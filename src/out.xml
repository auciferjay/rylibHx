<haxe>
	<class path="Array" params="T" file="C:\Motion-Twin\Haxe/std/Array.hx" extern="1">
		<iterator public="1" set="method">
			<f a=""><t path="Iterator"><c path="Array.T"/></t></f>
			<haxe_doc>Returns an iterator of the Array values.</haxe_doc>
		</iterator>
		<copy public="1" set="method">
			<f a=""><c path="Array"><c path="Array.T"/></c></f>
			<haxe_doc>Returns a copy of the Array. The values are not
		copied, only the Array structure.</haxe_doc>
		</copy>
		<remove public="1" set="method">
			<f a="x">
				<c path="Array.T"/>
				<e path="Bool"/>
			</f>
			<haxe_doc>Removes the first occurence of [x].
		Returns false if [x] was not present.
		Elements are compared by using standard equality.</haxe_doc>
		</remove>
		<insert public="1" set="method">
			<f a="pos:x">
				<c path="Int"/>
				<c path="Array.T"/>
				<e path="Void"/>
			</f>
			<haxe_doc>Inserts the element [x] at the position [pos].
		All elements after [pos] are moved one index ahead.</haxe_doc>
		</insert>
		<unshift public="1" set="method">
			<f a="x">
				<c path="Array.T"/>
				<e path="Void"/>
			</f>
			<haxe_doc>Adds the element [x] at the start of the array.</haxe_doc>
		</unshift>
		<toString public="1" set="method">
			<f a=""><c path="String"/></f>
			<haxe_doc>Returns a displayable representation of the Array content.</haxe_doc>
		</toString>
		<splice public="1" set="method">
			<f a="pos:len">
				<c path="Int"/>
				<c path="Int"/>
				<c path="Array"><c path="Array.T"/></c>
			</f>
			<haxe_doc>Removes [len] elements starting from [pos] an returns them.</haxe_doc>
		</splice>
		<sort public="1" set="method">
			<f a="f">
				<f a=":">
					<c path="Array.T"/>
					<c path="Array.T"/>
					<c path="Int"/>
				</f>
				<e path="Void"/>
			</f>
			<haxe_doc><![CDATA[Sort the Array according to the comparison function [f].
		[f(x,y)] should return [0] if [x == y], [>0] if [x > y]
		and [<0] if [x < y].]]></haxe_doc>
		</sort>
		<slice public="1" set="method">
			<f a="pos:?end">
				<c path="Int"/>
				<c path="Int"/>
				<c path="Array"><c path="Array.T"/></c>
			</f>
			<haxe_doc>Copies the range of the array starting at [pos] up to,
		but not including, [end]. Both [pos] and [end] can be
		negative to count from the end: -1 is the last item in
		the array.</haxe_doc>
		</slice>
		<shift public="1" set="method">
			<f a=""><t path="Null"><c path="Array.T"/></t></f>
			<haxe_doc>Removes the first element and returns it.</haxe_doc>
		</shift>
		<reverse public="1" set="method">
			<f a=""><e path="Void"/></f>
			<haxe_doc>Reverse the order of elements of the Array.</haxe_doc>
		</reverse>
		<push public="1" set="method">
			<f a="x">
				<c path="Array.T"/>
				<c path="Int"/>
			</f>
			<haxe_doc>Adds the element [x] at the end of the array.</haxe_doc>
		</push>
		<pop public="1" set="method">
			<f a=""><t path="Null"><c path="Array.T"/></t></f>
			<haxe_doc>Removes the last element of the array and returns it.</haxe_doc>
		</pop>
		<join public="1" set="method">
			<f a="sep">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>Returns a representation of an array with [sep] for separating each element.</haxe_doc>
		</join>
		<concat public="1" set="method">
			<f a="a">
				<c path="Array"><c path="Array.T"/></c>
				<c path="Array"><c path="Array.T"/></c>
			</f>
			<haxe_doc>Returns a new Array by appending [a] to [this].</haxe_doc>
		</concat>
		<length public="1" set="null">
			<c path="Int"/>
			<haxe_doc>The length of the Array</haxe_doc>
		</length>
		<new public="1" set="method">
			<f a=""><e path="Void"/></f>
			<haxe_doc>Creates a new Array.</haxe_doc>
		</new>
		<haxe_doc>An Array is a storage for values. You can access it using indexes or
	with its API. On the server side, it's often better to use a [List] which
	is less memory and CPU consuming, unless you really need indexed access.</haxe_doc>
	</class>
	<class path="Class" params="T" file="C:\Motion-Twin\Haxe/std/Class.hx" extern="1"><haxe_doc>An abstract type that represents a Class.
	See [Type] for the haXe Reflection API.</haxe_doc></class>
	<class path="Date" params="" file="C:\Motion-Twin\Haxe/std/Date.hx" extern="1">
		<now public="1" set="method" static="1">
			<f a=""><c path="Date"/></f>
			<haxe_doc>Returns a Date representing the current local time.</haxe_doc>
		</now>
		<fromTime public="1" set="method" static="1">
			<f a="t">
				<c path="Float"/>
				<c path="Date"/>
			</f>
			<haxe_doc>Returns a Date from a timestamp [t] which is the number of
		milliseconds elapsed since 1st January 1970.</haxe_doc>
		</fromTime>
		<fromString public="1" set="method" static="1">
			<f a="s">
				<c path="String"/>
				<c path="Date"/>
			</f>
			<haxe_doc>Returns a Date from a formated string of one of the following formats :
		[YYYY-MM-DD hh:mm:ss] or [YYYY-MM-DD] or [hh:mm:ss]. The first two formats
		are expressed in local time, the third in UTC Epoch.</haxe_doc>
		</fromString>
		<toString public="1" set="method">
			<f a=""><c path="String"/></f>
			<haxe_doc>Returns a string representation for the Date, by using the
		standard format [YYYY-MM-DD HH:MM:SS]. See [DateTools.format] for
		other formating rules.</haxe_doc>
		</toString>
		<getDay public="1" set="method">
			<f a=""><c path="Int"/></f>
			<haxe_doc>Returns the week day of the date (0-6 range).</haxe_doc>
		</getDay>
		<getDate public="1" set="method">
			<f a=""><c path="Int"/></f>
			<haxe_doc>Returns the day of the date (1-31 range).</haxe_doc>
		</getDate>
		<getMonth public="1" set="method">
			<f a=""><c path="Int"/></f>
			<haxe_doc>Returns the month of the date (0-11 range).</haxe_doc>
		</getMonth>
		<getFullYear public="1" set="method">
			<f a=""><c path="Int"/></f>
			<haxe_doc>Returns the full year of the date.</haxe_doc>
		</getFullYear>
		<getSeconds public="1" set="method">
			<f a=""><c path="Int"/></f>
			<haxe_doc>Returns the seconds of the date (0-59 range).</haxe_doc>
		</getSeconds>
		<getMinutes public="1" set="method">
			<f a=""><c path="Int"/></f>
			<haxe_doc>Returns the minutes value of the date (0-59 range).</haxe_doc>
		</getMinutes>
		<getHours public="1" set="method">
			<f a=""><c path="Int"/></f>
			<haxe_doc>Returns the hours value of the date (0-23 range).</haxe_doc>
		</getHours>
		<getTime public="1" set="method">
			<f a=""><c path="Float"/></f>
			<haxe_doc>Returns the timestamp of the date. It's the number of milliseconds
		elapsed since 1st January 1970. It might only have a per-second precision
		depending on the platforms.</haxe_doc>
		</getTime>
		<new public="1" set="method">
			<f a="year:month:day:hour:min:sec">
				<c path="Int"/>
				<c path="Int"/>
				<c path="Int"/>
				<c path="Int"/>
				<c path="Int"/>
				<c path="Int"/>
				<e path="Void"/>
			</f>
			<haxe_doc>Creates a new date object.</haxe_doc>
		</new>
		<haxe_doc>The Date class is used for date manipulation. There is some extra functions
	available in the [DateTools] class.</haxe_doc>
	</class>
	<class path="EReg" params="" file="C:\Motion-Twin\Haxe/std/flash/_std/EReg.hx">
		<customReplace public="1" set="method" line="74">
			<f a="s:f">
				<c path="String"/>
				<f a="">
					<c path="EReg"/>
					<c path="String"/>
				</f>
				<c path="String"/>
			</f>
			<haxe_doc>For each occurence of the pattern in the string [s], the function [f] is called and
		can return the string that needs to be replaced. All occurences are matched anyway,
		and setting the [g] flag might cause some incorrect behavior on some platforms.</haxe_doc>
		</customReplace>
		<replace public="1" set="method" line="70">
			<f a="s:by">
				<c path="String"/>
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>Replaces a pattern by another string. The [by] format can
		contains [$1] to [$9] that will correspond to groups matched
		while replacing. [$$] means the [$] character.</haxe_doc>
		</replace>
		<split public="1" set="method" line="63">
			<f a="s">
				<c path="String"/>
				<c path="Array"><c path="String"/></c>
			</f>
			<haxe_doc>Split a string by using the regular expression to match
		the separators.</haxe_doc>
		</split>
		<matchedPos public="1" set="method" line="58">
			<f a=""><a>
	<pos><c path="Int"/></pos>
	<len><c path="Int"/></len>
</a></f>
			<haxe_doc>Returns the position of the matched substring within the
		original matched string.</haxe_doc>
		</matchedPos>
		<matchedRight public="1" set="method" line="51">
			<f a=""><c path="String"/></f>
			<haxe_doc>Returns the part of the string that was at the right of
		of the matched substring.</haxe_doc>
		</matchedRight>
		<matchedLeft public="1" set="method" line="45">
			<f a=""><c path="String"/></f>
			<haxe_doc>Returns the part of the string that was as the left of
		of the matched substring.</haxe_doc>
		</matchedLeft>
		<matched public="1" set="method" line="41">
			<f a="n">
				<c path="Int"/>
				<c path="String"/>
			</f>
			<haxe_doc>Returns a matched group or throw an expection if there
		is no such group. If [n = 0], the whole matched substring
		is returned.</haxe_doc>
		</matched>
		<match public="1" set="method" line="35">
			<f a="s">
				<c path="String"/>
				<e path="Bool"/>
			</f>
			<haxe_doc>Tells if the regular expression matches the String.
		Updates the internal state accordingly.</haxe_doc>
		</match>
		<result><c path="+Array"/></result>
		<r><c path="flash.utils.RegExp"/></r>
		<new public="1" set="method" line="31">
			<f a="r:opt">
				<c path="String"/>
				<c path="String"/>
				<e path="Void"/>
			</f>
			<haxe_doc>Creates a new regular expression with pattern [r] and
		options [opt].</haxe_doc>
		</new>
		<haxe_doc>Regular expressions are a way to find regular patterns into
	Strings. Have a look at the tutorial on haXe website to learn
	how to use them.</haxe_doc>
		<meta><m n=":core_api"/></meta>
	</class>
	<class path="Enum" params="T" file="C:\Motion-Twin\Haxe/std/Enum.hx" extern="1"><haxe_doc>An abstract type that represents an Enum.
	See [Type] for the haXe Reflection API.</haxe_doc></class>
	<class path="EnumValue" params="" file="C:\Motion-Twin\Haxe/std/EnumValue.hx" extern="1"><haxe_doc>An abstract type that represents any enum value.
	See [Type] for the haXe Reflection API.</haxe_doc></class>
	<class path="Hash" params="T" file="C:\Motion-Twin\Haxe/std/flash/_std/Hash.hx">
		<toString public="1" set="method" line="66">
			<f a=""><c path="String"/></f>
			<haxe_doc>Returns an displayable representation of the hashtable content.</haxe_doc>
		</toString>
		<iterator public="1" set="method" line="57">
			<f a=""><t path="Iterator"><c path="Hash.T"/></t></f>
			<haxe_doc>Returns an iterator of all values in the hashtable.</haxe_doc>
		</iterator>
		<keys public="1" set="method" line="53">
			<f a=""><t path="Iterator"><c path="String"/></t></f>
			<haxe_doc>Returns an iterator of all keys in the hashtable.</haxe_doc>
		</keys>
		<remove public="1" set="method" line="46">
			<f a="key">
				<c path="String"/>
				<e path="Bool"/>
			</f>
			<haxe_doc>Removes a hashtable entry. Returns [true] if
		there was such entry.</haxe_doc>
		</remove>
		<exists public="1" set="method" line="42">
			<f a="key">
				<c path="String"/>
				<e path="Bool"/>
			</f>
			<haxe_doc>Tells if a value exists for the given key.
		In particular, it's useful to tells if a key has
		a [null] value versus no value.</haxe_doc>
		</exists>
		<get public="1" set="method" line="38">
			<f a="key">
				<c path="String"/>
				<t path="Null"><c path="Hash.T"/></t>
			</f>
			<haxe_doc>Get a value for the given key.</haxe_doc>
		</get>
		<set public="1" set="method" line="34">
			<f a="key:value">
				<c path="String"/>
				<c path="Hash.T"/>
				<e path="Void"/>
			</f>
			<haxe_doc>Set a value for the given key.</haxe_doc>
		</set>
		<h><c path="flash.utils.Dictionary"/></h>
		<new public="1" set="method" line="30">
			<f a=""><e path="Void"/></f>
			<haxe_doc>Creates a new empty hashtable.</haxe_doc>
		</new>
		<haxe_doc>Hashtable over a set of elements, using [String] as keys.
	Other kind of keys are not possible on all platforms since they
	can't always be implemented efficiently.</haxe_doc>
		<meta><m n=":core_api"/></meta>
	</class>
	<class path="IntIter" params="" file="C:\Motion-Twin\Haxe/std/IntIter.hx">
		<next public="1" set="method" line="53">
			<f a=""><c path="Int"/></f>
			<haxe_doc>Moves to the next item of the iterator.</haxe_doc>
		</next>
		<hasNext public="1" set="method" line="46">
			<f a=""><e path="Bool"/></f>
			<haxe_doc>Returns true if the iterator has other items, false otherwise.</haxe_doc>
		</hasNext>
		<max><c path="Int"/></max>
		<min><c path="Int"/></min>
		<new public="1" set="method" line="38">
			<f a="min:max">
				<c path="Int"/>
				<c path="Int"/>
				<e path="Void"/>
			</f>
			<haxe_doc><![CDATA[Iterate from [min] (inclusive) to [max] (exclusive).
		If [max <= min], the iterator will not act as a countdown.]]></haxe_doc>
		</new>
		<haxe_doc>Integer iterator. Used for interval implementation.</haxe_doc>
	</class>
	<class path="Math" params="" file="C:\Motion-Twin\Haxe/std/Math.hx" extern="1">
		<PI public="1" set="null" static="1"><c path="Float"/></PI>
		<NaN public="1" set="null" static="1"><c path="Float"/></NaN>
		<NEGATIVE_INFINITY public="1" set="null" static="1"><c path="Float"/></NEGATIVE_INFINITY>
		<POSITIVE_INFINITY public="1" set="null" static="1"><c path="Float"/></POSITIVE_INFINITY>
		<abs public="1" set="method" static="1"><f a="v">
	<c path="Float"/>
	<c path="Float"/>
</f></abs>
		<min public="1" set="method" static="1"><f a="a:b">
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
</f></min>
		<max public="1" set="method" static="1"><f a="a:b">
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
</f></max>
		<sin public="1" set="method" static="1"><f a="v">
	<c path="Float"/>
	<c path="Float"/>
</f></sin>
		<cos public="1" set="method" static="1"><f a="v">
	<c path="Float"/>
	<c path="Float"/>
</f></cos>
		<atan2 public="1" set="method" static="1"><f a="y:x">
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
</f></atan2>
		<tan public="1" set="method" static="1"><f a="v">
	<c path="Float"/>
	<c path="Float"/>
</f></tan>
		<exp public="1" set="method" static="1"><f a="v">
	<c path="Float"/>
	<c path="Float"/>
</f></exp>
		<log public="1" set="method" static="1"><f a="v">
	<c path="Float"/>
	<c path="Float"/>
</f></log>
		<sqrt public="1" set="method" static="1"><f a="v">
	<c path="Float"/>
	<c path="Float"/>
</f></sqrt>
		<round public="1" set="method" static="1"><f a="v">
	<c path="Float"/>
	<c path="Int"/>
</f></round>
		<floor public="1" set="method" static="1"><f a="v">
	<c path="Float"/>
	<c path="Int"/>
</f></floor>
		<ceil public="1" set="method" static="1"><f a="v">
	<c path="Float"/>
	<c path="Int"/>
</f></ceil>
		<atan public="1" set="method" static="1"><f a="v">
	<c path="Float"/>
	<c path="Float"/>
</f></atan>
		<asin public="1" set="method" static="1"><f a="v">
	<c path="Float"/>
	<c path="Float"/>
</f></asin>
		<acos public="1" set="method" static="1"><f a="v">
	<c path="Float"/>
	<c path="Float"/>
</f></acos>
		<pow public="1" set="method" static="1"><f a="v:exp">
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
</f></pow>
		<random public="1" set="method" static="1"><f a=""><c path="Float"/></f></random>
		<isFinite public="1" set="method" static="1"><f a="f">
	<c path="Float"/>
	<e path="Bool"/>
</f></isFinite>
		<isNaN public="1" set="method" static="1"><f a="f">
	<c path="Float"/>
	<e path="Bool"/>
</f></isNaN>
		<haxe_doc>This class defines mathematical functions and constants.</haxe_doc>
	</class>
	<class path="MyLibClasses" params="" file="MyLibClasses.hx">
		<main public="1" set="method" line="72" static="1"><f a=""><e path="Void"/></f></main>
		<haxe_doc>* ...
 * @author RoYan</haxe_doc>
	</class>
	<class path="Reflect" params="" file="C:\Motion-Twin\Haxe/std/flash/_std/Reflect.hx">
		<hasField public="1" set="method" line="28" static="1">
			<f a="o:field">
				<d/>
				<c path="String"/>
				<e path="Bool"/>
			</f>
			<haxe_doc>Tells if an object has a field set. This doesn't take into account the object prototype (class methods).</haxe_doc>
		</hasField>
		<field public="1" set="method" line="32" static="1">
			<f a="o:field">
				<d/>
				<c path="String"/>
				<d/>
			</f>
			<haxe_doc>Returns the field of an object, or null if [o] is not an object or doesn't have this field.</haxe_doc>
		</field>
		<setField public="1" get="inline" set="null" line="37" static="1">
			<f a="o:field:value">
				<d/>
				<c path="String"/>
				<d/>
				<e path="Void"/>
			</f>
			<haxe_doc>Set an object field value.</haxe_doc>
		</setField>
		<getProperty public="1" set="method" line="41" static="1">
			<f a="o:field">
				<d/>
				<c path="String"/>
				<d/>
			</f>
			<haxe_doc>Similar to field but also supports property (might be slower).</haxe_doc>
		</getProperty>
		<setProperty public="1" set="method" line="51" static="1">
			<f a="o:field:value">
				<d/>
				<c path="String"/>
				<d/>
				<e path="Void"/>
			</f>
			<haxe_doc>Similar to setField but also supports property (might be slower).</haxe_doc>
		</setProperty>
		<callMethod public="1" get="inline" set="null" line="59" static="1">
			<f a="o:func:args">
				<d/>
				<d/>
				<c path="Array"><d/></c>
				<d/>
			</f>
			<haxe_doc>Call a method with the given object and arguments.</haxe_doc>
		</callMethod>
		<fields public="1" set="method" line="63" static="1">
			<f a="o">
				<d/>
				<c path="Array"><c path="String"/></c>
			</f>
			<haxe_doc>Returns the list of fields of an object, excluding its prototype (class methods).</haxe_doc>
		</fields>
		<isFunction public="1" set="method" line="86" static="1">
			<f a="f">
				<d/>
				<e path="Bool"/>
			</f>
			<haxe_doc>Tells if a value is a function or not.</haxe_doc>
		</isFunction>
		<compare public="1" params="T" set="method" line="90" static="1">
			<f a="a:b">
				<c path="compare.T"/>
				<c path="compare.T"/>
				<c path="Int"/>
			</f>
			<haxe_doc>Generic comparison function, does not work for methods, see [compareMethods]</haxe_doc>
		</compare>
		<compareMethods public="1" set="method" line="96" static="1">
			<f a="f1:f2">
				<d/>
				<d/>
				<e path="Bool"/>
			</f>
			<haxe_doc>Compare two methods closures. Returns true if it's the same method of the same instance.</haxe_doc>
		</compareMethods>
		<isObject public="1" set="method" line="100" static="1">
			<f a="v">
				<d/>
				<e path="Bool"/>
			</f>
			<haxe_doc>Tells if a value is an object or not.</haxe_doc>
		</isObject>
		<deleteField public="1" set="method" line="115" static="1">
			<f a="o:f">
				<d/>
				<c path="String"/>
				<e path="Bool"/>
			</f>
			<haxe_doc>Delete an object field.</haxe_doc>
		</deleteField>
		<copy public="1" params="T" set="method" line="121" static="1">
			<f a="o">
				<c path="copy.T"/>
				<c path="copy.T"/>
			</f>
			<haxe_doc>Make a copy of the fields of an object.</haxe_doc>
		</copy>
		<makeVarArgs public="1" set="method" line="128" static="1">
			<f a="f">
				<f a="">
					<c path="Array"><d/></c>
					<d/>
				</f>
				<d/>
			</f>
			<haxe_doc>Transform a function taking an array of arguments into a function that can
		be called with any number of arguments.</haxe_doc>
		</makeVarArgs>
		<haxe_doc>The Reflect API is a way to manipulate values dynamicly through an
	abstract interface in an untyped manner. Use with care.</haxe_doc>
		<meta><m n=":core_api"/></meta>
	</class>
	<class path="Std" params="" file="C:\Motion-Twin\Haxe/std/flash/_std/Std.hx">
		<is public="1" set="method" line="29" static="1">
			<f a="v:t">
				<d/>
				<d/>
				<e path="Bool"/>
			</f>
			<haxe_doc>Tells if a value v is of the type t.</haxe_doc>
		</is>
		<string public="1" set="method" line="33" static="1">
			<f a="s">
				<d/>
				<c path="String"/>
			</f>
			<haxe_doc>Convert any value to a String</haxe_doc>
		</string>
		<int public="1" get="inline" set="null" line="37" static="1">
			<f a="x">
				<c path="Float"/>
				<c path="Int"/>
			</f>
			<haxe_doc>Convert a Float to an Int, rounded down.</haxe_doc>
		</int>
		<parseInt public="1" set="method" line="41" static="1">
			<f a="x">
				<c path="String"/>
				<t path="Null"><c path="Int"/></t>
			</f>
			<haxe_doc>Convert a String to an Int, parsing different possible representations. Returns [null] if could not be parsed.</haxe_doc>
		</parseInt>
		<parseFloat public="1" set="method" line="48" static="1">
			<f a="x">
				<c path="String"/>
				<c path="Float"/>
			</f>
			<haxe_doc>Convert a String to a Float, parsing different possible reprensations.</haxe_doc>
		</parseFloat>
		<random public="1" set="method" line="52" static="1">
			<f a="x">
				<c path="Int"/>
				<c path="Int"/>
			</f>
			<haxe_doc>Return a random integer between 0 included and x excluded.</haxe_doc>
		</random>
		<haxe_doc>The Std class provides standard methods for manipulating basic types.</haxe_doc>
		<meta><m n=":core_api"/></meta>
	</class>
	<enum path="Void" params="" file="C:\Motion-Twin\Haxe/std/StdTypes.hx" module="StdTypes"><haxe_doc>The standard Void type. Only [null] values can be of the type [Void].</haxe_doc></enum>
	<class path="Float" params="" file="C:\Motion-Twin\Haxe/std/StdTypes.hx" module="StdTypes" extern="1"><haxe_doc>The standard Float type, this is a double-precision IEEE 64bit float.</haxe_doc></class>
	<class path="Int" params="" file="C:\Motion-Twin\Haxe/std/StdTypes.hx" module="StdTypes" extern="1">
		<extends path="Float"/>
		<haxe_doc>The standard Int type. Its precision depends on the platform.</haxe_doc>
	</class>
	<typedef path="UInt" params="" file="C:\Motion-Twin\Haxe/std/StdTypes.hx" module="StdTypes">
		<c path="Int"/>
		<haxe_doc>The unsigned Int type is only defined for Flash9. It's currently
	handled the same as a normal Int.</haxe_doc>
	</typedef>
	<typedef path="Null" params="T" file="C:\Motion-Twin\Haxe/std/StdTypes.hx" module="StdTypes">
		<c path="Null.T"/>
		<haxe_doc>[Null] can be useful in two cases. In order to document some methods
	that accepts or can return a [null] value, or for the Flash9 compiler and AS3
	generator to distinguish between base values that can be null and others that
	can't.</haxe_doc>
	</typedef>
	<enum path="Bool" params="" file="C:\Motion-Twin\Haxe/std/StdTypes.hx" module="StdTypes">
		<true/>
		<false/>
		<haxe_doc>The standard Boolean type is represented as an enum with two choices.</haxe_doc>
	</enum>
	<class path="Dynamic" params="T" file="C:\Motion-Twin\Haxe/std/StdTypes.hx" module="StdTypes" extern="1"><haxe_doc>Dynamic is an internal compiler type which has special behavior.
	See the haXe language reference for more informations.</haxe_doc></class>
	<typedef path="Iterator" params="T" file="C:\Motion-Twin\Haxe/std/StdTypes.hx" module="StdTypes">
		<a>
			<next set="method"><f a=""><c path="Iterator.T"/></f></next>
			<hasNext set="method"><f a=""><e path="Bool"/></f></hasNext>
		</a>
		<haxe_doc>An Iterator is a structure that permits to list a given container
	values. It can be used by your own data structures. See the haXe
	documentation for more informations.</haxe_doc>
	</typedef>
	<typedef path="Iterable" params="T" file="C:\Motion-Twin\Haxe/std/StdTypes.hx" module="StdTypes">
		<a><iterator set="method"><f a=""><t path="Iterator"><c path="Iterable.T"/></t></f></iterator></a>
		<haxe_doc>An Iterable is a data structure which has an iterator() method.
	See [Lambda] for generic functions on iterable structures.</haxe_doc>
	</typedef>
	<class path="ArrayAccess" params="T" file="C:\Motion-Twin\Haxe/std/StdTypes.hx" module="StdTypes" extern="1" interface="1"><haxe_doc>ArrayAccess is used to indicate a class that can be accessed using brackets.
	The type parameter represent the type of the elements stored.</haxe_doc></class>
	<class path="String" params="" file="C:\Motion-Twin\Haxe/std/String.hx" extern="1">
		<fromCharCode public="1" set="method" static="1"><f a="code">
	<c path="Int"/>
	<c path="String"/>
</f></fromCharCode>
		<toString public="1" set="method">
			<f a=""><c path="String"/></f>
			<haxe_doc>Returns the String itself.</haxe_doc>
		</toString>
		<substring public="1" set="method">
			<f a="startIndex:?endIndex">
				<c path="Int"/>
				<c path="Int"/>
				<c path="String"/>
			</f>
			<haxe_doc><![CDATA[Returns a part of the String, taking from [startIndex] to [endIndex] - 1.
		If [endIndex] is not specified, length is used.
		If [startIndex] or [endIndex] is smaller than 0, than 0 is used.
		If [startIndex] > [endIndex] then they are swaped.]]></haxe_doc>
		</substring>
		<substr public="1" set="method">
			<f a="pos:?len">
				<c path="Int"/>
				<c path="Int"/>
				<c path="String"/>
			</f>
			<haxe_doc>Returns a part of the String, taking [len] characters starting from [pos].
		If [len] is not specified, it takes all the remaining characters.</haxe_doc>
		</substr>
		<split public="1" set="method">
			<f a="delimiter">
				<c path="String"/>
				<c path="Array"><c path="String"/></c>
			</f>
			<haxe_doc>Split the string using the specified delimiter.</haxe_doc>
		</split>
		<lastIndexOf public="1" set="method">
			<f a="str:?startIndex">
				<c path="String"/>
				<c path="Int"/>
				<c path="Int"/>
			</f>
			<haxe_doc>Similar to [indexOf] but returns the latest index.</haxe_doc>
		</lastIndexOf>
		<indexOf public="1" set="method">
			<f a="str:?startIndex">
				<c path="String"/>
				<c path="Int"/>
				<c path="Int"/>
			</f>
			<haxe_doc>Returns the index of first occurence of [value]
		Returns [1-1] if [value] is not found.
		The optional [startIndex] parameter allows you to specify at which character to start searching.
		The position returned is still relative to the beginning of the string.</haxe_doc>
		</indexOf>
		<charCodeAt public="1" set="method">
			<f a="index">
				<c path="Int"/>
				<t path="Null"><c path="Int"/></t>
			</f>
			<haxe_doc>Returns the character code at the given position.
		Returns [null] if outside of String bounds.</haxe_doc>
		</charCodeAt>
		<charAt public="1" set="method">
			<f a="index">
				<c path="Int"/>
				<c path="String"/>
			</f>
			<haxe_doc>Returns the character at the given position.
		Returns the empty String if outside of String bounds.</haxe_doc>
		</charAt>
		<toLowerCase public="1" set="method">
			<f a=""><c path="String"/></f>
			<haxe_doc>Returns an String where all characters have been lowercased.</haxe_doc>
		</toLowerCase>
		<toUpperCase public="1" set="method">
			<f a=""><c path="String"/></f>
			<haxe_doc>Returns an String where all characters have been uppercased.</haxe_doc>
		</toUpperCase>
		<length public="1" set="null">
			<c path="Int"/>
			<haxe_doc>The number of characters in the String.</haxe_doc>
		</length>
		<new public="1" set="method">
			<f a="string">
				<c path="String"/>
				<e path="Void"/>
			</f>
			<haxe_doc>Creates a copy from a given String.</haxe_doc>
		</new>
		<haxe_doc>The basic String class.</haxe_doc>
	</class>
	<class path="StringBuf" params="" file="C:\Motion-Twin\Haxe/std/StringBuf.hx">
		<toString public="1" get="inline" set="null" line="64">
			<f a=""><c path="String"/></f>
			<haxe_doc>Returns the content of the string buffer.
		The buffer is not emptied by this operation.</haxe_doc>
		</toString>
		<addSub public="1" get="inline" set="null" line="56">
			<f a="s:pos:?len">
				<c path="String"/>
				<c path="Int"/>
				<c path="Int"/>
				<e path="Void"/>
			</f>
			<haxe_doc>Adds a character to the string buffer.</haxe_doc>
		</addSub>
		<addChar public="1" get="inline" set="null" line="49">
			<f a="c">
				<c path="Int"/>
				<e path="Void"/>
			</f>
			<haxe_doc>Adds a part of a string to the string buffer.</haxe_doc>
		</addChar>
		<add public="1" get="inline" set="null" line="42">
			<f a="x">
				<d/>
				<e path="Void"/>
			</f>
			<haxe_doc>Adds the representation of any value to the string buffer.</haxe_doc>
		</add>
		<b><c path="String"/></b>
		<new public="1" set="method" line="37">
			<f a=""><e path="Void"/></f>
			<haxe_doc>Creates a new string buffer.</haxe_doc>
		</new>
		<haxe_doc>A String buffer is an efficient way to build a big string by
	appending small elements together.</haxe_doc>
	</class>
	<class path="StringTools" params="" file="C:\Motion-Twin\Haxe/std/StringTools.hx">
		<urlEncode public="1" set="method" line="41" static="1">
			<f a="s">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>Encode an URL by using the standard format.</haxe_doc>
		</urlEncode>
		<urlDecode public="1" set="method" line="68" static="1">
			<f a="s">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>Decode an URL using the standard format.</haxe_doc>
		</urlDecode>
		<htmlEscape public="1" set="method" line="95" static="1">
			<f a="s">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>Escape HTML special characters of the string.</haxe_doc>
		</htmlEscape>
		<htmlUnescape public="1" set="method" line="102" static="1">
			<f a="s">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>Unescape HTML special characters of the string.</haxe_doc>
		</htmlUnescape>
		<startsWith public="1" set="method" line="113" static="1">
			<f a="s:start">
				<c path="String"/>
				<c path="String"/>
				<e path="Bool"/>
			</f>
			<haxe_doc>Tells if the string [s] starts with the string [start].</haxe_doc>
		</startsWith>
		<endsWith public="1" set="method" line="126" static="1">
			<f a="s:end">
				<c path="String"/>
				<c path="String"/>
				<e path="Bool"/>
			</f>
			<haxe_doc>Tells if the string [s] ends with the string [end].</haxe_doc>
		</endsWith>
		<isSpace public="1" set="method" line="141" static="1">
			<f a="s:pos">
				<c path="String"/>
				<c path="Int"/>
				<e path="Bool"/>
			</f>
			<haxe_doc>Tells if the character in the string [s] at position [pos] is a space.</haxe_doc>
		</isSpace>
		<ltrim public="1" set="method" line="149" static="1">
			<f a="s">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>Removes spaces at the left of the String [s].</haxe_doc>
		</ltrim>
		<rtrim public="1" set="method" line="170" static="1">
			<f a="s">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>Removes spaces at the right of the String [s].</haxe_doc>
		</rtrim>
		<trim public="1" set="method" line="192" static="1">
			<f a="s">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>Removes spaces at the beginning and the end of the String [s].</haxe_doc>
		</trim>
		<rpad public="1" set="method" line="207" static="1">
			<f a="s:c:l">
				<c path="String"/>
				<c path="String"/>
				<c path="Int"/>
				<c path="String"/>
			</f>
			<haxe_doc>Pad the string [s] by appending [c] at its right until it reach [l] characters.</haxe_doc>
		</rpad>
		<lpad public="1" set="method" line="229" static="1">
			<f a="s:c:l">
				<c path="String"/>
				<c path="String"/>
				<c path="Int"/>
				<c path="String"/>
			</f>
			<haxe_doc>Pad the string [s] by appending [c] at its left until it reach [l] characters.</haxe_doc>
		</lpad>
		<replace public="1" set="method" line="254" static="1">
			<f a="s:sub:by">
				<c path="String"/>
				<c path="String"/>
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>Replace all occurences of the string [sub] in the string [s] by the string [by].</haxe_doc>
		</replace>
		<hex public="1" set="method" line="269" static="1">
			<f a="n:?digits">
				<c path="Int"/>
				<c path="Int"/>
				<c path="String"/>
			</f>
			<haxe_doc>Encode a number into a hexadecimal representation, with an optional number of zeros for left padding.</haxe_doc>
		</hex>
		<fastCodeAt public="1" get="inline" set="null" line="292" static="1">
			<f a="s:index">
				<c path="String"/>
				<c path="Int"/>
				<c path="Int"/>
			</f>
			<haxe_doc>Provides a fast native string charCodeAt access. Since the EOF value might vary depending on the platforms, always test with StringTools.isEOF.
		Only guaranteed to work if index in [0,s.length] range. Might not work with strings containing \0 char.</haxe_doc>
		</fastCodeAt>
		<isEOF public="1" get="inline" set="null" line="322" static="1"><f a="c">
	<c path="Int"/>
	<e path="Bool"/>
</f></isEOF>
		<haxe_doc>The StringTools class contains some extra functionalities for [String]
	manipulation. It's stored in a different class in order to prevent
	the standard [String] of being bloated and thus increasing the size of
	each application using it.</haxe_doc>
	</class>
	<enum path="ValueType" params="" file="C:\Motion-Twin\Haxe/std/flash/_std/Type.hx" module="Type">
		<TUnknown/>
		<TObject/>
		<TNull/>
		<TInt/>
		<TFunction/>
		<TFloat/>
		<TEnum a="e"><c path="Enum"><d/></c></TEnum>
		<TClass a="c"><c path="Class"><d/></c></TClass>
		<TBool/>
	</enum>
	<class path="Type" params="" file="C:\Motion-Twin\Haxe/std/flash/_std/Type.hx">
		<getClass public="1" params="T" set="method" line="40" static="1">
			<f a="o">
				<c path="getClass.T"/>
				<c path="Class"><c path="getClass.T"/></c>
			</f>
			<haxe_doc>Returns the class of a value or [null] if this value is not a Class instance.</haxe_doc>
		</getClass>
		<getEnum public="1" set="method" line="52" static="1">
			<f a="o">
				<c path="EnumValue"/>
				<c path="Enum"><d/></c>
			</f>
			<haxe_doc>Returns the enum of a value or [null] if this value is not an Enum instance.</haxe_doc>
		</getEnum>
		<getSuperClass public="1" set="method" line="66" static="1">
			<f a="c">
				<c path="Class"><d/></c>
				<c path="Class"><d/></c>
			</f>
			<haxe_doc>Returns the super-class of a class, or null if no super class.</haxe_doc>
		</getSuperClass>
		<getClassName public="1" set="method" line="73" static="1">
			<f a="c">
				<c path="Class"><d/></c>
				<c path="String"/>
			</f>
			<haxe_doc>Returns the complete name of a class.</haxe_doc>
		</getClassName>
		<getEnumName public="1" set="method" line="89" static="1">
			<f a="e">
				<c path="Enum"><d/></c>
				<c path="String"/>
			</f>
			<haxe_doc>Returns the complete name of an enum.</haxe_doc>
		</getEnumName>
		<resolveClass public="1" set="method" line="93" static="1">
			<f a="name">
				<c path="String"/>
				<c path="Class"><d/></c>
			</f>
			<haxe_doc>Evaluates a class from a name. The class must have been compiled
		to be accessible.</haxe_doc>
		</resolveClass>
		<resolveEnum public="1" set="method" line="117" static="1">
			<f a="name">
				<c path="String"/>
				<c path="Enum"><d/></c>
			</f>
			<haxe_doc>Evaluates an enum from a name. The enum must have been compiled
		to be accessible.</haxe_doc>
		</resolveEnum>
		<createInstance public="1" params="T" set="method" line="134" static="1">
			<f a="cl:args">
				<c path="Class"><c path="createInstance.T"/></c>
				<c path="Array"><d/></c>
				<c path="createInstance.T"/>
			</f>
			<haxe_doc>Creates an instance of the given class with the list of constructor arguments.</haxe_doc>
		</createInstance>
		<createEmptyInstance public="1" params="T" set="method" line="155" static="1">
			<f a="cl">
				<c path="Class"><c path="createEmptyInstance.T"/></c>
				<c path="createEmptyInstance.T"/>
			</f>
			<haxe_doc>Similar to [Reflect.createInstance] excepts that the constructor is not called.
		This enables you to create an instance without any side-effect.</haxe_doc>
		</createEmptyInstance>
		<createEnum public="1" params="T" set="method" line="168" static="1">
			<f a="e:constr:?params">
				<c path="Enum"><c path="createEnum.T"/></c>
				<c path="String"/>
				<c path="Array"><d/></c>
				<c path="createEnum.T"/>
			</f>
			<haxe_doc>Create an instance of an enum by using a constructor name and parameters.</haxe_doc>
		</createEnum>
		<createEnumIndex public="1" params="T" set="method" line="180" static="1">
			<f a="e:index:?params">
				<c path="Enum"><c path="createEnumIndex.T"/></c>
				<c path="Int"/>
				<c path="Array"><d/></c>
				<c path="createEnumIndex.T"/>
			</f>
			<haxe_doc>Create an instance of an enum by using a constructor index and parameters.</haxe_doc>
		</createEnumIndex>
		<describe set="method" line="186" static="1"><f a="t:fact">
	<d/>
	<e path="Bool"/>
	<c path="Array"><c path="String"/></c>
</f></describe>
		<getInstanceFields public="1" set="method" line="203" static="1">
			<f a="c">
				<c path="Class"><d/></c>
				<c path="Array"><c path="String"/></c>
			</f>
			<haxe_doc>Returns the list of instance fields.</haxe_doc>
		</getInstanceFields>
		<getClassFields public="1" set="method" line="207" static="1">
			<f a="c">
				<c path="Class"><d/></c>
				<c path="Array"><c path="String"/></c>
			</f>
			<haxe_doc>Returns the list of a class static fields.</haxe_doc>
		</getClassFields>
		<getEnumConstructs public="1" set="method" line="214" static="1">
			<f a="e">
				<c path="Enum"><d/></c>
				<c path="Array"><c path="String"/></c>
			</f>
			<haxe_doc>Returns all the available constructor names for an enum.</haxe_doc>
		</getEnumConstructs>
		<typeof public="1" set="method" line="219" static="1">
			<f a="v">
				<d/>
				<e path="ValueType"/>
			</f>
			<haxe_doc>Returns the runtime type of a value.</haxe_doc>
		</typeof>
		<enumEq public="1" params="T" set="method" line="251" static="1">
			<f a="a:b">
				<c path="enumEq.T"/>
				<c path="enumEq.T"/>
				<e path="Bool"/>
			</f>
			<haxe_doc>Recursively compare two enums constructors and parameters.</haxe_doc>
		</enumEq>
		<enumConstructor public="1" set="method" line="268" static="1">
			<f a="e">
				<c path="EnumValue"/>
				<c path="String"/>
			</f>
			<haxe_doc>Returns the constructor of an enum</haxe_doc>
		</enumConstructor>
		<enumParameters public="1" set="method" line="272" static="1">
			<f a="e">
				<c path="EnumValue"/>
				<c path="Array"><d/></c>
			</f>
			<haxe_doc>Returns the parameters of an enum</haxe_doc>
		</enumParameters>
		<enumIndex public="1" get="inline" set="null" line="276" static="1">
			<f a="e">
				<c path="EnumValue"/>
				<c path="Int"/>
			</f>
			<haxe_doc>Returns the index of the constructor of an enum</haxe_doc>
		</enumIndex>
		<allEnums public="1" params="T" set="method" line="280" static="1">
			<f a="e">
				<c path="Enum"><c path="allEnums.T"/></c>
				<c path="Array"><c path="allEnums.T"/></c>
			</f>
			<haxe_doc>Returns the list of all enum values that don't take any parameter.</haxe_doc>
		</allEnums>
		<haxe_doc>The haXe Reflection API enables you to retreive informations about any value,
	Classes and Enums at runtime.</haxe_doc>
		<meta><m n=":core_api"/></meta>
	</class>
	<enum path="XmlType" params="" file="C:\Motion-Twin\Haxe/std/flash/_std/Xml.hx" module="Xml"/>
	<class path="Xml" params="" file="C:\Motion-Twin\Haxe/std/flash/_std/Xml.hx">
		<Element public="1" set="null" static="1">
			<e path="XmlType"/>
			<haxe_doc>A type of Xml node.</haxe_doc>
		</Element>
		<PCData public="1" set="null" static="1">
			<e path="XmlType"/>
			<haxe_doc>A type of Xml node.</haxe_doc>
		</PCData>
		<CData public="1" set="null" static="1">
			<e path="XmlType"/>
			<haxe_doc>A type of Xml node.</haxe_doc>
		</CData>
		<Comment public="1" set="null" static="1">
			<e path="XmlType"/>
			<haxe_doc>A type of Xml node.</haxe_doc>
		</Comment>
		<DocType public="1" set="null" static="1">
			<e path="XmlType"/>
			<haxe_doc>A type of Xml node.</haxe_doc>
		</DocType>
		<Prolog public="1" set="null" static="1">
			<e path="XmlType"/>
			<haxe_doc>A type of Xml node.</haxe_doc>
		</Prolog>
		<Document public="1" set="null" static="1">
			<e path="XmlType"/>
			<haxe_doc>A type of Xml node.</haxe_doc>
		</Document>
		<parse public="1" set="method" line="49" static="1">
			<f a="str">
				<c path="String"/>
				<c path="Xml"/>
			</f>
			<haxe_doc>Parse a String into an Xml object.</haxe_doc>
		</parse>
		<compare set="method" line="71" static="1">
			<f a="a:b">
				<c path="Xml"/>
				<c path="Xml"/>
				<e path="Bool"/>
			</f>
			<meta><m n=":keep"/></meta>
		</compare>
		<createElement public="1" set="method" line="77" static="1">
			<f a="name">
				<c path="String"/>
				<c path="Xml"/>
			</f>
			<haxe_doc>Creates a node of the given type.</haxe_doc>
		</createElement>
		<createPCData public="1" set="method" line="81" static="1">
			<f a="data">
				<c path="String"/>
				<c path="Xml"/>
			</f>
			<haxe_doc>Creates a node of the given type.</haxe_doc>
		</createPCData>
		<createCData public="1" set="method" line="86" static="1">
			<f a="data">
				<c path="String"/>
				<c path="Xml"/>
			</f>
			<haxe_doc>Creates a node of the given type.</haxe_doc>
		</createCData>
		<createComment public="1" set="method" line="90" static="1">
			<f a="data">
				<c path="String"/>
				<c path="Xml"/>
			</f>
			<haxe_doc>Creates a node of the given type.</haxe_doc>
		</createComment>
		<createDocType public="1" set="method" line="95" static="1">
			<f a="data">
				<c path="String"/>
				<c path="Xml"/>
			</f>
			<haxe_doc>Creates a node of the given type.</haxe_doc>
		</createDocType>
		<createProlog public="1" set="method" line="99" static="1">
			<f a="data">
				<c path="String"/>
				<c path="Xml"/>
			</f>
			<haxe_doc>Creates a node of the given type.</haxe_doc>
		</createProlog>
		<createDocument public="1" set="method" line="104" static="1">
			<f a=""><c path="Xml"/></f>
			<haxe_doc>Creates a node of the given type.</haxe_doc>
		</createDocument>
		<getNodeType set="method" line="108" static="1"><f a="node">
	<c path="flash.xml.XML"/>
	<e path="XmlType"/>
</f></getNodeType>
		<wrap set="method" line="184" static="1"><f a="node:?type">
	<c path="flash.xml.XML"/>
	<e path="XmlType"/>
	<c path="Xml"/>
</f></wrap>
		<toString public="1" set="method" line="389">
			<f a=""><c path="String"/></f>
			<haxe_doc>Returns a String representation of the Xml node.</haxe_doc>
		</toString>
		<insertChild public="1" set="method" line="379">
			<f a="x:pos">
				<c path="Xml"/>
				<c path="Int"/>
				<e path="Void"/>
			</f>
			<haxe_doc>Inserts a child at the given position among the other childs.</haxe_doc>
		</insertChild>
		<removeChild public="1" set="method" line="368">
			<f a="x">
				<c path="Xml"/>
				<e path="Bool"/>
			</f>
			<haxe_doc>Removes a child from the Document or Element.
		Returns true if the child was successfuly removed.</haxe_doc>
		</removeChild>
		<addChild public="1" set="method" line="361">
			<f a="x">
				<c path="Xml"/>
				<e path="Void"/>
			</f>
			<haxe_doc>Adds a child node to the Document or Element.
		One node can only be inside one given node which is indicated by the [parent] property.</haxe_doc>
		</addChild>
		<firstElement public="1" set="method" line="352">
			<f a=""><c path="Xml"/></f>
			<haxe_doc>Returns the first child node which is an Element.</haxe_doc>
		</firstElement>
		<firstChild public="1" set="method" line="343">
			<f a=""><c path="Xml"/></f>
			<haxe_doc>Returns the first child node.</haxe_doc>
		</firstChild>
		<elementsNamed public="1" set="method" line="318">
			<f a="name">
				<c path="String"/>
				<t path="Iterator"><c path="Xml"/></t>
			</f>
			<haxe_doc>Returns an iterator of all child nodes which are Elements with the given nodeName.
		Only works if the current node is an Element or a Document.</haxe_doc>
		</elementsNamed>
		<elements public="1" set="method" line="302">
			<f a=""><t path="Iterator"><c path="Xml"/></t></f>
			<haxe_doc>Returns an iterator of all child nodes which are Elements.
		Only works if the current node is an Element or a Document.</haxe_doc>
		</elements>
		<iterator public="1" set="method" line="286">
			<f a=""><t path="Iterator"><c path="Xml"/></t></f>
			<haxe_doc>Returns an iterator of all child nodes.
		Only works if the current node is an Element or a Document.</haxe_doc>
		</iterator>
		<attributes public="1" set="method" line="270">
			<f a=""><t path="Iterator"><c path="String"/></t></f>
			<haxe_doc>Returns an [Iterator] on all the attribute names.</haxe_doc>
		</attributes>
		<exists public="1" set="method" line="259">
			<f a="att">
				<c path="String"/>
				<e path="Bool"/>
			</f>
			<haxe_doc>Tells if the Element node has a given attribute.
		Attributes are case-sensitive.</haxe_doc>
		</exists>
		<remove public="1" set="method" line="249">
			<f a="att">
				<c path="String"/>
				<e path="Void"/>
			</f>
			<haxe_doc>Removes an attribute for an Element node.
		Attributes are case-sensitive.</haxe_doc>
		</remove>
		<set public="1" set="method" line="228">
			<f a="att:value">
				<c path="String"/>
				<c path="String"/>
				<e path="Void"/>
			</f>
			<haxe_doc>Set the given attribute value for an Element node.
		Attributes are case-sensitive.</haxe_doc>
		</set>
		<get public="1" set="method" line="211">
			<f a="att">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>Get the given attribute of an Element node. Returns [null] if not found.
		Attributes are case-sensitive.</haxe_doc>
		</get>
		<getAttribNS set="method" line="198"><f a="cur:ns">
	<c path="flash.xml.XML"/>
	<c path="Array"><c path="String"/></c>
	<c path="flash.xml.XMLList"/>
</f></getAttribNS>
		<wraps set="method" line="191"><f a="xList">
	<c path="flash.xml.XMLList"/>
	<c path="Array"><c path="Xml"/></c>
</f></wraps>
		<getParent set="method" line="179"><f a=""><c path="Xml"/></f></getParent>
		<setNodeValue set="method" line="153"><f a="v">
	<c path="String"/>
	<c path="String"/>
</f></setNodeValue>
		<getNodeValue set="method" line="144"><f a=""><c path="String"/></f></getNodeValue>
		<setNodeName set="method" line="131"><f a="n">
	<c path="String"/>
	<c path="String"/>
</f></setNodeName>
		<getNodeName set="method" line="124"><f a=""><c path="String"/></f></getNodeName>
		<_node><c path="flash.xml.XML"/></_node>
		<parent public="1" get="getParent" set="null">
			<c path="Xml"/>
			<haxe_doc>Returns the parent object in the Xml hierarchy.
		The parent can be [null], an Element or a Document.</haxe_doc>
		</parent>
		<nodeValue public="1" get="getNodeValue" set="setNodeValue">
			<c path="String"/>
			<haxe_doc>Returns the node value. Only works if the Xml node is not an Element or a Document.</haxe_doc>
		</nodeValue>
		<nodeName public="1" get="getNodeName" set="setNodeName">
			<c path="String"/>
			<haxe_doc>Returns the node name of an Element.</haxe_doc>
		</nodeName>
		<nodeType public="1" set="null">
			<e path="XmlType"/>
			<haxe_doc>Returns the type of the Xml Node. This should be used before
		accessing other functions since some might raise an exception
		if the node type is not correct.</haxe_doc>
		</nodeType>
		<new set="method" line="75"><f a=""><e path="Void"/></f></new>
		<haxe_doc>The standard Xml class and parsing.
	More API to manipulate XML are available in the [haxe.xml] package.</haxe_doc>
		<meta><m n=":core_api"/></meta>
	</class>
	<typedef path="cn.royan.hl.bases.Dictionary" params="" file="cn/royan/hl/bases/Dictionary.hx">
		<c path="flash.utils.Dictionary"/>
		<haxe_doc><![CDATA[* ...
 * Flash环境下为Dictionary，其他环境下为Dynamic<Dynamic>
 * @author RoYan]]></haxe_doc>
	</typedef>
	<class path="flash.events.IEventDispatcher" params="" file="C:\Motion-Twin\Haxe/std/flash/events/IEventDispatcher.hx" extern="1" interface="1">
		<willTrigger public="1" set="method"><f a="type">
	<c path="String"/>
	<e path="Bool"/>
</f></willTrigger>
		<removeEventListener public="1" set="method"><f a="type:listener:?useCapture">
	<c path="String"/>
	<f a="">
		<d/>
		<e path="Void"/>
	</f>
	<e path="Bool"/>
	<e path="Void"/>
</f></removeEventListener>
		<hasEventListener public="1" set="method"><f a="type">
	<c path="String"/>
	<e path="Bool"/>
</f></hasEventListener>
		<dispatchEvent public="1" set="method"><f a="event">
	<c path="flash.events.Event"/>
	<e path="Bool"/>
</f></dispatchEvent>
		<addEventListener public="1" set="method"><f a="type:listener:?useCapture:?priority:?useWeakReference">
	<c path="String"/>
	<f a="">
		<d/>
		<e path="Void"/>
	</f>
	<e path="Bool"/>
	<c path="Int"/>
	<e path="Bool"/>
	<e path="Void"/>
</f></addEventListener>
	</class>
	<class path="flash.events.EventDispatcher" params="" file="C:\Motion-Twin\Haxe/std/flash/events/EventDispatcher.hx" extern="1">
		<implements path="flash.events.IEventDispatcher"/>
		<willTrigger public="1" set="method"><f a="type">
	<c path="String"/>
	<e path="Bool"/>
</f></willTrigger>
		<toString public="1" set="method"><f a=""><c path="String"/></f></toString>
		<removeEventListener public="1" set="method"><f a="type:listener:?useCapture">
	<c path="String"/>
	<f a="">
		<d/>
		<e path="Void"/>
	</f>
	<e path="Bool"/>
	<e path="Void"/>
</f></removeEventListener>
		<hasEventListener public="1" set="method"><f a="type">
	<c path="String"/>
	<e path="Bool"/>
</f></hasEventListener>
		<dispatchEvent public="1" set="method"><f a="event">
	<c path="flash.events.Event"/>
	<e path="Bool"/>
</f></dispatchEvent>
		<addEventListener public="1" set="method"><f a="type:listener:?useCapture:?priority:?useWeakReference">
	<c path="String"/>
	<f a="">
		<d/>
		<e path="Void"/>
	</f>
	<e path="Bool"/>
	<c path="Int"/>
	<e path="Bool"/>
	<e path="Void"/>
</f></addEventListener>
		<new public="1" set="method"><f a="?target">
	<c path="flash.events.IEventDispatcher"/>
	<e path="Void"/>
</f></new>
	</class>
	<class path="cn.royan.hl.bases.DispatcherBase" params="" file="cn/royan/hl/bases/DispatcherBase.hx">
		<extends path="flash.events.EventDispatcher"/>
		<removeAllEventListeners public="1" set="method" line="74">
			<f a=""><e path="Void"/></f>
			<haxe_doc>* 删除所有监听事件</haxe_doc>
		</removeAllEventListeners>
		<removeEventListener public="1" set="method" line="47" override="1">
			<f a="type:listener:?useCapture">
				<c path="String"/>
				<f a="">
					<d/>
					<e path="Void"/>
				</f>
				<e path="Bool"/>
				<e path="Void"/>
			</f>
			<haxe_doc>* 移除监听事件
	 * @param	type
	 * @param	listener
	 * @param	useCapture</haxe_doc>
		</removeEventListener>
		<addEventListener public="1" set="method" line="27" override="1">
			<f a="type:listener:?useCapture:?priority:?useWeakReference">
				<c path="String"/>
				<f a="">
					<d/>
					<e path="Void"/>
				</f>
				<e path="Bool"/>
				<c path="Int"/>
				<e path="Bool"/>
				<e path="Void"/>
			</f>
			<haxe_doc>* 添加监听事件
	 * @param	type
	 * @param	listener
	 * @param	useCapture
	 * @param	priority
	 * @param	useWeakReference</haxe_doc>
		</addEventListener>
		<evtListenerDirectory><c path="Array"><t path="cn.royan.hl.bases.Dictionary"/></c></evtListenerDirectory>
		<evtListenerType><c path="Array"><c path="String"/></c></evtListenerType>
		<new public="1" set="method" line="14"><f a="?target">
	<c path="flash.events.IEventDispatcher"/>
	<e path="Void"/>
</f></new>
		<haxe_doc><![CDATA[* ...
 * 基础事件驱动类，继承于EventDispatcher
 * <p>DispatcherBase->EventDispatcher</p>
 * @author RoYan]]></haxe_doc>
	</class>
	<class path="cn.royan.hl.bases.WeakMap" params="" file="cn/royan/hl/bases/WeakMap.hx">
		<__instance static="1"><c path="cn.royan.hl.bases.WeakMap"/></__instance>
		<getInstance public="1" set="method" line="33" static="1">
			<f a=""><c path="cn.royan.hl.bases.WeakMap"/></f>
			<haxe_doc>* 获取单例
	 * @return</haxe_doc>
		</getInstance>
		<clear public="1" set="method" line="198">
			<f a="key">
				<c path="String"/>
				<e path="Void"/>
			</f>
			<haxe_doc>* 清楚键值
	 * @param	key</haxe_doc>
		</clear>
		<getKeys public="1" set="method" line="185">
			<f a="value">
				<d/>
				<c path="Array"><d/></c>
			</f>
			<haxe_doc>* 获取对象对应的所有键值
	 * @param	value
	 * @return</haxe_doc>
		</getKeys>
		<getValue public="1" set="method" line="158">
			<f a="key">
				<c path="String"/>
				<d/>
			</f>
			<haxe_doc>* 获取对象
	 * @param	key
	 * @return</haxe_doc>
		</getValue>
		<set public="1" set="method" line="116">
			<f a="key:value">
				<c path="String"/>
				<d/>
				<e path="Void"/>
			</f>
			<haxe_doc>* 设置对象
	 * @param	key		键值
	 * @param	value	对象</haxe_doc>
		</set>
		<containKey public="1" set="method" line="101">
			<f a="key">
				<c path="String"/>
				<e path="Bool"/>
			</f>
			<haxe_doc>* 判断是否包含键值
	 * @param	key
	 * @return</haxe_doc>
		</containKey>
		<containValue public="1" set="method" line="86">
			<f a="value">
				<d/>
				<e path="Bool"/>
			</f>
			<haxe_doc>* 判断是否包含对象
	 * @param	value
	 * @return</haxe_doc>
		</containValue>
		<getValues public="1" set="method" line="72">
			<f a=""><c path="Array"><d/></c></f>
			<haxe_doc>* 获取对象列表
	 * @return</haxe_doc>
		</getValues>
		<getAllKeys public="1" set="method" line="63">
			<f a=""><c path="Array"><c path="String"/></c></f>
			<haxe_doc>* 获取键值列表
	 * @return</haxe_doc>
		</getAllKeys>
		<getLength public="1" set="method" line="54">
			<f a=""><c path="Int"/></f>
			<haxe_doc>* 获取键值数量
	 * @return</haxe_doc>
		</getLength>
		<length><c path="Int"/></length>
		<keys><c path="Array"><c path="String"/></c></keys>
		<map><c path="flash.utils.TypedDictionary">
	<d/>
	<c path="Array"><c path="String"/></c>
</c></map>
		<new set="method" line="39"><f a=""><e path="Void"/></f></new>
		<haxe_doc>* ...
 * 弱引用池
 * @author RoYan</haxe_doc>
	</class>
	<class path="flash.utils.Dictionary" params="" file="C:\Motion-Twin\Haxe/std/flash/utils/Dictionary.hx" extern="1">
		<new public="1" set="method"><f a="?weakKeys">
	<e path="Bool"/>
	<e path="Void"/>
</f></new>
		<haxe_dynamic><d/></haxe_dynamic>
	</class>
	<class path="flash.utils.TypedDictionary" params="K:T" file="C:\Motion-Twin\Haxe/std/flash/utils/TypedDictionary.hx">
		<extends path="flash.utils.Dictionary"/>
		<iterator public="1" set="method" line="52"><f a=""><t path="Iterator"><c path="flash.utils.TypedDictionary.K"/></t></f></iterator>
		<keys public="1" get="inline" set="null" line="48"><f a=""><c path="Array"><c path="flash.utils.TypedDictionary.K"/></c></f></keys>
		<delete public="1" get="inline" set="null" line="44"><f a="k">
	<c path="flash.utils.TypedDictionary.K"/>
	<e path="Void"/>
</f></delete>
		<exists public="1" get="inline" set="null" line="40"><f a="k">
	<c path="flash.utils.TypedDictionary.K"/>
	<unknown/>
</f></exists>
		<set public="1" get="inline" set="null" line="36"><f a="k:v">
	<c path="flash.utils.TypedDictionary.K"/>
	<c path="flash.utils.TypedDictionary.T"/>
	<e path="Void"/>
</f></set>
		<get public="1" get="inline" set="null" line="32"><f a="k">
	<c path="flash.utils.TypedDictionary.K"/>
	<t path="Null"><c path="flash.utils.TypedDictionary.T"/></t>
</f></get>
		<new public="1" set="method" line="30"><f a="?weakKeys">
	<e path="Bool"/>
	<e path="Void"/>
</f></new>
		<haxe_doc>This is a typed version of the Flash9 Dictionary class.</haxe_doc>
	</class>
	<class path="cn.royan.hl.bases.PoolMap" params="" file="cn/royan/hl/bases/PoolMap.hx">
		<maxValue public="1" line="13" static="1"><c path="Int"/></maxValue>
		<__weakMap line="15" static="1"><c path="cn.royan.hl.bases.WeakMap"/></__weakMap>
		<pools line="16" static="1"><t path="cn.royan.hl.bases.Dictionary"/></pools>
		<getPool set="method" line="18" static="1"><f a="type">
	<c path="Class"><d/></c>
	<c path="Array"><d/></c>
</f></getPool>
		<createInstanceByType set="method" line="29" static="1"><f a="type:parameters">
	<c path="Class"><d/></c>
	<c path="Array"><d/></c>
	<d/>
</f></createInstanceByType>
		<getInstanceByType public="1" set="method" line="46" static="1">
			<f a="type:?parameters">
				<c path="Class"><d/></c>
				<c path="Array"><d/></c>
				<d/>
			</f>
			<haxe_doc>* 获取类实例
	 * @param	type			类
	 * @param	?parameters		带入参数
	 * @return</haxe_doc>
		</getInstanceByType>
		<disposeInstance public="1" set="method" line="69" static="1">
			<f a="object:?type">
				<d/>
				<c path="Class"><d/></c>
				<e path="Void"/>
			</f>
			<haxe_doc>* 销毁对象
	 * @param	object		待销毁对象
	 * @param	type		对象类型</haxe_doc>
		</disposeInstance>
		<haxe_doc>* ...
 * 对象池类
 * @author RoYan</haxe_doc>
	</class>
	<class path="cn.royan.hl.bases.WaterDrop" params="" file="cn/royan/hl/bases/PoolMap.hx" module="cn.royan.hl.bases.PoolMap">
		<createInstanceByType set="method" line="122"><f a="type:parameters">
	<c path="Class"><d/></c>
	<c path="Array"><d/></c>
	<d/>
</f></createInstanceByType>
		<autoKill public="1"><c path="Int"/></autoKill>
		<key public="1"><c path="String"/></key>
		<params public="1"><c path="Array"><d/></c></params>
		<type public="1"><c path="Class"><d/></c></type>
		<target public="1"><d/></target>
		<new public="1" set="method" line="112"><f a="type:parameters">
	<c path="Class"><d/></c>
	<c path="Array"><d/></c>
	<e path="Void"/>
</f></new>
	</class>
	<class path="cn.royan.hl.interfaces.IDisposeBase" params="" file="cn/royan/hl/interfaces/IDisposeBase.hx" interface="1">
		<dispose public="1" set="method">
			<f a=""><e path="Void"/></f>
			<haxe_doc>* 销毁</haxe_doc>
		</dispose>
		<haxe_doc>* ...
 * 可销毁接口
 * @author RoYan</haxe_doc>
	</class>
	<class path="cn.royan.hl.bases.TimerBase" params="" file="cn/royan/hl/bases/TimerBase.hx">
		<implements path="cn.royan.hl.interfaces.IDisposeBase"/>
		<TIMERBASE_DELAY get="inline" set="null" line="19" static="1"><c path="Int"/></TIMERBASE_DELAY>
		<timer static="1"><c path="haxe.Timer"/></timer>
		<timerNumber line="25" static="1"><c path="Int"/></timerNumber>
		<timerlists line="26" static="1"><c path="Array"><c path="cn.royan.hl.bases.TimerBase"/></c></timerlists>
		<timerHandler set="method" line="140" static="1"><f a=""><e path="Void"/></f></timerHandler>
		<dispose public="1" set="method" line="129">
			<f a=""><e path="Void"/></f>
			<haxe_doc>* 销毁</haxe_doc>
		</dispose>
		<needRender public="1" set="method" line="115">
			<f a=""><c path="Int"/></f>
			<haxe_doc>* 获取执行次数
	 * @return</haxe_doc>
		</needRender>
		<excute public="1" set="method" line="99">
			<f a=""><e path="Void"/></f>
			<haxe_doc>* 执行</haxe_doc>
		</excute>
		<remain public="1" set="method" line="91">
			<f a=""><c path="Float"/></f>
			<haxe_doc>* 剩余时间
	 * @return</haxe_doc>
		</remain>
		<stop public="1" set="method" line="81">
			<f a=""><e path="Void"/></f>
			<haxe_doc>* 停止计时</haxe_doc>
		</stop>
		<start public="1" set="method" line="57">
			<f a=""><e path="Void"/></f>
			<haxe_doc>* 开始计时</haxe_doc>
		</start>
		<isStart public="1" set="null">
			<e path="Bool"/>
			<haxe_doc>* 计时是否开始</haxe_doc>
		</isStart>
		<loopLimit><c path="Int"/></loopLimit>
		<jumped><c path="Int"/></jumped>
		<current><c path="Float"/></current>
		<begin><c path="Int"/></begin>
		<last><c path="Int"/></last>
		<delay><c path="Float"/></delay>
		<callFun><f a=""><e path="Void"/></f></callFun>
		<new public="1" set="method" line="47">
			<f a="time:f:?loop">
				<c path="Float"/>
				<f a=""><e path="Void"/></f>
				<c path="Int"/>
				<e path="Void"/>
			</f>
			<haxe_doc>* 创建计时器
	 * @param	time	时间间隔（ms）
	 * @param	f		执行函数
	 * @param	loop	执行次数 0为无限次</haxe_doc>
		</new>
		<haxe_doc>* ...
 * 基础计时器
 * @author RoYan</haxe_doc>
	</class>
	<class path="cn.royan.hl.consts.PrintConst" params="" file="cn/royan/hl/consts/PrintConst.hx">
		<UTILS public="1" get="inline" set="null" line="12" static="1">
			<c path="Int"/>
			<haxe_doc>* 工具</haxe_doc>
		</UTILS>
		<UIS public="1" get="inline" set="null" line="17" static="1">
			<c path="Int"/>
			<haxe_doc>* 视图</haxe_doc>
		</UIS>
		<SERVICES public="1" get="inline" set="null" line="22" static="1">
			<c path="Int"/>
			<haxe_doc>* 服务</haxe_doc>
		</SERVICES>
		<RESOURCES public="1" get="inline" set="null" line="27" static="1">
			<c path="Int"/>
			<haxe_doc>* 资源</haxe_doc>
		</RESOURCES>
		<BASES public="1" get="inline" set="null" line="32" static="1">
			<c path="Int"/>
			<haxe_doc>* 基础</haxe_doc>
		</BASES>
		<haxe_doc>* ...
 * @author RoYan</haxe_doc>
	</class>
	<class path="cn.royan.hl.consts.UiConst" params="" file="cn/royan/hl/consts/UiConst.hx">
		<DEFAULT_CSS public="1" get="inline" set="null" line="12" static="1">
			<c path="String"/>
			<haxe_doc>* 默认样式</haxe_doc>
		</DEFAULT_CSS>
		<STATUS_LEN public="1" get="inline" set="null" line="18" static="1">
			<c path="Int"/>
			<haxe_doc><![CDATA[* 视图状态 5
	 * 正常->鼠标移入->鼠标按下->选中->禁用]]></haxe_doc>
		</STATUS_LEN>
		<INTERACTIVE_STATUS_NORMAL public="1" get="inline" set="null" line="19" static="1"><c path="Int"/></INTERACTIVE_STATUS_NORMAL>
		<INTERACTIVE_STATUS_OVER public="1" get="inline" set="null" line="20" static="1"><c path="Int"/></INTERACTIVE_STATUS_OVER>
		<INTERACTIVE_STATUS_DOWN public="1" get="inline" set="null" line="21" static="1"><c path="Int"/></INTERACTIVE_STATUS_DOWN>
		<INTERACTIVE_STATUS_SELECTED public="1" get="inline" set="null" line="22" static="1"><c path="Int"/></INTERACTIVE_STATUS_SELECTED>
		<INTERACTIVE_STATUS_DISABLE public="1" get="inline" set="null" line="23" static="1"><c path="Int"/></INTERACTIVE_STATUS_DISABLE>
		<CONTAINER_HORIZONTAL_LEFT public="1" get="inline" set="null" line="29" static="1">
			<c path="Int"/>
			<haxe_doc><![CDATA[* 水平对齐方式
	 * 左对齐->居中->右对齐]]></haxe_doc>
		</CONTAINER_HORIZONTAL_LEFT>
		<CONTAINER_HORIZONTAL_CENTER public="1" get="inline" set="null" line="30" static="1"><c path="Int"/></CONTAINER_HORIZONTAL_CENTER>
		<CONTAINER_HORIZONTAL_RIGHT public="1" get="inline" set="null" line="31" static="1"><c path="Int"/></CONTAINER_HORIZONTAL_RIGHT>
		<CONTAINER_VERTICAL_TOP public="1" get="inline" set="null" line="37" static="1">
			<c path="Int"/>
			<haxe_doc><![CDATA[* 垂直对齐方式
	 * 顶部对齐->居中->底部对齐]]></haxe_doc>
		</CONTAINER_VERTICAL_TOP>
		<CONTAINER_VERTICAL_MIDDLE public="1" get="inline" set="null" line="38" static="1"><c path="Int"/></CONTAINER_VERTICAL_MIDDLE>
		<CONTAINER_VERTICAL_BOTTOM public="1" get="inline" set="null" line="39" static="1"><c path="Int"/></CONTAINER_VERTICAL_BOTTOM>
		<CONTAINER_CONTENT_ALIGN_TOP public="1" get="inline" set="null" line="45" static="1">
			<c path="Int"/>
			<haxe_doc><![CDATA[* 单行垂直对齐方式
	 * 顶部对齐->居中->底部对齐]]></haxe_doc>
		</CONTAINER_CONTENT_ALIGN_TOP>
		<CONTAINER_CONTENT_ALIGN_MIDDLE public="1" get="inline" set="null" line="46" static="1"><c path="Int"/></CONTAINER_CONTENT_ALIGN_MIDDLE>
		<CONTAINER_CONTENT_ALIGN_BOTTOM public="1" get="inline" set="null" line="47" static="1"><c path="Int"/></CONTAINER_CONTENT_ALIGN_BOTTOM>
		<SCROLLBAR_TYPE_HORIZONTAL public="1" get="inline" set="null" line="53" static="1">
			<c path="Int"/>
			<haxe_doc><![CDATA[* 滚动条类型
	 * 水平方向->垂直方向]]></haxe_doc>
		</SCROLLBAR_TYPE_HORIZONTAL>
		<SCROLLBAR_TYPE_VERICAL public="1" get="inline" set="null" line="54" static="1"><c path="Int"/></SCROLLBAR_TYPE_VERICAL>
		<SCROLL_TYPE_NONE public="1" get="inline" set="null" line="60" static="1">
			<c path="Int"/>
			<haxe_doc><![CDATA[* 滚动条显示类型
	 * 不显示->只显示水平方向->只显示垂直方向->都显示]]></haxe_doc>
		</SCROLL_TYPE_NONE>
		<SCROLL_TYPE_HORIZONTAL_ONLY public="1" get="inline" set="null" line="61" static="1"><c path="Int"/></SCROLL_TYPE_HORIZONTAL_ONLY>
		<SCROLL_TYPE_VERICAL_ONLY public="1" get="inline" set="null" line="62" static="1"><c path="Int"/></SCROLL_TYPE_VERICAL_ONLY>
		<SCROLL_TYPE_HANDV public="1" get="inline" set="null" line="63" static="1"><c path="Int"/></SCROLL_TYPE_HANDV>
		<TEXT_ALIGN_LEFT public="1" get="inline" set="null" line="69" static="1">
			<c path="Int"/>
			<haxe_doc><![CDATA[* 文字对齐方式
	 * 左对齐->居中->右对齐]]></haxe_doc>
		</TEXT_ALIGN_LEFT>
		<TEXT_ALIGN_CENTER public="1" get="inline" set="null" line="70" static="1"><c path="Int"/></TEXT_ALIGN_CENTER>
		<TEXT_ALIGN_RIGHT public="1" get="inline" set="null" line="71" static="1"><c path="Int"/></TEXT_ALIGN_RIGHT>
		<TEXT_AUTOSIZE_NONE public="1" get="inline" set="null" line="77" static="1">
			<c path="Int"/>
			<haxe_doc><![CDATA[* 文字自动对齐方式
	 * 不对齐->左对齐->居中->右对齐]]></haxe_doc>
		</TEXT_AUTOSIZE_NONE>
		<TEXT_AUTOSIZE_LEFT public="1" get="inline" set="null" line="78" static="1"><c path="Int"/></TEXT_AUTOSIZE_LEFT>
		<TEXT_AUTOSIZE_CENTER public="1" get="inline" set="null" line="79" static="1"><c path="Int"/></TEXT_AUTOSIZE_CENTER>
		<TEXT_AUTOSIZE_RIGHT public="1" get="inline" set="null" line="80" static="1"><c path="Int"/></TEXT_AUTOSIZE_RIGHT>
		<TEXT_TYPE_INPUT public="1" get="inline" set="null" line="86" static="1">
			<c path="Int"/>
			<haxe_doc><![CDATA[* 文本类型
	 * 输入框->密码框]]></haxe_doc>
		</TEXT_TYPE_INPUT>
		<TEXT_TYPE_PASSWORD public="1" get="inline" set="null" line="87" static="1"><c path="Int"/></TEXT_TYPE_PASSWORD>
		<haxe_doc>* ...
 * @author RoYan</haxe_doc>
	</class>
	<class path="flash.events.Event" params="" file="C:\Motion-Twin\Haxe/std/flash/events/Event.hx" extern="1">
		<ACTIVATE public="1" static="1"><c path="String"/></ACTIVATE>
		<ADDED public="1" static="1"><c path="String"/></ADDED>
		<ADDED_TO_STAGE public="1" static="1"><c path="String"/></ADDED_TO_STAGE>
		<CANCEL public="1" static="1"><c path="String"/></CANCEL>
		<CHANGE public="1" static="1"><c path="String"/></CHANGE>
		<CLEAR public="1" static="1">
			<c path="String"/>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</CLEAR>
		<CLOSE public="1" static="1"><c path="String"/></CLOSE>
		<COMPLETE public="1" static="1"><c path="String"/></COMPLETE>
		<CONNECT public="1" static="1"><c path="String"/></CONNECT>
		<CONTEXT3D_CREATE public="1" static="1">
			<c path="String"/>
			<meta><m n=":require"><e>flash11</e></m></meta>
		</CONTEXT3D_CREATE>
		<COPY public="1" static="1">
			<c path="String"/>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</COPY>
		<CUT public="1" static="1">
			<c path="String"/>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</CUT>
		<DEACTIVATE public="1" static="1"><c path="String"/></DEACTIVATE>
		<ENTER_FRAME public="1" static="1"><c path="String"/></ENTER_FRAME>
		<EXIT_FRAME public="1" static="1">
			<c path="String"/>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</EXIT_FRAME>
		<FRAME_CONSTRUCTED public="1" static="1">
			<c path="String"/>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</FRAME_CONSTRUCTED>
		<FRAME_LABEL public="1" static="1">
			<c path="String"/>
			<meta><m n=":require"><e>flash11_3</e></m></meta>
		</FRAME_LABEL>
		<FULLSCREEN public="1" static="1"><c path="String"/></FULLSCREEN>
		<ID3 public="1" static="1"><c path="String"/></ID3>
		<INIT public="1" static="1"><c path="String"/></INIT>
		<MOUSE_LEAVE public="1" static="1"><c path="String"/></MOUSE_LEAVE>
		<OPEN public="1" static="1"><c path="String"/></OPEN>
		<PASTE public="1" static="1">
			<c path="String"/>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</PASTE>
		<REMOVED public="1" static="1"><c path="String"/></REMOVED>
		<REMOVED_FROM_STAGE public="1" static="1"><c path="String"/></REMOVED_FROM_STAGE>
		<RENDER public="1" static="1"><c path="String"/></RENDER>
		<RESIZE public="1" static="1"><c path="String"/></RESIZE>
		<SCROLL public="1" static="1"><c path="String"/></SCROLL>
		<SELECT public="1" static="1"><c path="String"/></SELECT>
		<SELECT_ALL public="1" static="1">
			<c path="String"/>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</SELECT_ALL>
		<SOUND_COMPLETE public="1" static="1"><c path="String"/></SOUND_COMPLETE>
		<SUSPEND public="1" static="1">
			<c path="String"/>
			<meta><m n=":require"><e>flash11_3</e></m></meta>
		</SUSPEND>
		<TAB_CHILDREN_CHANGE public="1" static="1"><c path="String"/></TAB_CHILDREN_CHANGE>
		<TAB_ENABLED_CHANGE public="1" static="1"><c path="String"/></TAB_ENABLED_CHANGE>
		<TAB_INDEX_CHANGE public="1" static="1"><c path="String"/></TAB_INDEX_CHANGE>
		<TEXTURE_READY public="1" static="1">
			<c path="String"/>
			<meta><m n=":require"><e>flash11_3</e></m></meta>
		</TEXTURE_READY>
		<TEXT_INTERACTION_MODE_CHANGE public="1" static="1">
			<c path="String"/>
			<meta><m n=":require"><e>flash11</e></m></meta>
		</TEXT_INTERACTION_MODE_CHANGE>
		<UNLOAD public="1" static="1"><c path="String"/></UNLOAD>
		<toString public="1" set="method"><f a=""><c path="String"/></f></toString>
		<stopPropagation public="1" set="method"><f a=""><e path="Void"/></f></stopPropagation>
		<stopImmediatePropagation public="1" set="method"><f a=""><e path="Void"/></f></stopImmediatePropagation>
		<preventDefault public="1" set="method"><f a=""><e path="Void"/></f></preventDefault>
		<isDefaultPrevented public="1" set="method"><f a=""><e path="Bool"/></f></isDefaultPrevented>
		<formatToString public="1" set="method"><f a="className:?p1:?p2:?p3:?p4:?p5">
	<c path="String"/>
	<d/>
	<d/>
	<d/>
	<d/>
	<d/>
	<c path="String"/>
</f></formatToString>
		<clone public="1" set="method"><f a=""><c path="flash.events.Event"/></f></clone>
		<type public="1" set="null"><c path="String"/></type>
		<target public="1" set="null"><d/></target>
		<eventPhase public="1" set="null"><e path="flash.events.EventPhase"/></eventPhase>
		<currentTarget public="1" set="null"><d/></currentTarget>
		<cancelable public="1" set="null"><e path="Bool"/></cancelable>
		<bubbles public="1" set="null"><e path="Bool"/></bubbles>
		<new public="1" set="method"><f a="type:?bubbles:?cancelable">
	<c path="String"/>
	<e path="Bool"/>
	<e path="Bool"/>
	<e path="Void"/>
</f></new>
	</class>
	<class path="cn.royan.hl.events.DatasEvent" params="" file="cn/royan/hl/events/DatasEvent.hx">
		<extends path="flash.events.Event"/>
		<DATA_CHANGE public="1" get="inline" set="null" line="15" static="1">
			<c path="String"/>
			<haxe_doc>* 修改事件</haxe_doc>
		</DATA_CHANGE>
		<DATA_DOING public="1" get="inline" set="null" line="20" static="1">
			<c path="String"/>
			<haxe_doc>* 进行事件</haxe_doc>
		</DATA_DOING>
		<DATA_DONE public="1" get="inline" set="null" line="25" static="1">
			<c path="String"/>
			<haxe_doc>* 完成事件</haxe_doc>
		</DATA_DONE>
		<DATA_CREATE public="1" get="inline" set="null" line="30" static="1">
			<c path="String"/>
			<haxe_doc>* 创建事件</haxe_doc>
		</DATA_CREATE>
		<DATA_DESTROY public="1" get="inline" set="null" line="35" static="1">
			<c path="String"/>
			<haxe_doc>* 摧毁事件</haxe_doc>
		</DATA_DESTROY>
		<DATA_ERROR public="1" get="inline" set="null" line="40" static="1">
			<c path="String"/>
			<haxe_doc>* 错误事件</haxe_doc>
		</DATA_ERROR>
		<getParams public="1" set="method" line="77">
			<f a=""><d/></f>
			<haxe_doc>* 获取事件数据
	 * @return</haxe_doc>
		</getParams>
		<clone public="1" set="method" line="68" override="1">
			<f a=""><c path="flash.events.Event"/></f>
			<haxe_doc>* 复制事件
	 * @return</haxe_doc>
		</clone>
		<_c><e path="Bool"/></_c>
		<_b><e path="Bool"/></_b>
		<_d><d/></_d>
		<_t><c path="String"/></_t>
		<new public="1" set="method" line="54">
			<f a="t:?d:?b:?c">
				<c path="String"/>
				<d/>
				<e path="Bool"/>
				<e path="Bool"/>
				<e path="Void"/>
			</f>
			<haxe_doc>* 创建事件
	 * @param	t		事件类型
	 * @param	?d		事件数据
	 * @param	?b		是否冒泡
	 * @param	?c		是否可取消</haxe_doc>
		</new>
		<haxe_doc>* ...
 * 基础事件
 * @author RoYan</haxe_doc>
	</class>
	<typedef path="cn.royan.hl.geom.Range" params="" file="cn/royan/hl/geom/Range.hx">
		<a>
			<y>
				<c path="Float"/>
				<meta><m n=":optional"/></meta>
			</y>
			<x>
				<c path="Float"/>
				<meta><m n=":optional"/></meta>
			</x>
			<width>
				<c path="Float"/>
				<meta><m n=":optional"/></meta>
			</width>
			<height>
				<c path="Float"/>
				<meta><m n=":optional"/></meta>
			</height>
		</a>
		<haxe_doc>* ...
 * 范围
 * @author RoYan</haxe_doc>
	</typedef>
	<class path="cn.royan.hl.interfaces.services.IServiceBase" params="" file="cn/royan/hl/interfaces/services/IServiceBase.hx" interface="1">
		<implements path="cn.royan.hl.interfaces.IDisposeBase"/>
		<implements path="flash.events.IEventDispatcher"/>
		<getIsServicing public="1" set="method">
			<f a=""><e path="Bool"/></f>
			<haxe_doc>* 获取交互状态
	 * @return</haxe_doc>
		</getIsServicing>
		<getData public="1" set="method">
			<f a=""><d/></f>
			<haxe_doc>* 获取回应值
	 * @return</haxe_doc>
		</getData>
		<setCallbacks public="1" set="method">
			<f a="value">
				<d/>
				<e path="Void"/>
			</f>
			<haxe_doc>* 设置毁掉函数
	 * @param	value	{done:..., doing:..., create:..., error:..., destroy:...}</haxe_doc>
		</setCallbacks>
		<close public="1" set="method">
			<f a=""><e path="Void"/></f>
			<haxe_doc>* 关闭请求</haxe_doc>
		</close>
		<connect public="1" set="method">
			<f a=""><e path="Void"/></f>
			<haxe_doc>* 开始请求</haxe_doc>
		</connect>
		<sendRequest public="1" set="method">
			<f a="?url:?extra">
				<c path="String"/>
				<d/>
				<e path="Void"/>
			</f>
			<haxe_doc>* 设置请求
	 * @param	url
	 * @param	extra</haxe_doc>
		</sendRequest>
		<haxe_doc><![CDATA[* ...
 * 交互接口，继承自可销毁接口
 * <p>IServiceBase->(IDisposeBase, IEventDispatcher)</p>
 * @author RoYan]]></haxe_doc>
	</class>
	<class path="cn.royan.hl.interfaces.services.IServiceMessageBase" params="" file="cn/royan/hl/interfaces/services/IServiceMessageBase.hx" interface="1">
		<implements path="cn.royan.hl.interfaces.IDisposeBase"/>
		<serialize public="1" set="method">
			<f a=""><e path="Void"/></f>
			<haxe_doc>* 序列化</haxe_doc>
		</serialize>
		<writeMessageFromBytes public="1" set="method">
			<f a="input">
				<c path="haxe.io.Bytes"/>
				<e path="Void"/>
			</f>
			<haxe_doc>* 从输入值解析
	 * @param	input</haxe_doc>
		</writeMessageFromBytes>
		<readMessageData public="1" set="method">
			<f a=""><t path="haxe.io.BytesData"/></f>
			<haxe_doc>* 获取数据值
	 * @return</haxe_doc>
		</readMessageData>
		<writeMessageData public="1" set="method">
			<f a="value">
				<t path="haxe.io.BytesData"/>
				<e path="Void"/>
			</f>
			<haxe_doc>* 设置数据值
	 * @param	value</haxe_doc>
		</writeMessageData>
		<readMessageLen public="1" set="method">
			<f a=""><c path="Int"/></f>
			<haxe_doc>* 获取数据长度
	 * @return</haxe_doc>
		</readMessageLen>
		<writeMessageLen public="1" set="method">
			<f a="value">
				<c path="Int"/>
				<e path="Void"/>
			</f>
			<haxe_doc>* 设置数据长度
	 * @param	value</haxe_doc>
		</writeMessageLen>
		<readMessageType public="1" set="method">
			<f a=""><c path="Int"/></f>
			<haxe_doc>* 获取数据类型
	 * @return</haxe_doc>
		</readMessageType>
		<writeMessageType public="1" set="method">
			<f a="value">
				<c path="Int"/>
				<e path="Void"/>
			</f>
			<haxe_doc>* 设置数据类型
	 * @param	value</haxe_doc>
		</writeMessageType>
		<haxe_doc><![CDATA[* ...
 * 交互数据接口，继承自可销毁接口
 * <p>IServiceMessageBase->IDisposeBase</p>
 * @author RoYan]]></haxe_doc>
	</class>
	<class path="cn.royan.hl.interfaces.uis.IUiBase" params="" file="cn/royan/hl/interfaces/uis/IUiBase.hx" interface="1">
		<implements path="cn.royan.hl.interfaces.IDisposeBase"/>
		<getInclude public="1" set="method">
			<f a=""><c path="Array"><c path="String"/></c></f>
			<haxe_doc>* 获取容器状态对应显示列表
	 * @return</haxe_doc>
		</getInclude>
		<setInclude public="1" set="method">
			<f a="args">
				<c path="Array"><c path="String"/></c>
				<e path="Void"/>
			</f>
			<haxe_doc>* 设置容器状态对应显示列表
	 * @param	args</haxe_doc>
		</setInclude>
		<getExclude public="1" set="method">
			<f a=""><c path="Array"><c path="String"/></c></f>
			<haxe_doc>* 获取容器状态对应隐藏列表
	 * @return</haxe_doc>
		</getExclude>
		<setExclude public="1" set="method">
			<f a="args">
				<c path="Array"><c path="String"/></c>
				<e path="Void"/>
			</f>
			<haxe_doc>* 设置容器状态对应隐藏列表
	 * @param	args</haxe_doc>
		</setExclude>
		<getDispatcher public="1" set="method">
			<f a=""><c path="flash.events.EventDispatcher"/></f>
			<haxe_doc>* 获取事件发送者
	 * @return</haxe_doc>
		</getDispatcher>
		<setStyle public="1" set="method">
			<f a="value">
				<c path="cn.royan.hl.uis.style.Style"/>
				<e path="Void"/>
			</f>
			<haxe_doc>* 设置样式名称
	 * @param 	value</haxe_doc>
		</setStyle>
		<getScale public="1" set="method">
			<f a=""><c path="Float"/></f>
			<haxe_doc>* 获取缩放比列
	 * @return</haxe_doc>
		</getScale>
		<setScale public="1" set="method">
			<f a="value">
				<c path="Float"/>
				<e path="Void"/>
			</f>
			<haxe_doc>* 设置缩放比例
	 * @param	value</haxe_doc>
		</setScale>
		<getTexture public="1" set="method">
			<f a=""><d/></f>
			<haxe_doc>* 获取当前材质
	 * @return</haxe_doc>
		</getTexture>
		<setTexture public="1" set="method">
			<f a="texture:?frames">
				<d/>
				<c path="Int"/>
				<e path="Void"/>
			</f>
			<haxe_doc>* 设置材质
	 * @param	texture		Sparrow/Texture(Starling)
	 * @param	frames</haxe_doc>
		</setTexture>
		<getDefaultTexture public="1" set="method">
			<f a=""><d/></f>
			<haxe_doc>* 获取默认材质
	 * @return Sparrow/Texture(Starling)</haxe_doc>
		</getDefaultTexture>
		<getRange public="1" set="method">
			<f a=""><t path="cn.royan.hl.geom.Range"/></f>
			<haxe_doc>* 获取范围
	 * @return	{width:..., height:..., x:..., y:...}</haxe_doc>
		</getRange>
		<setRange public="1" set="method">
			<f a="value">
				<t path="cn.royan.hl.geom.Range"/>
				<e path="Void"/>
			</f>
			<haxe_doc>* 设置范围
	 * @param	value	{width:..., height:..., x:..., y:...}</haxe_doc>
		</setRange>
		<setPosition public="1" set="method">
			<f a="cX:cY">
				<c path="Float"/>
				<c path="Float"/>
				<e path="Void"/>
			</f>
			<haxe_doc>* 设置位置
	 * @param	cX
	 * @param	cY</haxe_doc>
		</setPosition>
		<setSize public="1" set="method">
			<f a="cWidth:cHeight">
				<c path="Float"/>
				<c path="Float"/>
				<e path="Void"/>
			</f>
			<haxe_doc>* 设置尺寸
	 * @param	cWidth
	 * @param	cHeight</haxe_doc>
		</setSize>
		<setBorder public="1" set="method">
			<f a="thick:color:alpha:?rx:?ry">
				<c path="Int"/>
				<c path="Int"/>
				<c path="Float"/>
				<c path="Int"/>
				<c path="Int"/>
				<e path="Void"/>
			</f>
			<haxe_doc>* 设置边框样式
	 * @param	thick 	粗细度
	 * @param	color 	颜色值
	 * @param	alpha 	透明度
	 * @param	rx		x轴半径
	 * @param	ry		y轴半径</haxe_doc>
		</setBorder>
		<getAlphas public="1" set="method">
			<f a=""><c path="Array"><d/></c></f>
			<haxe_doc>* 获取背景透明度
	 * @return [1, .5, 0]/[[1, .5, 0],[1, .5, 0]]</haxe_doc>
		</getAlphas>
		<getColors public="1" set="method">
			<f a=""><c path="Array"><d/></c></f>
			<haxe_doc>* 获取背景颜色
	 * @return [0xFFFFFF, 0xFFFF00, 0xFF0000]/[[0xFFFFFF, 0xFFFF00, 0xFF0000],[0xFFFFFF, 0xFFFF00, 0xFF0000]]</haxe_doc>
		</getColors>
		<setColorsAndAplhas public="1" set="method">
			<f a="color:alpha">
				<c path="Array"><d/></c>
				<c path="Array"><d/></c>
				<e path="Void"/>
			</f>
			<haxe_doc>* 设置背景颜色以及对应透明度
	 * @param	color 	[0xFFFFFF, 0xFFFF00, 0xFF0000]/[[0xFFFFFF, 0xFFFF00, 0xFF0000],[0xFFFFFF, 0xFFFF00, 0xFF0000]]
	 * @param	alpha 	[1, .5, 0]/[[1, .5, 0],[1, .5, 0]]</haxe_doc>
		</setColorsAndAplhas>
		<setCallbacks public="1" set="method">
			<f a="value">
				<d/>
				<e path="Void"/>
			</f>
			<haxe_doc>* 设置毁掉函数
	 * @param	value {click:..., up:..., down:..., over:..., out:...}</haxe_doc>
		</setCallbacks>
		<draw public="1" set="method">
			<f a=""><e path="Void"/></f>
			<haxe_doc>* 画布刷新</haxe_doc>
		</draw>
		<haxe_doc><![CDATA[* ...
 * 基础显示接口，所有显示类继承此接口，继承自可销毁接口
 * <p>IUiBase->IDisposeBase</p>
 * @author RoYan]]></haxe_doc>
	</class>
	<class path="cn.royan.hl.interfaces.uis.IUiContainerBase" params="" file="cn/royan/hl/interfaces/uis/IUiContainerBase.hx" interface="1">
		<implements path="cn.royan.hl.interfaces.uis.IUiBase"/>
		<setHide public="1" set="method">
			<f a="effect">
				<f a=":">
					<d/>
					<d/>
					<e path="Void"/>
				</f>
				<e path="Void"/>
			</f>
			<haxe_doc><![CDATA[* 设置移除显示项时执行函数, effect中callback方法必须被执行
	 * @param	effect 		function effect(item:IUiBase, callback:Void->Void):Void]]></haxe_doc>
		</setHide>
		<getState public="1" set="method">
			<f a=""><c path="String"/></f>
			<haxe_doc>* 获取容器当前状态
	 * @return</haxe_doc>
		</getState>
		<setState public="1" set="method">
			<f a="value">
				<c path="String"/>
				<e path="Void"/>
			</f>
			<haxe_doc>* 设置容器当前状态
	 * @param	value</haxe_doc>
		</setState>
		<setShow public="1" set="method">
			<f a="effect">
				<f a="">
					<d/>
					<e path="Void"/>
				</f>
				<e path="Void"/>
			</f>
			<haxe_doc>* 设置添加显示项时执行函数
	 * @param	effect		function effect(item:IUiBase):Void</haxe_doc>
		</setShow>
		<getItems public="1" set="method">
			<f a=""><c path="Array"><c path="cn.royan.hl.interfaces.uis.IUiBase"/></c></f>
			<haxe_doc>* 获取显示列表
	 * @return</haxe_doc>
		</getItems>
		<getIndexByItem public="1" set="method">
			<f a="item">
				<c path="cn.royan.hl.interfaces.uis.IUiBase"/>
				<c path="Int"/>
			</f>
			<haxe_doc>* 获取显示项索引
	 * @param	item
	 * @return</haxe_doc>
		</getIndexByItem>
		<getItemAt public="1" set="method">
			<f a="index">
				<c path="Int"/>
				<c path="cn.royan.hl.interfaces.uis.IUiBase"/>
			</f>
			<haxe_doc>* 获取显示项
	 * @param	index
	 * @return</haxe_doc>
		</getItemAt>
		<removeAllItems public="1" set="method">
			<f a=""><e path="Void"/></f>
			<haxe_doc>* 清空显示项</haxe_doc>
		</removeAllItems>
		<removeItemAt public="1" set="method">
			<f a="index">
				<c path="Int"/>
				<c path="cn.royan.hl.interfaces.uis.IUiBase"/>
			</f>
			<haxe_doc>* 移除显示项
	 * @param	index</haxe_doc>
		</removeItemAt>
		<removeItem public="1" set="method">
			<f a="item">
				<c path="cn.royan.hl.interfaces.uis.IUiBase"/>
				<c path="cn.royan.hl.interfaces.uis.IUiBase"/>
			</f>
			<haxe_doc>* 移除显示想
	 * @param	item</haxe_doc>
		</removeItem>
		<addItemAt public="1" set="method">
			<f a="item:index">
				<c path="cn.royan.hl.interfaces.uis.IUiBase"/>
				<c path="Int"/>
				<c path="cn.royan.hl.interfaces.uis.IUiBase"/>
			</f>
			<haxe_doc>* 添加显示项
	 * @param	item
	 * @param	index</haxe_doc>
		</addItemAt>
		<addItem public="1" set="method">
			<f a="item">
				<c path="cn.royan.hl.interfaces.uis.IUiBase"/>
				<c path="cn.royan.hl.interfaces.uis.IUiBase"/>
			</f>
			<haxe_doc>* 添加显示项
	 * @param	item</haxe_doc>
		</addItem>
		<haxe_doc><![CDATA[* ...
 * 基础容器接口，所有容器类继承此接口，继承自基础显示接口
 * <p>IUiContainerBase->IUiBase</p>
 * @author RoYan]]></haxe_doc>
	</class>
	<class path="cn.royan.hl.interfaces.uis.IUiContainerAlignBase" params="" file="cn/royan/hl/interfaces/uis/IUiContainerAlignBase.hx" interface="1">
		<implements path="cn.royan.hl.interfaces.uis.IUiContainerBase"/>
		<setMove public="1" set="method">
			<f a="effect">
				<f a="">
					<d/>
					<e path="Void"/>
				</f>
				<e path="Void"/>
			</f>
			<haxe_doc>* 设置调整显示项位置时执行执行函数
	 * @param	effect		function effect(item:IUiBase):Void</haxe_doc>
		</setMove>
		<setMargins public="1" set="method">
			<f a="left:top:right:bottom">
				<c path="Int"/>
				<c path="Int"/>
				<c path="Int"/>
				<c path="Int"/>
				<e path="Void"/>
			</f>
			<haxe_doc>* 设置显示列表与边框的间距
	 * @param	left
	 * @param	top
	 * @param	right
	 * @param	bottom</haxe_doc>
		</setMargins>
		<setGaps public="1" set="method">
			<f a="gapX:gapY">
				<c path="Int"/>
				<c path="Int"/>
				<e path="Void"/>
			</f>
			<haxe_doc>* 设置水平及垂直方向间隔
	 * @param	gapX
	 * @param	gapY</haxe_doc>
		</setGaps>
		<setContentAlign public="1" set="method">
			<f a="value">
				<c path="Int"/>
				<e path="Void"/>
			</f>
			<haxe_doc>* 设置内容对齐方式
	 * @param	value	CONTAINER_CONTENT_ALIGN_TOP / CONTAINER_CONTENT_ALIGN_MIDDLE / CONTAINER_CONTENT_ALIGN_BOTTOM</haxe_doc>
		</setContentAlign>
		<setVerticalAlign public="1" set="method">
			<f a="value">
				<c path="Int"/>
				<e path="Void"/>
			</f>
			<haxe_doc>* 设置垂直对齐方式
	 * @param	value	CONTAINER_VERTICAL_TOP / CONTAINER_VERTICAL_MIDDLE / CONTAINER_VERTICAL_BOTTOM</haxe_doc>
		</setVerticalAlign>
		<setHorizontalAlign public="1" set="method">
			<f a="value">
				<c path="Int"/>
				<e path="Void"/>
			</f>
			<haxe_doc>* 设置水平对齐方式
	 * @param	value 	CONTAINER_HORIZONTAL_LEFT / CONTAINER_HORIZONTAL_CENTER / CONTAINER_HORIZONTAL_RIGHT</haxe_doc>
		</setHorizontalAlign>
		<haxe_doc><![CDATA[* ...
 * 基础对齐类容器接口，继承自基础类容器接口
 * <p>IUiContainerAlignBase->IUiContainerBase</p>
 * @author RoYan]]></haxe_doc>
	</class>
	<class path="cn.royan.hl.interfaces.uis.IUiContainerGroupBase" params="" file="cn/royan/hl/interfaces/uis/IUiContainerGroupBase.hx" interface="1">
		<implements path="cn.royan.hl.interfaces.uis.IUiContainerAlignBase"/>
		<setMaxLen public="1" set="method">
			<f a="value">
				<c path="Int"/>
				<e path="Void"/>
			</f>
			<haxe_doc>* 设置多选数
	 * @param	value</haxe_doc>
		</setMaxLen>
		<setIsMulti public="1" set="method">
			<f a="value">
				<e path="Bool"/>
				<e path="Void"/>
			</f>
			<haxe_doc>* 设置多选
	 * @param	value</haxe_doc>
		</setIsMulti>
		<setIsMust public="1" set="method">
			<f a="value">
				<e path="Bool"/>
				<e path="Void"/>
			</f>
			<haxe_doc>* 设置必选
	 * @param	value</haxe_doc>
		</setIsMust>
		<getValues public="1" set="method">
			<f a=""><c path="Array"><d/></c></f>
			<haxe_doc>* 获取选中值
	 * @return</haxe_doc>
		</getValues>
		<getSelectedItems public="1" set="method">
			<f a=""><c path="Array"><c path="cn.royan.hl.interfaces.uis.IUiItemGroupBase"/></c></f>
			<haxe_doc>* 获取选中显示项
	 * @return</haxe_doc>
		</getSelectedItems>
		<getGroupItems public="1" set="method">
			<f a=""><c path="Array"><c path="cn.royan.hl.interfaces.uis.IUiItemGroupBase"/></c></f>
			<haxe_doc>* 获取显示列表
	 * @return</haxe_doc>
		</getGroupItems>
		<getIndexByGroupItem public="1" set="method">
			<f a="item">
				<c path="cn.royan.hl.interfaces.uis.IUiItemGroupBase"/>
				<c path="Int"/>
			</f>
			<haxe_doc>* 获取显示项索引
	 * @param	item
	 * @return</haxe_doc>
		</getIndexByGroupItem>
		<getGroupItemAt public="1" set="method">
			<f a="index">
				<c path="Int"/>
				<c path="cn.royan.hl.interfaces.uis.IUiItemGroupBase"/>
			</f>
			<haxe_doc>* 获取显示项
	 * @param	index
	 * @return</haxe_doc>
		</getGroupItemAt>
		<removeAllGroupItems public="1" set="method">
			<f a=""><e path="Void"/></f>
			<haxe_doc>* 清空显示项</haxe_doc>
		</removeAllGroupItems>
		<removeGroupItemAt public="1" set="method">
			<f a="index">
				<c path="Int"/>
				<c path="cn.royan.hl.interfaces.uis.IUiItemGroupBase"/>
			</f>
			<haxe_doc>* 移除显示项
	 * @param	index</haxe_doc>
		</removeGroupItemAt>
		<removeGroupItem public="1" set="method">
			<f a="item">
				<c path="cn.royan.hl.interfaces.uis.IUiItemGroupBase"/>
				<c path="cn.royan.hl.interfaces.uis.IUiItemGroupBase"/>
			</f>
			<haxe_doc>* 移除显示项
	 * @param	item</haxe_doc>
		</removeGroupItem>
		<addGroupItemAt public="1" set="method">
			<f a="item:index:?key">
				<c path="cn.royan.hl.interfaces.uis.IUiItemGroupBase"/>
				<c path="Int"/>
				<d/>
				<c path="cn.royan.hl.interfaces.uis.IUiItemGroupBase"/>
			</f>
			<haxe_doc>* 添加显示项及健值
	 * @param	item
	 * @param	index
	 * @param	key</haxe_doc>
		</addGroupItemAt>
		<addGroupItem public="1" set="method">
			<f a="item:?key">
				<c path="cn.royan.hl.interfaces.uis.IUiItemGroupBase"/>
				<d/>
				<c path="cn.royan.hl.interfaces.uis.IUiItemGroupBase"/>
			</f>
			<haxe_doc>* 添加显示项及健值
	 * @param	item
	 * @param	key</haxe_doc>
		</addGroupItem>
		<haxe_doc><![CDATA[* ...
 * 基础组容器接口，继承自基础对齐类容器接口
 * 注销IUiContainerBase中addItem,addItemAt,removeItem,removeItemAt,getItemAt,getIndexByItem,getItems
 * 
 * <p>IUiContainerGroupBase->IUiContainerAlignBase</p>
 * @author RoYan]]></haxe_doc>
	</class>
	<class path="cn.royan.hl.interfaces.uis.IUiItemGroupBase" params="" file="cn/royan/hl/interfaces/uis/IUiItemGroupBase.hx" interface="1">
		<implements path="cn.royan.hl.interfaces.uis.IUiBase"/>
		<setInGroup public="1" set="method">
			<f a="value">
				<e path="Bool"/>
				<e path="Void"/>
			</f>
			<haxe_doc>* 设置入组
	 * @param	value</haxe_doc>
		</setInGroup>
		<getSelected public="1" set="method">
			<f a=""><e path="Bool"/></f>
			<haxe_doc>* 获取选中
	 * @return</haxe_doc>
		</getSelected>
		<setSelected public="1" set="method">
			<f a="value">
				<e path="Bool"/>
				<e path="Void"/>
			</f>
			<haxe_doc>* 设置选中
	 * @param	value</haxe_doc>
		</setSelected>
		<haxe_doc><![CDATA[* ...
 * 基础组项显示接口，继承自基础显示接口
 * <p>IUiItemGroupBase->IUiBase</p>
 * @author RoYan]]></haxe_doc>
	</class>
	<class path="cn.royan.hl.interfaces.uis.IUiItemPlayBase" params="" file="cn/royan/hl/interfaces/uis/IUiItemPlayBase.hx" interface="1">
		<implements path="cn.royan.hl.interfaces.uis.IUiBase"/>
		<goFromTo public="1" set="method">
			<f a="from:to">
				<c path="Int"/>
				<c path="Int"/>
				<e path="Void"/>
			</f>
			<haxe_doc>* 跳转到，并播放到
	 * @param	from
	 * @param	to</haxe_doc>
		</goFromTo>
		<jumpTo public="1" set="method">
			<f a="frame">
				<c path="Int"/>
				<e path="Void"/>
			</f>
			<haxe_doc>* 跳转到
	 * @param	frame</haxe_doc>
		</jumpTo>
		<goTo public="1" set="method">
			<f a="frame">
				<c path="Int"/>
				<e path="Void"/>
			</f>
			<haxe_doc>* 播放到
	 * @param	frame</haxe_doc>
		</goTo>
		<getOut public="1" set="method">
			<f a=""><e path="Void"/></f>
			<haxe_doc>* 出场</haxe_doc>
		</getOut>
		<getIn public="1" set="method">
			<f a=""><e path="Void"/></f>
			<haxe_doc>* 进场</haxe_doc>
		</getIn>
		<haxe_doc><![CDATA[* ...
 * 基础可播放显示接口，继承自基础显示接口
 * <p>IUiItemPlayBase->IUiBase</p>
 * @author RoYan]]></haxe_doc>
	</class>
	<class path="cn.royan.hl.interfaces.uis.IUiScrollBarBase" params="" file="cn/royan/hl/interfaces/uis/IUiScrollBarBase.hx" interface="1">
		<implements path="cn.royan.hl.interfaces.uis.IUiContainerAlignBase"/>
		<setBackgroundTextrue public="1" set="method">
			<f a="texture">
				<d/>
				<e path="Void"/>
			</f>
			<haxe_doc>* 设置bg材质
	 * @param	texture</haxe_doc>
		</setBackgroundTextrue>
		<setMaxTexture public="1" set="method">
			<f a="texture">
				<d/>
				<e path="Void"/>
			</f>
			<haxe_doc>* 设置max材质
	 * @param	texture</haxe_doc>
		</setMaxTexture>
		<setMinTexture public="1" set="method">
			<f a="texture">
				<d/>
				<e path="Void"/>
			</f>
			<haxe_doc>* 设置min材质
	 * @param	texture</haxe_doc>
		</setMinTexture>
		<setThumbTexture public="1" set="method">
			<f a="texture">
				<d/>
				<e path="Void"/>
			</f>
			<haxe_doc>* 设置Thumb材质
	 * @param	texture</haxe_doc>
		</setThumbTexture>
		<setType public="1" set="method">
			<f a="type">
				<c path="Int"/>
				<e path="Void"/>
			</f>
			<haxe_doc>* 设置滑动类型
	 * @param	type	SCROLLBAR_TYPE_HORIZONTAL / SCROLLBAR_TYPE_VERICAL</haxe_doc>
		</setType>
		<setValue public="1" set="method">
			<f a="value">
				<c path="Int"/>
				<e path="Void"/>
			</f>
			<haxe_doc>* 设置滑动值
	 * @param	value</haxe_doc>
		</setValue>
		<getValue public="1" set="method">
			<f a=""><c path="Int"/></f>
			<haxe_doc>* 获取滑动值
	 * @return</haxe_doc>
		</getValue>
		<haxe_doc><![CDATA[* ...
 * 滚动条接口， 继承自基础对齐类容器接口
 * <p>IUiScrollBarBase->IUiContainerAlignBase</p>
 * @author RoYan]]></haxe_doc>
	</class>
	<class path="cn.royan.hl.interfaces.uis.IUiScrollPaneBase" params="" file="cn/royan/hl/interfaces/uis/IUiScrollPaneBase.hx" interface="1">
		<implements path="cn.royan.hl.interfaces.uis.IUiBase"/>
		<setBackgroundTextrue public="1" set="method">
			<f a="texture">
				<d/>
				<e path="Void"/>
			</f>
			<haxe_doc>* 设置bg材质
	 * @param	texture</haxe_doc>
		</setBackgroundTextrue>
		<setMaxTexture public="1" set="method">
			<f a="texture">
				<d/>
				<e path="Void"/>
			</f>
			<haxe_doc>* 设置max材质
	 * @param	texture</haxe_doc>
		</setMaxTexture>
		<setMinTexture public="1" set="method">
			<f a="texture">
				<d/>
				<e path="Void"/>
			</f>
			<haxe_doc>* 设置min材质
	 * @param	texture</haxe_doc>
		</setMinTexture>
		<setThumbTexture public="1" set="method">
			<f a="texture">
				<d/>
				<e path="Void"/>
			</f>
			<haxe_doc>* 设置Thumb材质
	 * @param	texture</haxe_doc>
		</setThumbTexture>
		<setType public="1" set="method">
			<f a="type">
				<c path="Int"/>
				<e path="Void"/>
			</f>
			<haxe_doc>* 设置滚动类型
	 * @param	type	SCROLL_TYPE_NONE / SCROLL_TYPE_HORIZONTAL_ONLY / SCROLL_TYPE_VERICAL_ONLY / SCROLL_TYPE_HANDV</haxe_doc>
		</setType>
		<haxe_doc><![CDATA[* ...
 * 滚动容器接口，继承自基础显示接口
 * <p>IUiScrollPane->IUiBase</p>
 * @author RoYan]]></haxe_doc>
	</class>
	<class path="cn.royan.hl.interfaces.uis.IUiTextBase" params="" file="cn/royan/hl/interfaces/uis/IUiTextBase.hx" interface="1">
		<implements path="cn.royan.hl.interfaces.uis.IUiBase"/>
		<setMultiLine public="1" set="method">
			<f a="value">
				<e path="Bool"/>
				<e path="Void"/>
			</f>
			<haxe_doc>* 设置分行显示
	 * @param	value</haxe_doc>
		</setMultiLine>
		<getDefaultFormat public="1" set="method">
			<f a=""><c path="flash.text.TextFormat"/></f>
			<haxe_doc>* 获取默认样式
	 * @return</haxe_doc>
		</getDefaultFormat>
		<setDefaultFormat public="1" set="method">
			<f a="value">
				<c path="flash.text.TextFormat"/>
				<e path="Void"/>
			</f>
			<haxe_doc>* 设置默认样式
	 * @param	value</haxe_doc>
		</setDefaultFormat>
		<getFormat public="1" set="method">
			<f a="?begin:?end">
				<c path="Int"/>
				<c path="Int"/>
				<c path="flash.text.TextFormat"/>
			</f>
			<haxe_doc>* 获取文本样式
	 * @param	begin
	 * @param	end
	 * @return</haxe_doc>
		</getFormat>
		<setFormat public="1" set="method">
			<f a="value:?begin:?end">
				<c path="flash.text.TextFormat"/>
				<c path="Int"/>
				<c path="Int"/>
				<e path="Void"/>
			</f>
			<haxe_doc>* 设置文本样式
	 * @param	value
	 * @param	begin
	 * @param	end</haxe_doc>
		</setFormat>
		<setEmbedFont public="1" set="method">
			<f a="value">
				<e path="Bool"/>
				<e path="Void"/>
			</f>
			<haxe_doc>* 设置绑定字体
	 * @param	value</haxe_doc>
		</setEmbedFont>
		<setTextSize public="1" set="method">
			<f a="value">
				<c path="Int"/>
				<e path="Void"/>
			</f>
			<haxe_doc>* 设置文本整体大小
	 * @param	value</haxe_doc>
		</setTextSize>
		<setTextColor public="1" set="method">
			<f a="value">
				<c path="Int"/>
				<e path="Void"/>
			</f>
			<haxe_doc>* 设置文本整体颜色
	 * @param	value</haxe_doc>
		</setTextColor>
		<setTextAlign public="1" set="method">
			<f a="value">
				<c path="Int"/>
				<e path="Void"/>
			</f>
			<haxe_doc>* 设置文本对齐方式
	 * @param	value	TEXT_ALIGN_LEFT / TEXT_ALIGN_CENTER / TEXT_ALIGN_RIGHT</haxe_doc>
		</setTextAlign>
		<getHTMLText public="1" set="method">
			<f a=""><c path="String"/></f>
			<haxe_doc>* 获取文本HTML内容
	 * @return</haxe_doc>
		</getHTMLText>
		<appendHTMLText public="1" set="method">
			<f a="value">
				<c path="String"/>
				<e path="Void"/>
			</f>
			<haxe_doc>* 追加文本HTML内容
	 * @param	value</haxe_doc>
		</appendHTMLText>
		<setHTMLText public="1" set="method">
			<f a="value">
				<c path="String"/>
				<e path="Void"/>
			</f>
			<haxe_doc>* 设置文本HTML内容
	 * @param	value</haxe_doc>
		</setHTMLText>
		<getText public="1" set="method">
			<f a=""><c path="String"/></f>
			<haxe_doc>* 获取文本内容
	 * @return</haxe_doc>
		</getText>
		<appendText public="1" set="method">
			<f a="value">
				<c path="String"/>
				<e path="Void"/>
			</f>
			<haxe_doc>* 追加文本内容
	 * @param	value</haxe_doc>
		</appendText>
		<setText public="1" set="method">
			<f a="value">
				<c path="String"/>
				<e path="Void"/>
			</f>
			<haxe_doc>* 设置文本内容
	 * @param	value</haxe_doc>
		</setText>
		<setType public="1" set="method">
			<f a="type">
				<c path="Int"/>
				<e path="Void"/>
			</f>
			<haxe_doc>* 设置文本类型 
	 * @param	type	TEXT_TYPE_INPUT / TEXT_TYPE_PASSWORD</haxe_doc>
		</setType>
		<setTextSpace public="1" set="method">
			<f a="r:c">
				<c path="Int"/>
				<c path="Int"/>
				<e path="Void"/>
			</f>
			<haxe_doc>* 设置文本间隔
	 * @param	r	字距
	 * @param	c	行距</haxe_doc>
		</setTextSpace>
		<haxe_doc><![CDATA[* ...
 * 基础文本显示接口，所有文本显示类继承此接口，继承自基础显示接口
 * <p>IUiTextBase->IUiBase</p>
 * @author RoYan]]></haxe_doc>
	</class>
	<class path="cn.royan.hl.resources.ConfigFile" params="" file="cn/royan/hl/resources/ConfigFile.hx">
		<implements path="cn.royan.hl.interfaces.IDisposeBase"/>
		<CONFIG_FILE_TYPE_JSON public="1" get="inline" set="null" line="20" static="1">
			<c path="Int"/>
			<haxe_doc>* JSON格式</haxe_doc>
		</CONFIG_FILE_TYPE_JSON>
		<CONFIG_FILE_TYPE_XML public="1" get="inline" set="null" line="25" static="1">
			<c path="Int"/>
			<haxe_doc>* XML格式</haxe_doc>
		</CONFIG_FILE_TYPE_XML>
		<CONFIG_FILE_TYPE_TXT public="1" get="inline" set="null" line="30" static="1">
			<c path="Int"/>
			<haxe_doc>* TXT格式</haxe_doc>
		</CONFIG_FILE_TYPE_TXT>
		<getExtension public="1" set="method" line="129" static="1">
			<f a="configType">
				<c path="Int"/>
				<c path="String"/>
			</f>
			<haxe_doc>* 获取后缀名
	 * @param	configType
	 * @return</haxe_doc>
		</getExtension>
		<parseTxtToObject set="method" line="113"><f a="txt">
	<c path="String"/>
	<e path="Void"/>
</f></parseTxtToObject>
		<parseXMLListToObject set="method" line="85"><f a="xmlList:parent">
	<t path="Iterator"><c path="Xml"/></t>
	<d/>
	<e path="Void"/>
</f></parseXMLListToObject>
		<parseXMLToObject set="method" line="78"><f a="data">
	<c path="String"/>
	<e path="Void"/>
</f></parseXMLToObject>
		<parseJsonToObject set="method" line="73"><f a="data">
	<c path="String"/>
	<e path="Void"/>
</f></parseJsonToObject>
		<dispose public="1" set="method" line="68">
			<f a=""><e path="Void"/></f>
			<haxe_doc>* 销毁</haxe_doc>
		</dispose>
		<getValue public="1" set="method" line="60">
			<f a=""><d/></f>
			<haxe_doc>* 获取配置信息
	 * @return</haxe_doc>
		</getValue>
		<configData><d/></configData>
		<type><c path="Int"/></type>
		<new public="1" set="method" line="40">
			<f a="data:?type">
				<c path="String"/>
				<c path="Int"/>
				<e path="Void"/>
			</f>
			<haxe_doc>* 创建配置文件
	 * @param	data	配置数据
	 * @param	type	配置文件格式</haxe_doc>
		</new>
		<haxe_doc>* ...
 * 配置文件类
 * @author RoYan</haxe_doc>
	</class>
	<class path="cn.royan.hl.resources.ResourceLoader" params="" file="cn/royan/hl/resources/ResourceLoader.hx">
		<extends path="cn.royan.hl.bases.DispatcherBase"/>
		<implements path="cn.royan.hl.interfaces.IDisposeBase"/>
		<__loaderMap line="25" static="1"><t path="cn.royan.hl.bases.Dictionary"/></__loaderMap>
		<__weakMap line="26" static="1"><c path="cn.royan.hl.bases.WeakMap"/></__weakMap>
		<getInstance public="1" set="method" line="51" static="1">
			<f a="key:container:?version:?type">
				<c path="String"/>
				<c path="flash.display.DisplayObjectContainer"/>
				<c path="String"/>
				<c path="Int"/>
				<c path="cn.royan.hl.resources.ResourceLoader"/>
			</f>
			<haxe_doc>* 创建单例
		 * @param	key			配置文件名
		 * @param	container	容器
		 * @param	version		版本
		 * @param	type		配置文件类型
		 * @return</haxe_doc>
		</getInstance>
		<checkResourceByPath set="method" line="336"><f a="path">
	<c path="String"/>
	<e path="Bool"/>
</f></checkResourceByPath>
		<asynFileOnErrorHandler set="method" line="331"><f a="message">
	<c path="String"/>
	<e path="Void"/>
</f></asynFileOnErrorHandler>
		<asynFileOnCompleteHandler set="method" line="319"><f a="data">
	<d/>
	<e path="Void"/>
</f></asynFileOnCompleteHandler>
		<asynFileOnProgressHandler set="method" line="314"><f a="data">
	<a>
		<total><c path="Int"/></total>
		<loaded><c path="Int"/></loaded>
	</a>
	<e path="Void"/>
</f></asynFileOnProgressHandler>
		<asynFileStartLoadHandler set="method" line="285"><f a=""><e path="Void"/></f></asynFileStartLoadHandler>
		<synFileOnErrorHandler set="method" line="279"><f a="message">
	<c path="String"/>
	<e path="Void"/>
</f></synFileOnErrorHandler>
		<synFileOnCompleteHandler set="method" line="265"><f a="data">
	<d/>
	<e path="Void"/>
</f></synFileOnCompleteHandler>
		<synFileOnProgressHandler set="method" line="260"><f a="data">
	<a>
		<total><c path="Int"/></total>
		<loaded><c path="Int"/></loaded>
	</a>
	<e path="Void"/>
</f></synFileOnProgressHandler>
		<synFileStartLoadHandler set="method" line="228"><f a=""><e path="Void"/></f></synFileStartLoadHandler>
		<configFileOnErrorHandler set="method" line="222"><f a="message">
	<c path="String"/>
	<e path="Void"/>
</f></configFileOnErrorHandler>
		<configFileOnCompleteHandler set="method" line="207"><f a="data">
	<d/>
	<e path="Void"/>
</f></configFileOnCompleteHandler>
		<configFileOnProgressHandler set="method" line="201"><f a="data">
	<a>
		<total><c path="Int"/></total>
		<loaded><c path="Int"/></loaded>
	</a>
	<e path="Void"/>
</f></configFileOnProgressHandler>
		<loaderOnErrorHandler set="method" line="195"><f a="message">
	<c path="String"/>
	<e path="Void"/>
</f></loaderOnErrorHandler>
		<loaderAnimationCompleteHandler set="method" line="190"><f a="evt">
	<c path="cn.royan.hl.events.DatasEvent"/>
	<e path="Void"/>
</f></loaderAnimationCompleteHandler>
		<loaderOnCompleteHandler set="method" line="164"><f a="data">
	<d/>
	<e path="Void"/>
</f></loaderOnCompleteHandler>
		<loaderOnProgressHandler set="method" line="159"><f a="data">
	<a>
		<total><c path="Int"/></total>
		<loaded><c path="Int"/></loaded>
	</a>
	<e path="Void"/>
</f></loaderOnProgressHandler>
		<containerInitComplete public="1" set="method" line="154">
			<f a=""><e path="Void"/></f>
			<haxe_doc>* 内部初始化完成（删除加载动画）</haxe_doc>
		</containerInitComplete>
		<extraComplete public="1" set="method" line="146">
			<f a=""><e path="Void"/></f>
			<haxe_doc>* 额外内容完成</haxe_doc>
		</extraComplete>
		<setCallbacks public="1" set="method" line="138">
			<f a="value">
				<d/>
				<e path="Void"/>
			</f>
			<haxe_doc>* 设置回调函数
		 * @param	value</haxe_doc>
		</setCallbacks>
		<getResourceByPath public="1" set="method" line="129">
			<f a="path">
				<c path="String"/>
				<d/>
			</f>
			<haxe_doc>* 获取资源
		 * @param	path	资源路径
		 * @return</haxe_doc>
		</getResourceByPath>
		<getConfigFile public="1" set="method" line="119">
			<f a=""><c path="cn.royan.hl.resources.ConfigFile"/></f>
			<haxe_doc>* 获取配置信息
		 * @return</haxe_doc>
		</getConfigFile>
		<setConfigType public="1" set="method" line="110">
			<f a="value">
				<c path="Int"/>
				<e path="Void"/>
			</f>
			<haxe_doc>* 设置配置文件类型
		 * @param	value</haxe_doc>
		</setConfigType>
		<dispose public="1" set="method" line="100">
			<f a=""><e path="Void"/></f>
			<haxe_doc>* 销毁</haxe_doc>
		</dispose>
		<load public="1" set="method" line="90">
			<f a=""><e path="Void"/></f>
			<haxe_doc>* 开始加载</haxe_doc>
		</load>
		<loader><c path="cn.royan.hl.uis.normal.bases.UiNLoader"/></loader>
		<root><c path="flash.display.DisplayObjectContainer"/></root>
		<callbacks><d/></callbacks>
		<currentPath><c path="String"/></currentPath>
		<takeService><c path="cn.royan.hl.services.TakeService"/></takeService>
		<configFile><c path="cn.royan.hl.resources.ConfigFile"/></configFile>
		<configType><c path="Int"/></configType>
		<moduleVer><c path="String"/></moduleVer>
		<moduleKey><c path="String"/></moduleKey>
		<uid><c path="String"/></uid>
		<new set="method" line="60"><f a="key:container:version:type">
	<c path="String"/>
	<c path="flash.display.DisplayObjectContainer"/>
	<c path="String"/>
	<c path="Int"/>
	<e path="Void"/>
</f></new>
		<haxe_doc>* ...
 * 资源导入类
 * @author RoYan</haxe_doc>
	</class>
	<class path="cn.royan.hl.services.JsService" params="" file="cn/royan/hl/services/JsService.hx">
		<extends path="cn.royan.hl.bases.DispatcherBase"/>
		<implements path="cn.royan.hl.interfaces.services.IServiceBase"/>
		<dispose public="1" set="method" line="83">
			<f a=""><e path="Void"/></f>
			<haxe_doc>* 销毁</haxe_doc>
		</dispose>
		<getIsServicing public="1" set="method" line="75">
			<f a=""><e path="Bool"/></f>
			<haxe_doc>* 获取交互状态
	 * @return</haxe_doc>
		</getIsServicing>
		<getData public="1" set="method" line="66">
			<f a=""><d/></f>
			<haxe_doc>* 获取回应值
	 * @return</haxe_doc>
		</getData>
		<setCallbacks public="1" set="method" line="57">
			<f a="value">
				<d/>
				<e path="Void"/>
			</f>
			<haxe_doc>* 设置毁掉函数
	 * @param	value	{done:..., doing:..., create:..., error:..., destroy:...}</haxe_doc>
		</setCallbacks>
		<close public="1" set="method" line="48">
			<f a=""><e path="Void"/></f>
			<haxe_doc>* 关闭请求</haxe_doc>
		</close>
		<connect public="1" set="method" line="40">
			<f a=""><e path="Void"/></f>
			<haxe_doc>* 开始请求</haxe_doc>
		</connect>
		<sendRequest public="1" set="method" line="31">
			<f a="?url:?extra">
				<c path="String"/>
				<d/>
				<e path="Void"/>
			</f>
			<haxe_doc>* 设置请求
	 * @param	url
	 * @param	extra</haxe_doc>
		</sendRequest>
		<callbacks><d/></callbacks>
		<serviceData><c path="String"/></serviceData>
		<params><c path="Array"><d/></c></params>
		<fun><c path="String"/></fun>
		<new public="1" set="method" line="21"><f a=""><e path="Void"/></f></new>
		<haxe_doc>* ...
 * Js交互
 * @author RoYan</haxe_doc>
	</class>
	<class path="cn.royan.hl.services.MQTTService" params="" file="cn/royan/hl/services/MQTTService.hx">
		<extends path="cn.royan.hl.bases.DispatcherBase"/>
		<implements path="cn.royan.hl.interfaces.services.IServiceBase"/>
		<dispose public="1" set="method" line="77">
			<f a=""><e path="Void"/></f>
			<haxe_doc>* 销毁</haxe_doc>
		</dispose>
		<getIsServicing public="1" set="method" line="69">
			<f a=""><e path="Bool"/></f>
			<haxe_doc>* 获取交互状态
	 * @return</haxe_doc>
		</getIsServicing>
		<getData public="1" set="method" line="60">
			<f a=""><d/></f>
			<haxe_doc>* 获取回应值
	 * @return</haxe_doc>
		</getData>
		<setCallbacks public="1" set="method" line="51">
			<f a="value">
				<d/>
				<e path="Void"/>
			</f>
			<haxe_doc>* 设置毁掉函数
	 * @param	value	{done:..., doing:..., create:..., error:..., destroy:...}</haxe_doc>
		</setCallbacks>
		<close public="1" set="method" line="42">
			<f a=""><e path="Void"/></f>
			<haxe_doc>* 关闭请求</haxe_doc>
		</close>
		<connect public="1" set="method" line="34">
			<f a=""><e path="Void"/></f>
			<haxe_doc>* 开始请求</haxe_doc>
		</connect>
		<sendRequest public="1" set="method" line="26">
			<f a="?url:?extra">
				<c path="String"/>
				<d/>
				<e path="Void"/>
			</f>
			<haxe_doc>* 设置请求
	 * @param	url
	 * @param	extra</haxe_doc>
		</sendRequest>
		<new public="1" set="method" line="16"><f a=""><e path="Void"/></f></new>
		<haxe_doc>* ...
 * MQTT协议接口
 * @author RoYan</haxe_doc>
	</class>
	<class path="cn.royan.hl.services.PushService" params="" file="cn/royan/hl/services/PushService.hx">
		<extends path="cn.royan.hl.bases.DispatcherBase"/>
		<implements path="cn.royan.hl.interfaces.services.IServiceBase"/>
		<dispose public="1" set="method" line="77">
			<f a=""><e path="Void"/></f>
			<haxe_doc>* 销毁</haxe_doc>
		</dispose>
		<getIsServicing public="1" set="method" line="69">
			<f a=""><e path="Bool"/></f>
			<haxe_doc>* 获取交互状态
	 * @return</haxe_doc>
		</getIsServicing>
		<getData public="1" set="method" line="60">
			<f a=""><d/></f>
			<haxe_doc>* 获取回应值
	 * @return</haxe_doc>
		</getData>
		<setCallbacks public="1" set="method" line="51">
			<f a="value">
				<d/>
				<e path="Void"/>
			</f>
			<haxe_doc>* 设置毁掉函数
	 * @param	value	{done:..., doing:..., create:..., error:..., destroy:...}</haxe_doc>
		</setCallbacks>
		<close public="1" set="method" line="42">
			<f a=""><e path="Void"/></f>
			<haxe_doc>* 关闭请求</haxe_doc>
		</close>
		<connect public="1" set="method" line="34">
			<f a=""><e path="Void"/></f>
			<haxe_doc>* 开始请求</haxe_doc>
		</connect>
		<sendRequest public="1" set="method" line="26">
			<f a="?url:?extra">
				<c path="String"/>
				<d/>
				<e path="Void"/>
			</f>
			<haxe_doc>* 设置请求
	 * @param	url
	 * @param	extra</haxe_doc>
		</sendRequest>
		<new public="1" set="method" line="16"><f a=""><e path="Void"/></f></new>
		<haxe_doc>* ...
 * 发送
 * @author RoYan</haxe_doc>
	</class>
	<typedef path="cn.royan.hl.services._SoktService.ClientInfos" params="" file="cn/royan/hl/services/SoktService.hx" private="1" module="cn.royan.hl.services.SoktService">
		<a>
			<socket><c path="flash.net.Socket"/></socket>
			<bufpos><c path="Int"/></bufpos>
			<buf><c path="haxe.io.Bytes"/></buf>
		</a>
		<haxe_doc>* ...
 * Socket客户
 * @author RoYan</haxe_doc>
	</typedef>
	<class path="cn.royan.hl.services.SoktService" params="" file="cn/royan/hl/services/SoktService.hx">
		<extends path="cn.royan.hl.bases.DispatcherBase"/>
		<implements path="cn.royan.hl.interfaces.services.IServiceBase"/>
		<onProgress set="method" line="233"><f a="evt">
	<c path="flash.events.ProgressEvent"/>
	<e path="Void"/>
</f></onProgress>
		<onSecurityError set="method" line="224"><f a="evt">
	<c path="flash.events.SecurityErrorEvent"/>
	<e path="Void"/>
</f></onSecurityError>
		<onIOError set="method" line="215"><f a="evt">
	<c path="flash.events.IOErrorEvent"/>
	<e path="Void"/>
</f></onIOError>
		<onClose set="method" line="206"><f a="evt">
	<c path="flash.events.Event"/>
	<e path="Void"/>
</f></onClose>
		<onConnect set="method" line="197"><f a="evt">
	<c path="flash.events.Event"/>
	<e path="Void"/>
</f></onConnect>
		<dispose public="1" set="method" line="179">
			<f a=""><e path="Void"/></f>
			<haxe_doc>* 销毁</haxe_doc>
		</dispose>
		<getIsServicing public="1" set="method" line="171">
			<f a=""><e path="Bool"/></f>
			<haxe_doc>* 获取交互状态
	 * @return</haxe_doc>
		</getIsServicing>
		<getData public="1" set="method" line="162">
			<f a=""><d/></f>
			<haxe_doc>* 获取回应值
	 * @return</haxe_doc>
		</getData>
		<setCallbacks public="1" set="method" line="153">
			<f a="value">
				<d/>
				<e path="Void"/>
			</f>
			<haxe_doc>* 设置毁掉函数
	 * @param	value	{done:..., doing:..., create:..., error:..., destroy:...}</haxe_doc>
		</setCallbacks>
		<close public="1" set="method" line="144">
			<f a=""><e path="Void"/></f>
			<haxe_doc>* 关闭请求</haxe_doc>
		</close>
		<connect public="1" set="method" line="105">
			<f a=""><e path="Void"/></f>
			<haxe_doc>* 开始请求</haxe_doc>
		</connect>
		<sendRequest public="1" set="method" line="84">
			<f a="?url:?extra">
				<c path="String"/>
				<d/>
				<e path="Void"/>
			</f>
			<haxe_doc>* 设置请求，未连接时(url:port)，连接后(null, bytes)
	 * @param	url	
	 * @param	extra</haxe_doc>
		</sendRequest>
		<socket><c path="flash.net.Socket"/></socket>
		<isServicing><e path="Bool"/></isServicing>
		<port><c path="Int"/></port>
		<host><c path="String"/></host>
		<callbacks><d/></callbacks>
		<new public="1" set="method" line="66"><f a="?host:?port">
	<c path="String"/>
	<c path="Int"/>
	<e path="Void"/>
</f></new>
	</class>
	<class path="cn.royan.hl.services.TakeService" params="" file="cn/royan/hl/services/TakeService.hx">
		<extends path="cn.royan.hl.bases.DispatcherBase"/>
		<implements path="cn.royan.hl.interfaces.services.IServiceBase"/>
		<onSecurityError set="method" line="268"><f a="evt">
	<c path="flash.events.SecurityErrorEvent"/>
	<e path="Void"/>
</f></onSecurityError>
		<onError set="method" line="260"><f a="evt">
	<c path="flash.events.IOErrorEvent"/>
	<e path="Void"/>
</f></onError>
		<onProgress set="method" line="253"><f a="evt">
	<c path="flash.events.ProgressEvent"/>
	<e path="Void"/>
</f></onProgress>
		<loaderOnComplete set="method" line="236"><f a="evt">
	<c path="flash.events.Event"/>
	<e path="Void"/>
</f></loaderOnComplete>
		<analyze set="method" line="217"><f a=""><e path="Void"/></f></analyze>
		<onComplete set="method" line="202"><f a="evt">
	<c path="flash.events.Event"/>
	<e path="Void"/>
</f></onComplete>
		<dispose public="1" set="method" line="181">
			<f a=""><e path="Void"/></f>
			<haxe_doc>* 销毁</haxe_doc>
		</dispose>
		<getIsServicing public="1" set="method" line="173">
			<f a=""><e path="Bool"/></f>
			<haxe_doc>* 获取交互状态
	 * @return</haxe_doc>
		</getIsServicing>
		<getData public="1" set="method" line="161">
			<f a=""><d/></f>
			<haxe_doc>* 获取回应值
	 * @return</haxe_doc>
		</getData>
		<setCallbacks public="1" set="method" line="152">
			<f a="value">
				<d/>
				<e path="Void"/>
			</f>
			<haxe_doc>* 设置毁掉函数
	 * @param	value	{done:..., doing:..., create:..., error:..., destroy:...}</haxe_doc>
		</setCallbacks>
		<close public="1" set="method" line="139">
			<f a=""><e path="Void"/></f>
			<haxe_doc>* 关闭请求</haxe_doc>
		</close>
		<connect public="1" set="method" line="84">
			<f a=""><e path="Void"/></f>
			<haxe_doc>* 开始请求</haxe_doc>
		</connect>
		<sendRequest public="1" set="method" line="73">
			<f a="?url:?extra">
				<c path="String"/>
				<d/>
				<e path="Void"/>
			</f>
			<haxe_doc>* 设置请求
	 * @param	url	
	 * @param	extra</haxe_doc>
		</sendRequest>
		<isLoading><e path="Bool"/></isLoading>
		<swfLoader><c path="flash.display.Loader"/></swfLoader>
		<weakMap><c path="cn.royan.hl.bases.WeakMap"/></weakMap>
		<callbacks><d/></callbacks>
		<serviceData><c path="flash.utils.ByteArray"/></serviceData>
		<urlvariable><c path="flash.net.URLVariables"/></urlvariable>
		<urlrequest><c path="flash.net.URLRequest"/></urlrequest>
		<urlstream><c path="flash.net.URLStream"/></urlstream>
		<new public="1" set="method" line="49"><f a="?param">
	<d/>
	<e path="Void"/>
</f></new>
		<haxe_doc>* ...
 * 获取
 * @author RoYan</haxe_doc>
	</class>
	<class path="cn.royan.hl.services.messages.MessageManager" params="" file="cn/royan/hl/services/messages/MessageManager.hx">
		<messages line="14" static="1"><t path="cn.royan.hl.bases.Dictionary"/></messages>
		<setMessageByType public="1" get="inline" set="null" line="21" static="1">
			<f a="type:message">
				<c path="Int"/>
				<c path="Class"><c path="cn.royan.hl.services.messages.SocketServiceMessage"/></c>
				<e path="Void"/>
			</f>
			<haxe_doc>* 注册消息
	 * @param	type		键值
	 * @param	message		消息类型</haxe_doc>
		</setMessageByType>
		<getMessageByType public="1" get="inline" set="null" line="32" static="1">
			<f a="type">
				<c path="Int"/>
				<c path="Class"><c path="cn.royan.hl.services.messages.SocketServiceMessage"/></c>
			</f>
			<haxe_doc>* 获取消息
	 * @param	type		键值
	 * @return</haxe_doc>
		</getMessageByType>
		<haxe_doc>* ...
 * 信息管理类
 * @author RoYan</haxe_doc>
	</class>
	<class path="cn.royan.hl.services.messages.Serializer" params="" file="cn/royan/hl/services/messages/Serializer.hx">
		<getBytes public="1" set="method" line="103"><f a=""><t path="haxe.io.BytesData"/></f></getBytes>
		<serializeArray set="method" line="93"><f a="v">
	<c path="Array"><d/></c>
	<c path="haxe.io.BytesOutput"/>
</f></serializeArray>
		<serializeObject set="method" line="82"><f a="v">
	<d/>
	<c path="haxe.io.BytesOutput"/>
</f></serializeObject>
		<serializeString set="method" line="74"><f a="v">
	<c path="String"/>
	<c path="haxe.io.BytesOutput"/>
</f></serializeString>
		<serialize public="1" set="method" line="36">
			<f a="v">
				<d/>
				<c path="haxe.io.BytesOutput"/>
			</f>
			<haxe_doc>* 对对象进行序列化
	 * @param	v
	 * 
	 * TNull 	0
	 * TInt		1
	 * TFloat	2
	 * TBool	3
	 * TClass	4
	 * TObject	5
	 * TEnum	6
	 * String	7
	 * Array	8
	 * Date		9;</haxe_doc>
		</serialize>
		<bytesOutput><c path="haxe.io.BytesOutput"/></bytesOutput>
		<new public="1" set="method" line="16"><f a=""><e path="Void"/></f></new>
		<haxe_doc>* ...
 * 序列化
 * @author RoYan</haxe_doc>
	</class>
	<class path="haxe.io.Bytes" params="" file="C:\Motion-Twin\Haxe/std/haxe/io/Bytes.hx">
		<alloc public="1" set="method" line="259" static="1"><f a="length">
	<c path="Int"/>
	<c path="haxe.io.Bytes"/>
</f></alloc>
		<ofString public="1" set="method" line="291" static="1"><f a="s">
	<c path="String"/>
	<c path="haxe.io.Bytes"/>
</f></ofString>
		<ofData public="1" set="method" line="340" static="1"><f a="b">
	<t path="haxe.io.BytesData"/>
	<c path="haxe.io.Bytes"/>
</f></ofData>
		<getData public="1" get="inline" set="null" line="255"><f a=""><t path="haxe.io.BytesData"/></f></getData>
		<toHex public="1" set="method" line="241"><f a=""><c path="String"/></f></toHex>
		<toString public="1" set="method" line="218"><f a=""><c path="String"/></f></toString>
		<readString public="1" set="method" line="168"><f a="pos:len">
	<c path="Int"/>
	<c path="Int"/>
	<c path="String"/>
</f></readString>
		<compare public="1" set="method" line="130"><f a="other">
	<c path="haxe.io.Bytes"/>
	<c path="Int"/>
</f></compare>
		<sub public="1" set="method" line="103"><f a="pos:len">
	<c path="Int"/>
	<c path="Int"/>
	<c path="haxe.io.Bytes"/>
</f></sub>
		<blit public="1" set="method" line="71"><f a="pos:src:srcpos:len">
	<c path="Int"/>
	<c path="haxe.io.Bytes"/>
	<c path="Int"/>
	<c path="Int"/>
	<e path="Void"/>
</f></blit>
		<set public="1" get="inline" set="null" line="53"><f a="pos:v">
	<c path="Int"/>
	<c path="Int"/>
	<e path="Void"/>
</f></set>
		<get public="1" get="inline" set="null" line="37"><f a="pos">
	<c path="Int"/>
	<c path="Int"/>
</f></get>
		<b><t path="haxe.io.BytesData"/></b>
		<length public="1" set="null"><c path="Int"/></length>
		<new set="method" line="32"><f a="length:b">
	<c path="Int"/>
	<t path="haxe.io.BytesData"/>
	<e path="Void"/>
</f></new>
	</class>
	<class path="cn.royan.hl.services.messages.SocketServiceMessage" params="" file="cn/royan/hl/services/messages/SocketServiceMessage.hx">
		<extends path="haxe.io.Bytes"/>
		<implements path="cn.royan.hl.interfaces.services.IServiceMessageBase"/>
		<ignores get="inline" set="null" line="21" static="1"><c path="Array"><c path="String"/></c></ignores>
		<fromBytes public="1" set="method" line="127" static="1">
			<f a="input">
				<c path="haxe.io.Bytes"/>
				<c path="cn.royan.hl.services.messages.SocketServiceMessage"/>
			</f>
			<haxe_doc>* 从原始数据中获取信息
	 * @param	input
	 * @return</haxe_doc>
		</fromBytes>
		<dispose public="1" set="method" line="205">
			<f a=""><e path="Void"/></f>
			<haxe_doc>* 销毁</haxe_doc>
		</dispose>
		<getSortedFields set="method" line="188"><f a=""><c path="Array"><c path="String"/></c></f></getSortedFields>
		<serialize public="1" set="method" line="173">
			<f a=""><e path="Void"/></f>
			<haxe_doc>* 序列化</haxe_doc>
		</serialize>
		<readMessageData public="1" set="method" line="163">
			<f a=""><t path="haxe.io.BytesData"/></f>
			<haxe_doc>* 获取信息数据
	 * @return</haxe_doc>
		</readMessageData>
		<readMessageLen public="1" set="method" line="152">
			<f a=""><c path="Int"/></f>
			<haxe_doc>* 获取信息长度
	 * @return</haxe_doc>
		</readMessageLen>
		<readMessageType public="1" set="method" line="141">
			<f a=""><c path="Int"/></f>
			<haxe_doc>* 获取键值
	 * @return</haxe_doc>
		</readMessageType>
		<writeMessageFromBytes public="1" set="method" line="88">
			<f a="input">
				<c path="haxe.io.Bytes"/>
				<e path="Void"/>
			</f>
			<haxe_doc>* 从原始数据中获取信息
	 * @param	input</haxe_doc>
		</writeMessageFromBytes>
		<writeMessageData public="1" set="method" line="71">
			<f a="value">
				<t path="haxe.io.BytesData"/>
				<e path="Void"/>
			</f>
			<haxe_doc>* 设置信息数据
	 * @param	value</haxe_doc>
		</writeMessageData>
		<writeMessageLen public="1" set="method" line="51">
			<f a="value">
				<c path="Int"/>
				<e path="Void"/>
			</f>
			<haxe_doc>* 设置信息长度
	 * @param	value</haxe_doc>
		</writeMessageLen>
		<writeMessageType public="1" set="method" line="41">
			<f a="value">
				<c path="Int"/>
				<e path="Void"/>
			</f>
			<haxe_doc>* 设置键值
	 * @param	value</haxe_doc>
		</writeMessageType>
		<data><c path="haxe.io.Bytes"/></data>
		<len><c path="Int"/></len>
		<type><c path="Int"/></type>
		<new public="1" set="method" line="27"><f a=""><e path="Void"/></f></new>
		<haxe_doc><![CDATA[* ...
 * Socket服务基础信息类，继承与Bytes
 * <p>SocketServiceMessage->Bytes</p>
 * @author RoYan]]></haxe_doc>
	</class>
	<class path="cn.royan.hl.services.messages.Unserializer" params="" file="cn/royan/hl/services/messages/Unserializer.hx">
		<unserializeArray set="method" line="72"><f a="v">
	<c path="haxe.io.Input"/>
	<c path="Array"><d/></c>
</f></unserializeArray>
		<unserializeObject set="method" line="60"><f a="v">
	<c path="haxe.io.Input"/>
	<d/>
</f></unserializeObject>
		<unserialize public="1" set="method" line="30">
			<f a="v">
				<c path="haxe.io.Input"/>
				<d/>
			</f>
			<haxe_doc>* 对数据进行反序列化
	 * @param	v
	 * 
	 * TNull 	0
	 * TInt		1
	 * TFloat	2
	 * TBool	3
	 * TClass	4
	 * TObject	5
	 * TEnum	6
	 * String	7
	 * Array	8
	 * Date		9</haxe_doc>
		</unserialize>
		<new public="1" set="method" line="13"><f a=""><e path="Void"/></f></new>
		<haxe_doc>* ...
 * 反序列化
 * @author RoYan</haxe_doc>
	</class>
	<class path="flash.system.Capabilities" params="" file="C:\Motion-Twin\Haxe/std/flash/system/Capabilities.hx" extern="1">
		<_internal public="1" set="null" static="1"><t path="UInt"/></_internal>
		<avHardwareDisable public="1" set="null" static="1"><e path="Bool"/></avHardwareDisable>
		<cpuArchitecture public="1" static="1">
			<c path="String"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</cpuArchitecture>
		<hasAccessibility public="1" set="null" static="1"><e path="Bool"/></hasAccessibility>
		<hasAudio public="1" set="null" static="1"><e path="Bool"/></hasAudio>
		<hasAudioEncoder public="1" set="null" static="1"><e path="Bool"/></hasAudioEncoder>
		<hasEmbeddedVideo public="1" set="null" static="1"><e path="Bool"/></hasEmbeddedVideo>
		<hasIME public="1" set="null" static="1"><e path="Bool"/></hasIME>
		<hasMP3 public="1" set="null" static="1"><e path="Bool"/></hasMP3>
		<hasPrinting public="1" set="null" static="1"><e path="Bool"/></hasPrinting>
		<hasScreenBroadcast public="1" set="null" static="1"><e path="Bool"/></hasScreenBroadcast>
		<hasScreenPlayback public="1" set="null" static="1"><e path="Bool"/></hasScreenPlayback>
		<hasStreamingAudio public="1" set="null" static="1"><e path="Bool"/></hasStreamingAudio>
		<hasStreamingVideo public="1" set="null" static="1"><e path="Bool"/></hasStreamingVideo>
		<hasTLS public="1" set="null" static="1"><e path="Bool"/></hasTLS>
		<hasVideoEncoder public="1" set="null" static="1"><e path="Bool"/></hasVideoEncoder>
		<isDebugger public="1" set="null" static="1"><e path="Bool"/></isDebugger>
		<isEmbeddedInAcrobat public="1" set="null" static="1">
			<e path="Bool"/>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</isEmbeddedInAcrobat>
		<language public="1" set="null" static="1"><c path="String"/></language>
		<localFileReadDisable public="1" set="null" static="1"><e path="Bool"/></localFileReadDisable>
		<manufacturer public="1" set="null" static="1"><c path="String"/></manufacturer>
		<maxLevelIDC public="1" set="null" static="1">
			<c path="String"/>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</maxLevelIDC>
		<os public="1" set="null" static="1"><c path="String"/></os>
		<pixelAspectRatio public="1" set="null" static="1"><c path="Float"/></pixelAspectRatio>
		<playerType public="1" set="null" static="1"><c path="String"/></playerType>
		<screenColor public="1" set="null" static="1"><c path="String"/></screenColor>
		<screenDPI public="1" set="null" static="1"><c path="Float"/></screenDPI>
		<screenResolutionX public="1" set="null" static="1"><c path="Float"/></screenResolutionX>
		<screenResolutionY public="1" set="null" static="1"><c path="Float"/></screenResolutionY>
		<serverString public="1" set="null" static="1"><c path="String"/></serverString>
		<supports32BitProcesses public="1" static="1">
			<e path="Bool"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</supports32BitProcesses>
		<supports64BitProcesses public="1" static="1">
			<e path="Bool"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</supports64BitProcesses>
		<touchscreenType public="1" static="1">
			<e path="flash.system.TouchscreenType"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</touchscreenType>
		<version public="1" set="null" static="1"><c path="String"/></version>
		<hasMultiChannelAudio public="1" static="1">
			<f a="type">
				<c path="String"/>
				<e path="Bool"/>
			</f>
			<meta><m n=":require"><e>flash11</e></m></meta>
		</hasMultiChannelAudio>
	</class>
	<class path="cn.royan.hl.systems.DeviceCapabilities" params="" file="cn/royan/hl/systems/DeviceCapabilities.hx">
		<tabletScreenMinimumInches public="1" line="12" static="1"><c path="Float"/></tabletScreenMinimumInches>
		<screenPixelWidth public="1" line="18" static="1">
			<c path="Float"/>
			<haxe_doc>* A custom width, in pixels, to use for calculations of the device's
		 * physical screen size. Set to NaN to use the actual width.</haxe_doc>
		</screenPixelWidth>
		<screenPixelHeight public="1" line="24" static="1">
			<c path="Float"/>
			<haxe_doc>* A custom height, in pixels, to use for calculations of the device's
		 * physical screen size. Set to NaN to use the actual height.</haxe_doc>
		</screenPixelHeight>
		<dpi public="1" line="32" static="1">
			<c path="Int"/>
			<haxe_doc><![CDATA[* The DPI to be used by Feathers. Defaults to the value of
		 * <code>Capabilities.screenDPI</code>, but may be overridden. For
		 * example, if one wishes to demo a mobile app in the desktop browser,
		 * a custom DPI will override the real DPI of the desktop screen.]]></haxe_doc>
		</dpi>
		<isTablet public="1" set="method" line="39" static="1">
			<f a="stage">
				<c path="flash.display.Stage"/>
				<e path="Bool"/>
			</f>
			<haxe_doc>* Determines if this device is probably a tablet, based on the physical
		 * width and height, in inches, calculated using the full-screen
		 * dimensions and the screen DPI.</haxe_doc>
		</isTablet>
		<isPhone public="1" set="method" line="51" static="1">
			<f a="stage">
				<c path="flash.display.Stage"/>
				<e path="Bool"/>
			</f>
			<haxe_doc>* Determines if this device is probably a phone, based on the physical
		 * width and height, in inches, calculated using the full-screen
		 * dimensions and the screen DPI.</haxe_doc>
		</isPhone>
		<screenInchesX public="1" set="method" line="60" static="1">
			<f a="stage">
				<c path="flash.display.Stage"/>
				<c path="Float"/>
			</f>
			<haxe_doc>* The physical width of the device, in inches. Calculated using the
		 * full-screen width and the screen DPI.</haxe_doc>
		</screenInchesX>
		<screenInchesY public="1" set="method" line="70" static="1">
			<f a="stage">
				<c path="flash.display.Stage"/>
				<c path="Float"/>
			</f>
			<haxe_doc>* The physical height of the device, in inches. Calculated using the
		 * full-screen height and the screen DPI.</haxe_doc>
		</screenInchesY>
		<haxe_doc>* ...
 * @author RoYan</haxe_doc>
	</class>
	<class path="flash.display.IBitmapDrawable" params="" file="C:\Motion-Twin\Haxe/std/flash/display/IBitmapDrawable.hx" extern="1" interface="1"/>
	<class path="flash.display.DisplayObject" params="" file="C:\Motion-Twin\Haxe/std/flash/display/DisplayObject.hx" extern="1">
		<extends path="flash.events.EventDispatcher"/>
		<implements path="flash.display.IBitmapDrawable"/>
		<localToGlobal public="1" set="method"><f a="point">
	<c path="flash.geom.Point"/>
	<c path="flash.geom.Point"/>
</f></localToGlobal>
		<local3DToGlobal public="1" set="method">
			<f a="point3d">
				<c path="flash.geom.Vector3D"/>
				<c path="flash.geom.Point"/>
			</f>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</local3DToGlobal>
		<hitTestPoint public="1" set="method"><f a="x:y:?shapeFlag">
	<c path="Float"/>
	<c path="Float"/>
	<e path="Bool"/>
	<e path="Bool"/>
</f></hitTestPoint>
		<hitTestObject public="1" set="method"><f a="obj">
	<c path="flash.display.DisplayObject"/>
	<e path="Bool"/>
</f></hitTestObject>
		<globalToLocal3D public="1" set="method">
			<f a="point">
				<c path="flash.geom.Point"/>
				<c path="flash.geom.Vector3D"/>
			</f>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</globalToLocal3D>
		<globalToLocal public="1" set="method"><f a="point">
	<c path="flash.geom.Point"/>
	<c path="flash.geom.Point"/>
</f></globalToLocal>
		<getRect public="1" set="method"><f a="targetCoordinateSpace">
	<c path="flash.display.DisplayObject"/>
	<c path="flash.geom.Rectangle"/>
</f></getRect>
		<getBounds public="1" set="method"><f a="targetCoordinateSpace">
	<c path="flash.display.DisplayObject"/>
	<c path="flash.geom.Rectangle"/>
</f></getBounds>
		<z public="1">
			<c path="Float"/>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</z>
		<y public="1"><c path="Float"/></y>
		<x public="1"><c path="Float"/></x>
		<width public="1"><c path="Float"/></width>
		<visible public="1"><e path="Bool"/></visible>
		<transform public="1"><c path="flash.geom.Transform"/></transform>
		<stage public="1" set="null"><c path="flash.display.Stage"/></stage>
		<scrollRect public="1"><c path="flash.geom.Rectangle"/></scrollRect>
		<scaleZ public="1">
			<c path="Float"/>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</scaleZ>
		<scaleY public="1"><c path="Float"/></scaleY>
		<scaleX public="1"><c path="Float"/></scaleX>
		<scale9Grid public="1"><c path="flash.geom.Rectangle"/></scale9Grid>
		<rotationZ public="1">
			<c path="Float"/>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</rotationZ>
		<rotationY public="1">
			<c path="Float"/>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</rotationY>
		<rotationX public="1">
			<c path="Float"/>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</rotationX>
		<rotation public="1"><c path="Float"/></rotation>
		<root public="1" set="null"><c path="flash.display.DisplayObject"/></root>
		<parent public="1" set="null"><c path="flash.display.DisplayObjectContainer"/></parent>
		<opaqueBackground public="1"><t path="Null"><t path="UInt"/></t></opaqueBackground>
		<name public="1"><c path="String"/></name>
		<mouseY public="1" set="null"><c path="Float"/></mouseY>
		<mouseX public="1" set="null"><c path="Float"/></mouseX>
		<mask public="1"><c path="flash.display.DisplayObject"/></mask>
		<loaderInfo public="1" set="null"><c path="flash.display.LoaderInfo"/></loaderInfo>
		<height public="1"><c path="Float"/></height>
		<filters public="1"><c path="Array"><c path="flash.filters.BitmapFilter"/></c></filters>
		<cacheAsBitmap public="1"><e path="Bool"/></cacheAsBitmap>
		<blendShader public="1" get="null">
			<c path="flash.display.Shader"/>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</blendShader>
		<blendMode public="1"><e path="flash.display.BlendMode"/></blendMode>
		<alpha public="1"><c path="Float"/></alpha>
		<accessibilityProperties public="1"><c path="flash.accessibility.AccessibilityProperties"/></accessibilityProperties>
	</class>
	<class path="flash.display.InteractiveObject" params="" file="C:\Motion-Twin\Haxe/std/flash/display/InteractiveObject.hx" extern="1">
		<extends path="flash.display.DisplayObject"/>
		<requestSoftKeyboard public="1">
			<f a=""><e path="Bool"/></f>
			<meta><m n=":require"><e>flash11</e></m></meta>
		</requestSoftKeyboard>
		<tabIndex public="1"><c path="Int"/></tabIndex>
		<tabEnabled public="1"><e path="Bool"/></tabEnabled>
		<softKeyboardInputAreaOfInterest public="1">
			<c path="flash.geom.Rectangle"/>
			<meta><m n=":require"><e>flash11</e></m></meta>
		</softKeyboardInputAreaOfInterest>
		<needsSoftKeyboard public="1">
			<e path="Bool"/>
			<meta><m n=":require"><e>flash11</e></m></meta>
		</needsSoftKeyboard>
		<mouseEnabled public="1"><e path="Bool"/></mouseEnabled>
		<focusRect public="1"><d/></focusRect>
		<doubleClickEnabled public="1"><e path="Bool"/></doubleClickEnabled>
		<contextMenu public="1"><c path="flash.ui.ContextMenu"/></contextMenu>
		<accessibilityImplementation public="1"><c path="flash.accessibility.AccessibilityImplementation"/></accessibilityImplementation>
		<new public="1" set="method"><f a=""><e path="Void"/></f></new>
	</class>
	<class path="flash.display.DisplayObjectContainer" params="" file="C:\Motion-Twin\Haxe/std/flash/display/DisplayObjectContainer.hx" extern="1">
		<extends path="flash.display.InteractiveObject"/>
		<swapChildrenAt public="1" set="method"><f a="index1:index2">
	<c path="Int"/>
	<c path="Int"/>
	<e path="Void"/>
</f></swapChildrenAt>
		<swapChildren public="1" set="method"><f a="child1:child2">
	<c path="flash.display.DisplayObject"/>
	<c path="flash.display.DisplayObject"/>
	<e path="Void"/>
</f></swapChildren>
		<setChildIndex public="1" set="method"><f a="child:index">
	<c path="flash.display.DisplayObject"/>
	<c path="Int"/>
	<e path="Void"/>
</f></setChildIndex>
		<removeChildren public="1">
			<f a="?beginIndex:?endIndex">
				<c path="Int"/>
				<c path="Int"/>
				<e path="Void"/>
			</f>
			<meta><m n=":require"><e>flash11</e></m></meta>
		</removeChildren>
		<removeChildAt public="1" set="method"><f a="index">
	<c path="Int"/>
	<c path="flash.display.DisplayObject"/>
</f></removeChildAt>
		<removeChild public="1" set="method"><f a="child">
	<c path="flash.display.DisplayObject"/>
	<c path="flash.display.DisplayObject"/>
</f></removeChild>
		<getObjectsUnderPoint public="1" set="method"><f a="point">
	<c path="flash.geom.Point"/>
	<c path="Array"><c path="flash.display.DisplayObject"/></c>
</f></getObjectsUnderPoint>
		<getChildIndex public="1" set="method"><f a="child">
	<c path="flash.display.DisplayObject"/>
	<c path="Int"/>
</f></getChildIndex>
		<getChildByName public="1" set="method"><f a="name">
	<c path="String"/>
	<c path="flash.display.DisplayObject"/>
</f></getChildByName>
		<getChildAt public="1" set="method"><f a="index">
	<c path="Int"/>
	<c path="flash.display.DisplayObject"/>
</f></getChildAt>
		<contains public="1" set="method"><f a="child">
	<c path="flash.display.DisplayObject"/>
	<e path="Bool"/>
</f></contains>
		<areInaccessibleObjectsUnderPoint public="1" set="method"><f a="point">
	<c path="flash.geom.Point"/>
	<e path="Bool"/>
</f></areInaccessibleObjectsUnderPoint>
		<addChildAt public="1" set="method"><f a="child:index">
	<c path="flash.display.DisplayObject"/>
	<c path="Int"/>
	<c path="flash.display.DisplayObject"/>
</f></addChildAt>
		<addChild public="1" set="method"><f a="child">
	<c path="flash.display.DisplayObject"/>
	<c path="flash.display.DisplayObject"/>
</f></addChild>
		<textSnapshot public="1" set="null"><c path="flash.text.TextSnapshot"/></textSnapshot>
		<tabChildren public="1"><e path="Bool"/></tabChildren>
		<numChildren public="1" set="null"><c path="Int"/></numChildren>
		<mouseChildren public="1"><e path="Bool"/></mouseChildren>
		<new public="1" set="method"><f a=""><e path="Void"/></f></new>
	</class>
	<class path="flash.display.Sprite" params="" file="C:\Motion-Twin\Haxe/std/flash/display/Sprite.hx" extern="1">
		<extends path="flash.display.DisplayObjectContainer"/>
		<stopTouchDrag public="1">
			<f a="touchPointID">
				<c path="Int"/>
				<e path="Void"/>
			</f>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</stopTouchDrag>
		<stopDrag public="1" set="method"><f a=""><e path="Void"/></f></stopDrag>
		<startTouchDrag public="1">
			<f a="touchPointID:?lockCenter:?bounds">
				<c path="Int"/>
				<e path="Bool"/>
				<c path="flash.geom.Rectangle"/>
				<e path="Void"/>
			</f>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</startTouchDrag>
		<startDrag public="1" set="method"><f a="?lockCenter:?bounds">
	<e path="Bool"/>
	<c path="flash.geom.Rectangle"/>
	<e path="Void"/>
</f></startDrag>
		<useHandCursor public="1"><e path="Bool"/></useHandCursor>
		<soundTransform public="1"><c path="flash.media.SoundTransform"/></soundTransform>
		<hitArea public="1"><c path="flash.display.Sprite"/></hitArea>
		<graphics public="1" set="null"><c path="flash.display.Graphics"/></graphics>
		<dropTarget public="1" set="null"><c path="flash.display.DisplayObject"/></dropTarget>
		<buttonMode public="1"><e path="Bool"/></buttonMode>
		<new public="1" set="method"><f a=""><e path="Void"/></f></new>
	</class>
	<class path="cn.royan.hl.uis.normal.InteractiveUiN" params="" file="cn/royan/hl/uis/normal/InteractiveUiN.hx">
		<extends path="flash.display.Sprite"/>
		<implements path="cn.royan.hl.interfaces.uis.IUiBase"/>
		<removeFromStageHandler set="method" line="407"><f a="evt">
	<c path="flash.events.Event"/>
	<e path="Void"/>
</f></removeFromStageHandler>
		<addToStageHandler set="method" line="387"><f a="?evt">
	<c path="flash.events.Event"/>
	<e path="Void"/>
</f></addToStageHandler>
		<mouseClickHandler set="method" line="381"><f a="evt">
	<c path="flash.events.MouseEvent"/>
	<e path="Void"/>
</f></mouseClickHandler>
		<mouseUpHandler set="method" line="373"><f a="evt">
	<c path="flash.events.MouseEvent"/>
	<e path="Void"/>
</f></mouseUpHandler>
		<mouseDownHandler set="method" line="365"><f a="evt">
	<c path="flash.events.MouseEvent"/>
	<e path="Void"/>
</f></mouseDownHandler>
		<mouseOutHandler set="method" line="357"><f a="evt">
	<c path="flash.events.MouseEvent"/>
	<e path="Void"/>
</f></mouseOutHandler>
		<mouseOverHandler set="method" line="349"><f a="evt">
	<c path="flash.events.MouseEvent"/>
	<e path="Void"/>
</f></mouseOverHandler>
		<dispose public="1" set="method" line="342"><f a=""><e path="Void"/></f></dispose>
		<removeAllChildren public="1" set="method" line="335"><f a=""><e path="Void"/></f></removeAllChildren>
		<removeAllEventListeners public="1" set="method" line="317"><f a=""><e path="Void"/></f></removeAllEventListeners>
		<removeEventListener public="1" set="method" line="294" override="1"><f a="type:listener:?useCapture">
	<c path="String"/>
	<f a="">
		<d/>
		<e path="Void"/>
	</f>
	<e path="Bool"/>
	<e path="Void"/>
</f></removeEventListener>
		<addEventListener public="1" set="method" line="281" override="1"><f a="type:listener:?useCapture:?priority:?useWeakReference">
	<c path="String"/>
	<f a="">
		<d/>
		<e path="Void"/>
	</f>
	<e path="Bool"/>
	<c path="Int"/>
	<e path="Bool"/>
	<e path="Void"/>
</f></addEventListener>
		<getInclude public="1" set="method" line="276"><f a=""><c path="Array"><c path="String"/></c></f></getInclude>
		<setInclude public="1" set="method" line="271"><f a="args">
	<c path="Array"><c path="String"/></c>
	<e path="Void"/>
</f></setInclude>
		<getExclude public="1" set="method" line="266"><f a=""><c path="Array"><c path="String"/></c></f></getExclude>
		<setExclude public="1" set="method" line="261"><f a="args">
	<c path="Array"><c path="String"/></c>
	<e path="Void"/>
</f></setExclude>
		<setMouseRender public="1" set="method" line="256"><f a="value">
	<e path="Bool"/>
	<e path="Void"/>
</f></setMouseRender>
		<getDispatcher public="1" set="method" line="251"><f a=""><c path="flash.events.EventDispatcher"/></f></getDispatcher>
		<setStyle public="1" set="method" line="246"><f a="value">
	<c path="cn.royan.hl.uis.style.Style"/>
	<e path="Void"/>
</f></setStyle>
		<getScale public="1" set="method" line="241"><f a=""><c path="Float"/></f></getScale>
		<setScale public="1" set="method" line="231"><f a="value">
	<c path="Float"/>
	<e path="Void"/>
</f></setScale>
		<getTexture public="1" set="method" line="226"><f a=""><d/></f></getTexture>
		<setTexture public="1" set="method" line="215"><f a="texture:?frames">
	<d/>
	<c path="Int"/>
	<e path="Void"/>
</f></setTexture>
		<getEnabled public="1" set="method" line="210"><f a=""><e path="Bool"/></f></getEnabled>
		<setEnabled public="1" set="method" line="202"><f a="value">
	<e path="Bool"/>
	<e path="Void"/>
</f></setEnabled>
		<getRange public="1" set="method" line="197"><f a=""><t path="cn.royan.hl.geom.Range"/></f></getRange>
		<setRange public="1" set="method" line="191"><f a="value">
	<t path="cn.royan.hl.geom.Range"/>
	<e path="Void"/>
</f></setRange>
		<setPosition public="1" set="method" line="181"><f a="cx:cy">
	<c path="Float"/>
	<c path="Float"/>
	<e path="Void"/>
</f></setPosition>
		<setSize public="1" set="method" line="167"><f a="w:h">
	<c path="Float"/>
	<c path="Float"/>
	<e path="Void"/>
</f></setSize>
		<setCallbacks public="1" set="method" line="162"><f a="value">
	<d/>
	<e path="Void"/>
</f></setCallbacks>
		<setBorder public="1" set="method" line="153"><f a="thick:color:alpha:?rx:?ry">
	<c path="Int"/>
	<c path="Int"/>
	<c path="Float"/>
	<c path="Int"/>
	<c path="Int"/>
	<e path="Void"/>
</f></setBorder>
		<getAlphas public="1" set="method" line="148"><f a=""><c path="Array"><d/></c></f></getAlphas>
		<getColors public="1" set="method" line="143"><f a=""><c path="Array"><d/></c></f></getColors>
		<setColorsAndAplhas public="1" set="method" line="122"><f a="color:alpha">
	<c path="Array"><d/></c>
	<c path="Array"><d/></c>
	<e path="Void"/>
</f></setColorsAndAplhas>
		<getDefaultTexture public="1" set="method" line="116"><f a=""><d/></f></getDefaultTexture>
		<draw public="1" set="method" line="101"><f a=""><e path="Void"/></f></draw>
		<background><c path="flash.display.Bitmap"/></background>
		<evtListenerDirectory><c path="Array"><d/></c></evtListenerDirectory>
		<evtListenerType><c path="Array"><c path="String"/></c></evtListenerType>
		<includes><c path="Array"><c path="String"/></c></includes>
		<excludes><c path="Array"><c path="String"/></c></excludes>
		<positionY><c path="Float"/></positionY>
		<positionX><c path="Float"/></positionX>
		<containerHeight><c path="Float"/></containerHeight>
		<containerWidth><c path="Float"/></containerWidth>
		<isOnStage><e path="Bool"/></isOnStage>
		<selected><e path="Bool"/></selected>
		<status><c path="Int"/></status>
		<isMouseRender><e path="Bool"/></isMouseRender>
		<callbacks><d/></callbacks>
		<borderRy><c path="Int"/></borderRy>
		<borderRx><c path="Int"/></borderRx>
		<borderAlpha><c path="Float"/></borderAlpha>
		<borderColor><c path="Int"/></borderColor>
		<borderThick><c path="Int"/></borderThick>
		<defaultTexture><c path="cn.royan.hl.uis.sparrow.Sparrow"/></defaultTexture>
		<bgTexture><c path="cn.royan.hl.uis.sparrow.Sparrow"/></bgTexture>
		<bgAlphas><c path="Array"><d/></c></bgAlphas>
		<bgColors><c path="Array"><d/></c></bgColors>
		<scale><c path="Float"/></scale>
		<originalDPI><c path="Int"/></originalDPI>
		<new public="1" set="method" line="65"><f a="?texture">
	<c path="cn.royan.hl.uis.sparrow.Sparrow"/>
	<e path="Void"/>
</f></new>
		<haxe_doc>* ...
 * @author RoYan</haxe_doc>
	</class>
	<class path="cn.royan.hl.uis.normal.UninteractiveUiN" params="" file="cn/royan/hl/uis/normal/UninteractiveUiN.hx">
		<extends path="flash.display.Sprite"/>
		<implements path="cn.royan.hl.interfaces.uis.IUiBase"/>
		<dispose public="1" set="method" line="254"><f a=""><e path="Void"/></f></dispose>
		<removeEventListener public="1" set="method" line="249" override="1"><f a="type:listener:?useCapture">
	<c path="String"/>
	<f a="">
		<d/>
		<e path="Void"/>
	</f>
	<e path="Bool"/>
	<e path="Void"/>
</f></removeEventListener>
		<addEventListener public="1" set="method" line="244" override="1"><f a="type:listener:?useCapture:?priority:?useWeakReference">
	<c path="String"/>
	<f a="">
		<d/>
		<e path="Void"/>
	</f>
	<e path="Bool"/>
	<c path="Int"/>
	<e path="Bool"/>
	<e path="Void"/>
</f></addEventListener>
		<getInclude public="1" set="method" line="239"><f a=""><c path="Array"><c path="String"/></c></f></getInclude>
		<setInclude public="1" set="method" line="234"><f a="args">
	<c path="Array"><c path="String"/></c>
	<e path="Void"/>
</f></setInclude>
		<getExclude public="1" set="method" line="229"><f a=""><c path="Array"><c path="String"/></c></f></getExclude>
		<setExclude public="1" set="method" line="224"><f a="args">
	<c path="Array"><c path="String"/></c>
	<e path="Void"/>
</f></setExclude>
		<getDispatcher public="1" set="method" line="219"><f a=""><c path="flash.events.EventDispatcher"/></f></getDispatcher>
		<setStyle public="1" set="method" line="214"><f a="value">
	<c path="cn.royan.hl.uis.style.Style"/>
	<e path="Void"/>
</f></setStyle>
		<getScale public="1" set="method" line="209"><f a=""><c path="Float"/></f></getScale>
		<setScale public="1" set="method" line="199"><f a="value">
	<c path="Float"/>
	<e path="Void"/>
</f></setScale>
		<getTexture public="1" set="method" line="194"><f a=""><d/></f></getTexture>
		<setTexture public="1" set="method" line="183"><f a="texture:?frames">
	<d/>
	<c path="Int"/>
	<e path="Void"/>
</f></setTexture>
		<getRange public="1" set="method" line="178"><f a=""><t path="cn.royan.hl.geom.Range"/></f></getRange>
		<setRange public="1" set="method" line="172"><f a="value">
	<t path="cn.royan.hl.geom.Range"/>
	<e path="Void"/>
</f></setRange>
		<setPosition public="1" set="method" line="162"><f a="cx:cy">
	<c path="Float"/>
	<c path="Float"/>
	<e path="Void"/>
</f></setPosition>
		<setSize public="1" set="method" line="148"><f a="w:h">
	<c path="Float"/>
	<c path="Float"/>
	<e path="Void"/>
</f></setSize>
		<setCallbacks public="1" set="method" line="143"><f a="value">
	<d/>
	<e path="Void"/>
</f></setCallbacks>
		<setBorder public="1" set="method" line="134"><f a="thick:color:alpha:?rx:?ry">
	<c path="Int"/>
	<c path="Int"/>
	<c path="Float"/>
	<c path="Int"/>
	<c path="Int"/>
	<e path="Void"/>
</f></setBorder>
		<getAlphas public="1" set="method" line="129"><f a=""><c path="Array"><d/></c></f></getAlphas>
		<getColors public="1" set="method" line="124"><f a=""><c path="Array"><d/></c></f></getColors>
		<setColorsAndAplhas public="1" set="method" line="103"><f a="color:alpha">
	<c path="Array"><d/></c>
	<c path="Array"><d/></c>
	<e path="Void"/>
</f></setColorsAndAplhas>
		<getDefaultTexture public="1" set="method" line="97"><f a=""><c path="cn.royan.hl.uis.sparrow.Sparrow"/></f></getDefaultTexture>
		<draw public="1" set="method" line="82"><f a=""><e path="Void"/></f></draw>
		<background><c path="flash.display.Bitmap"/></background>
		<includes><c path="Array"><c path="String"/></c></includes>
		<excludes><c path="Array"><c path="String"/></c></excludes>
		<positionY><c path="Float"/></positionY>
		<positionX><c path="Float"/></positionX>
		<containerHeight><c path="Float"/></containerHeight>
		<containerWidth><c path="Float"/></containerWidth>
		<borderRy><c path="Int"/></borderRy>
		<borderRx><c path="Int"/></borderRx>
		<borderAlpha><c path="Float"/></borderAlpha>
		<borderColor><c path="Int"/></borderColor>
		<borderThick><c path="Int"/></borderThick>
		<bgTexture><c path="cn.royan.hl.uis.sparrow.Sparrow"/></bgTexture>
		<defaultTexture><c path="cn.royan.hl.uis.sparrow.Sparrow"/></defaultTexture>
		<bgAlphas><c path="Array"><d/></c></bgAlphas>
		<bgColors><c path="Array"><d/></c></bgColors>
		<scale><c path="Float"/></scale>
		<originalDPI><c path="Int"/></originalDPI>
		<new public="1" set="method" line="53"><f a="?texture">
	<c path="cn.royan.hl.uis.sparrow.Sparrow"/>
	<e path="Void"/>
</f></new>
		<haxe_doc>* ...
 * @author RoYan</haxe_doc>
	</class>
	<class path="cn.royan.hl.uis.normal.bases.UiNBmpdButton" params="" file="cn/royan/hl/uis/normal/bases/UiNBmpdButton.hx">
		<extends path="cn.royan.hl.uis.normal.InteractiveUiN"/>
		<implements path="cn.royan.hl.interfaces.uis.IUiItemGroupBase"/>
		<dispose public="1" set="method" line="234" override="1"><f a=""><e path="Void"/></f></dispose>
		<setTexture public="1" set="method" line="213" override="1"><f a="value:?frames">
	<c path="cn.royan.hl.uis.sparrow.Sparrow"/>
	<c path="Int"/>
	<e path="Void"/>
</f></setTexture>
		<clone public="1" set="method" line="208"><f a=""><c path="cn.royan.hl.uis.normal.bases.UiNBmpdButton"/></f></clone>
		<getSelected public="1" set="method" line="203"><f a=""><e path="Bool"/></f></getSelected>
		<setSelected public="1" set="method" line="196"><f a="value">
	<e path="Bool"/>
	<e path="Void"/>
</f></setSelected>
		<setColorsAndAplhas public="1" set="method" line="164" override="1"><f a="color:alpha">
	<c path="Array"><d/></c>
	<c path="Array"><d/></c>
	<e path="Void"/>
</f></setColorsAndAplhas>
		<draw public="1" set="method" line="144" override="1"><f a=""><e path="Void"/></f></draw>
		<mouseMoveHandler set="method" line="132"><f a="evt">
	<c path="flash.events.MouseEvent"/>
	<e path="Void"/>
</f></mouseMoveHandler>
		<addToStageHandler set="method" line="125" override="1"><f a="?evt">
	<c path="flash.events.Event"/>
	<e path="Void"/>
</f></addToStageHandler>
		<drawTextures set="method" line="67"><f a="texture:statusLen">
	<c path="cn.royan.hl.uis.sparrow.Sparrow"/>
	<c path="Int"/>
	<e path="Void"/>
</f></drawTextures>
		<setInGroup public="1" set="method" line="62"><f a="value">
	<e path="Bool"/>
	<e path="Void"/>
</f></setInGroup>
		<freshRect><c path="flash.geom.Rectangle"/></freshRect>
		<isInGroup><e path="Bool"/></isInGroup>
		<currentStatus><c path="flash.display.Bitmap"/></currentStatus>
		<bgTextures><c path="Array"><c path="cn.royan.hl.uis.sparrow.Sparrow"/></c></bgTextures>
		<new public="1" set="method" line="30"><f a="texture:?frames">
	<d/>
	<c path="Int"/>
	<e path="Void"/>
</f></new>
		<haxe_doc>* ...
 * @author RoYan</haxe_doc>
	</class>
	<class path="cn.royan.hl.uis.normal.bases.UiNBmpdMovieClip" params="" file="cn/royan/hl/uis/normal/bases/UiNBmpdMovieClip.hx">
		<extends path="cn.royan.hl.uis.normal.InteractiveUiN"/>
		<implements path="cn.royan.hl.interfaces.uis.IUiItemPlayBase"/>
		<dispose public="1" set="method" line="267" override="1"><f a=""><e path="Void"/></f></dispose>
		<draw public="1" set="method" line="265" override="1"><f a=""><e path="Void"/></f></draw>
		<timerHandler set="method" line="229"><f a=""><e path="Void"/></f></timerHandler>
		<removeFromStageHandler set="method" line="222" override="1"><f a="evt">
	<c path="flash.events.Event"/>
	<e path="Void"/>
</f></removeFromStageHandler>
		<addToStageHandler set="method" line="215" override="1"><f a="?evt">
	<c path="flash.events.Event"/>
	<e path="Void"/>
</f></addToStageHandler>
		<stop public="1" set="method" line="209"><f a=""><e path="Void"/></f></stop>
		<play public="1" set="method" line="204"><f a=""><e path="Void"/></f></play>
		<goFromTo public="1" set="method" line="183"><f a="from:to">
	<c path="Int"/>
	<c path="Int"/>
	<e path="Void"/>
</f></goFromTo>
		<jumpTo public="1" set="method" line="168"><f a="frame">
	<c path="Int"/>
	<e path="Void"/>
</f></jumpTo>
		<goTo public="1" set="method" line="162"><f a="frame">
	<c path="Int"/>
	<e path="Void"/>
</f></goTo>
		<getOut public="1" set="method" line="157"><f a=""><e path="Void"/></f></getOut>
		<getIn public="1" set="method" line="152"><f a=""><e path="Void"/></f></getIn>
		<clone public="1" set="method" line="147"><f a=""><c path="cn.royan.hl.uis.normal.bases.UiNBmpdMovieClip"/></f></clone>
		<drawTextures set="method" line="85"><f a=""><e path="Void"/></f></drawTextures>
		<freshRect><c path="flash.geom.Rectangle"/></freshRect>
		<currentFrame><c path="flash.display.Bitmap"/></currentFrame>
		<autoPlay><e path="Bool"/></autoPlay>
		<loop><e path="Bool"/></loop>
		<sequence><e path="Bool"/></sequence>
		<frameRate><c path="Int"/></frameRate>
		<toFrame><c path="Int"/></toFrame>
		<totalCol><c path="Int"/></totalCol>
		<totalRow><c path="Int"/></totalRow>
		<total><c path="Int"/></total>
		<current><c path="Int"/></current>
		<timer><c path="cn.royan.hl.bases.TimerBase"/></timer>
		<bgTextures><c path="Array"><c path="cn.royan.hl.uis.sparrow.Sparrow"/></c></bgTextures>
		<new public="1" set="method" line="41"><f a="texture:?rate:?auto:?row:?column:?frames">
	<d/>
	<c path="Int"/>
	<e path="Bool"/>
	<c path="Int"/>
	<c path="Int"/>
	<c path="Int"/>
	<e path="Void"/>
</f></new>
		<haxe_doc>* ...
 * @author RoYan</haxe_doc>
	</class>
	<class path="cn.royan.hl.uis.normal.bases.UiNContainer" params="" file="cn/royan/hl/uis/normal/bases/UiNContainer.hx">
		<extends path="cn.royan.hl.uis.normal.InteractiveUiN"/>
		<implements path="cn.royan.hl.interfaces.uis.IUiContainerBase"/>
		<setHide public="1" set="method" line="207"><f a="effect">
	<f a=":">
		<d/>
		<d/>
		<e path="Void"/>
	</f>
	<e path="Void"/>
</f></setHide>
		<setShow public="1" set="method" line="202"><f a="effect">
	<f a="">
		<d/>
		<e path="Void"/>
	</f>
	<e path="Void"/>
</f></setShow>
		<getState public="1" set="method" line="197"><f a=""><c path="String"/></f></getState>
		<setState public="1" set="method" line="168"><f a="value">
	<c path="String"/>
	<e path="Void"/>
</f></setState>
		<setScale public="1" set="method" line="159" override="1"><f a="value">
	<c path="Float"/>
	<e path="Void"/>
</f></setScale>
		<getItems public="1" set="method" line="154"><f a=""><c path="Array"><c path="cn.royan.hl.interfaces.uis.IUiBase"/></c></f></getItems>
		<getIndexByItem public="1" set="method" line="146"><f a="item">
	<c path="cn.royan.hl.interfaces.uis.IUiBase"/>
	<c path="Int"/>
</f></getIndexByItem>
		<getItemAt public="1" set="method" line="141"><f a="index">
	<c path="Int"/>
	<c path="cn.royan.hl.interfaces.uis.IUiBase"/>
</f></getItemAt>
		<removeAllItems public="1" set="method" line="124"><f a=""><e path="Void"/></f></removeAllItems>
		<removeItemAt public="1" set="method" line="111"><f a="index">
	<c path="Int"/>
	<c path="cn.royan.hl.interfaces.uis.IUiBase"/>
</f></removeItemAt>
		<removeItem public="1" set="method" line="91"><f a="item">
	<c path="cn.royan.hl.interfaces.uis.IUiBase"/>
	<c path="cn.royan.hl.interfaces.uis.IUiBase"/>
</f></removeItem>
		<addItemAt public="1" set="method" line="65"><f a="item:index">
	<c path="cn.royan.hl.interfaces.uis.IUiBase"/>
	<c path="Int"/>
	<c path="cn.royan.hl.interfaces.uis.IUiBase"/>
</f></addItemAt>
		<addItem public="1" set="method" line="44"><f a="item">
	<c path="cn.royan.hl.interfaces.uis.IUiBase"/>
	<c path="cn.royan.hl.interfaces.uis.IUiBase"/>
</f></addItem>
		<addToStageHandler set="method" line="36" override="1"><f a="?evt">
	<c path="flash.events.Event"/>
	<e path="Void"/>
</f></addToStageHandler>
		<hideProp><f a=":">
	<d/>
	<d/>
	<e path="Void"/>
</f></hideProp>
		<showProp><f a="">
	<d/>
	<e path="Void"/>
</f></showProp>
		<items><c path="Array"><c path="cn.royan.hl.interfaces.uis.IUiBase"/></c></items>
		<current><c path="String"/></current>
		<states><c path="Array"><c path="String"/></c></states>
		<new public="1" set="method" line="28"><f a="?texture">
	<c path="cn.royan.hl.uis.sparrow.Sparrow"/>
	<e path="Void"/>
</f></new>
		<haxe_doc>* ...
 * @author RoYan</haxe_doc>
	</class>
	<typedef path="cn.royan.hl.uis.normal.bases._UiNContainerAlign.ContainerGap" params="" file="cn/royan/hl/uis/normal/bases/UiNContainerAlign.hx" private="1" module="cn.royan.hl.uis.normal.bases.UiNContainerAlign">
		<a>
			<y><c path="Int"/></y>
			<x><c path="Int"/></x>
		</a>
		<haxe_doc>* ...
 * @author RoYan</haxe_doc>
	</typedef>
	<typedef path="cn.royan.hl.uis.normal.bases._UiNContainerAlign.ContainerMargin" params="" file="cn/royan/hl/uis/normal/bases/UiNContainerAlign.hx" private="1" module="cn.royan.hl.uis.normal.bases.UiNContainerAlign"><a>
	<top><c path="Int"/></top>
	<right><c path="Int"/></right>
	<left><c path="Int"/></left>
	<bottom><c path="Int"/></bottom>
</a></typedef>
	<typedef path="cn.royan.hl.uis.normal.bases._UiNContainerAlign.ContainerRowConfig" params="" file="cn/royan/hl/uis/normal/bases/UiNContainerAlign.hx" private="1" module="cn.royan.hl.uis.normal.bases.UiNContainerAlign"><a>
	<width><c path="Float"/></width>
	<length><c path="Int"/></length>
	<height><c path="Float"/></height>
</a></typedef>
	<class path="cn.royan.hl.uis.normal.bases.UiNContainerAlign" params="" file="cn/royan/hl/uis/normal/bases/UiNContainerAlign.hx">
		<extends path="cn.royan.hl.uis.normal.bases.UiNContainer"/>
		<implements path="cn.royan.hl.interfaces.uis.IUiContainerAlignBase"/>
		<drawRow set="method" line="151"><f a=""><e path="Void"/></f></drawRow>
		<fillRow set="method" line="104"><f a=""><e path="Void"/></f></fillRow>
		<setMove public="1" set="method" line="99"><f a="effect">
	<f a="">
		<d/>
		<e path="Void"/>
	</f>
	<e path="Void"/>
</f></setMove>
		<setMargins public="1" set="method" line="94"><f a="left:top:right:bottom">
	<c path="Int"/>
	<c path="Int"/>
	<c path="Int"/>
	<c path="Int"/>
	<e path="Void"/>
</f></setMargins>
		<setGaps public="1" set="method" line="89"><f a="gapX:gapY">
	<c path="Int"/>
	<c path="Int"/>
	<e path="Void"/>
</f></setGaps>
		<setContentAlign public="1" set="method" line="84"><f a="value">
	<c path="Int"/>
	<e path="Void"/>
</f></setContentAlign>
		<setVerticalAlign public="1" set="method" line="79"><f a="value">
	<c path="Int"/>
	<e path="Void"/>
</f></setVerticalAlign>
		<setHorizontalAlign public="1" set="method" line="74"><f a="value">
	<c path="Int"/>
	<e path="Void"/>
</f></setHorizontalAlign>
		<dispose public="1" set="method" line="63" override="1"><f a=""><e path="Void"/></f></dispose>
		<draw public="1" set="method" line="54" override="1"><f a=""><e path="Void"/></f></draw>
		<moveProp><f a="">
	<d/>
	<e path="Void"/>
</f></moveProp>
		<itemsHeight><c path="Float"/></itemsHeight>
		<itemsWidth><c path="Float"/></itemsWidth>
		<margins><t path="cn.royan.hl.uis.normal.bases._UiNContainerAlign.ContainerMargin"/></margins>
		<gaps><t path="cn.royan.hl.uis.normal.bases._UiNContainerAlign.ContainerGap"/></gaps>
		<rows><c path="Array"><t path="cn.royan.hl.uis.normal.bases._UiNContainerAlign.ContainerRowConfig"/></c></rows>
		<contentAlign><c path="Int"/></contentAlign>
		<verticalAlign><c path="Int"/></verticalAlign>
		<horizontalAlign><c path="Int"/></horizontalAlign>
		<new public="1" set="method" line="48"><f a="?texture">
	<c path="cn.royan.hl.uis.sparrow.Sparrow"/>
	<e path="Void"/>
</f></new>
	</class>
	<class path="cn.royan.hl.uis.normal.bases.UiNContainerGroup" params="" file="cn/royan/hl/uis/normal/bases/UiNContainerGroup.hx">
		<extends path="cn.royan.hl.uis.normal.bases.UiNContainerAlign"/>
		<implements path="cn.royan.hl.interfaces.uis.IUiContainerGroupBase"/>
		<removeAllItems public="1" set="method" line="293" override="1"><f a=""><e path="Void"/></f></removeAllItems>
		<removeItemAt public="1" set="method" line="291" override="1"><f a="index">
	<c path="Int"/>
	<c path="cn.royan.hl.interfaces.uis.IUiBase"/>
</f></removeItemAt>
		<removeItem public="1" set="method" line="289" override="1"><f a="item">
	<c path="cn.royan.hl.interfaces.uis.IUiBase"/>
	<c path="cn.royan.hl.interfaces.uis.IUiBase"/>
</f></removeItem>
		<addItemAt public="1" set="method" line="287" override="1"><f a="item:index">
	<c path="cn.royan.hl.interfaces.uis.IUiBase"/>
	<c path="Int"/>
	<c path="cn.royan.hl.interfaces.uis.IUiBase"/>
</f></addItemAt>
		<addItem public="1" set="method" line="285" override="1"><f a="item">
	<c path="cn.royan.hl.interfaces.uis.IUiBase"/>
	<c path="cn.royan.hl.interfaces.uis.IUiBase"/>
</f></addItem>
		<addToStageHandler set="method" line="276" override="1"><f a="?evt">
	<c path="flash.events.Event"/>
	<e path="Void"/>
</f></addToStageHandler>
		<getKey set="method" line="266"><f a="value">
	<c path="cn.royan.hl.interfaces.uis.IUiItemGroupBase"/>
	<d/>
</f></getKey>
		<itemSelectHandler set="method" line="213"><f a="evt">
	<c path="flash.events.MouseEvent"/>
	<e path="Void"/>
</f></itemSelectHandler>
		<dispose public="1" set="method" line="204" override="1"><f a=""><e path="Void"/></f></dispose>
		<setMaxLen public="1" set="method" line="199"><f a="value">
	<c path="Int"/>
	<e path="Void"/>
</f></setMaxLen>
		<setIsMulti public="1" set="method" line="194"><f a="value">
	<e path="Bool"/>
	<e path="Void"/>
</f></setIsMulti>
		<setIsMust public="1" set="method" line="189"><f a="value">
	<e path="Bool"/>
	<e path="Void"/>
</f></setIsMust>
		<getValue set="method" line="177"><f a="key">
	<d/>
	<c path="cn.royan.hl.interfaces.uis.IUiItemGroupBase"/>
</f></getValue>
		<setValues public="1" set="method" line="165"><f a="array">
	<c path="Array"><d/></c>
	<e path="Void"/>
</f></setValues>
		<getValues public="1" set="method" line="160"><f a=""><c path="Array"><d/></c></f></getValues>
		<getSelectedItems public="1" set="method" line="155"><f a=""><c path="Array"><c path="cn.royan.hl.interfaces.uis.IUiItemGroupBase"/></c></f></getSelectedItems>
		<getGroupItems public="1" set="method" line="150"><f a=""><c path="Array"><c path="cn.royan.hl.interfaces.uis.IUiItemGroupBase"/></c></f></getGroupItems>
		<getIndexByGroupItem public="1" set="method" line="145"><f a="item">
	<c path="cn.royan.hl.interfaces.uis.IUiItemGroupBase"/>
	<c path="Int"/>
</f></getIndexByGroupItem>
		<getGroupItemAt public="1" set="method" line="140"><f a="index">
	<c path="Int"/>
	<c path="cn.royan.hl.interfaces.uis.IUiItemGroupBase"/>
</f></getGroupItemAt>
		<removeAllGroupItems public="1" set="method" line="128"><f a=""><e path="Void"/></f></removeAllGroupItems>
		<removeGroupItemAt public="1" set="method" line="115"><f a="index">
	<c path="Int"/>
	<c path="cn.royan.hl.interfaces.uis.IUiItemGroupBase"/>
</f></removeGroupItemAt>
		<removeGroupItem public="1" set="method" line="95"><f a="item">
	<c path="cn.royan.hl.interfaces.uis.IUiItemGroupBase"/>
	<c path="cn.royan.hl.interfaces.uis.IUiItemGroupBase"/>
</f></removeGroupItem>
		<addGroupItemAt public="1" set="method" line="64"><f a="item:index:?key">
	<c path="cn.royan.hl.interfaces.uis.IUiItemGroupBase"/>
	<c path="Int"/>
	<d/>
	<c path="cn.royan.hl.interfaces.uis.IUiItemGroupBase"/>
</f></addGroupItemAt>
		<addGroupItem public="1" set="method" line="42"><f a="item:?key">
	<c path="cn.royan.hl.interfaces.uis.IUiItemGroupBase"/>
	<d/>
	<c path="cn.royan.hl.interfaces.uis.IUiItemGroupBase"/>
</f></addGroupItem>
		<values><c path="Array"><d/></c></values>
		<selects><c path="Array"><c path="cn.royan.hl.interfaces.uis.IUiItemGroupBase"/></c></selects>
		<keys><c path="Array"><d/></c></keys>
		<maxLen><c path="Int"/></maxLen>
		<isMust><e path="Bool"/></isMust>
		<isMulti><e path="Bool"/></isMulti>
		<new public="1" set="method" line="28"><f a="?texture">
	<c path="cn.royan.hl.uis.sparrow.Sparrow"/>
	<e path="Void"/>
</f></new>
		<haxe_doc>* ...
 * @author RoYan</haxe_doc>
	</class>
	<class path="cn.royan.hl.uis.normal.bases.UiNLabelButton" params="" file="cn/royan/hl/uis/normal/bases/UiNLabelButton.hx">
		<extends path="cn.royan.hl.uis.normal.bases.UiNBmpdButton"/>
		<implements path="cn.royan.hl.interfaces.uis.IUiItemGroupBase"/>
		<implements path="cn.royan.hl.interfaces.uis.IUiTextBase"/>
		<setMultiLine public="1" set="method" line="205"><f a="value">
	<e path="Bool"/>
	<e path="Void"/>
</f></setMultiLine>
		<getMaxScroll public="1" set="method" line="200"><f a=""><t path="cn.royan.hl.geom.Range"/></f></getMaxScroll>
		<getScroll public="1" set="method" line="195"><f a=""><t path="cn.royan.hl.geom.Range"/></f></getScroll>
		<setScroll public="1" set="method" line="190"><f a="?sx:?sy">
	<c path="Int"/>
	<c path="Int"/>
	<e path="Void"/>
</f></setScroll>
		<getDefaultFormat public="1" set="method" line="185"><f a=""><c path="flash.text.TextFormat"/></f></getDefaultFormat>
		<setDefaultFormat public="1" set="method" line="180"><f a="value">
	<c path="flash.text.TextFormat"/>
	<e path="Void"/>
</f></setDefaultFormat>
		<getFormat public="1" set="method" line="175"><f a="?begin:?end">
	<c path="Int"/>
	<c path="Int"/>
	<c path="flash.text.TextFormat"/>
</f></getFormat>
		<setFormat public="1" set="method" line="170"><f a="value:?begin:?end">
	<c path="flash.text.TextFormat"/>
	<c path="Int"/>
	<c path="Int"/>
	<e path="Void"/>
</f></setFormat>
		<setEmbedFont public="1" set="method" line="165"><f a="value">
	<e path="Bool"/>
	<e path="Void"/>
</f></setEmbedFont>
		<setTextSize public="1" set="method" line="160"><f a="value">
	<c path="Int"/>
	<e path="Void"/>
</f></setTextSize>
		<setTextColor public="1" set="method" line="155"><f a="value">
	<c path="Int"/>
	<e path="Void"/>
</f></setTextColor>
		<setTextAlign public="1" set="method" line="150"><f a="value">
	<c path="Int"/>
	<e path="Void"/>
</f></setTextAlign>
		<getHTMLText public="1" set="method" line="145"><f a=""><c path="String"/></f></getHTMLText>
		<appendHTMLText public="1" set="method" line="140"><f a="value">
	<c path="String"/>
	<e path="Void"/>
</f></appendHTMLText>
		<setHTMLText public="1" set="method" line="135"><f a="value">
	<c path="String"/>
	<e path="Void"/>
</f></setHTMLText>
		<getText public="1" set="method" line="130"><f a=""><c path="String"/></f></getText>
		<appendText public="1" set="method" line="125"><f a="value">
	<c path="String"/>
	<e path="Void"/>
</f></appendText>
		<setText public="1" set="method" line="120"><f a="value">
	<c path="String"/>
	<e path="Void"/>
</f></setText>
		<setTextMargin public="1" set="method" line="114"><f a="left:top:right:bottom">
	<c path="Int"/>
	<c path="Int"/>
	<c path="Int"/>
	<c path="Int"/>
	<e path="Void"/>
</f></setTextMargin>
		<setScale public="1" set="method" line="108" override="1"><f a="value">
	<c path="Float"/>
	<e path="Void"/>
</f></setScale>
		<setSize public="1" set="method" line="98" override="1"><f a="cWidth:cHeight">
	<c path="Float"/>
	<c path="Float"/>
	<e path="Void"/>
</f></setSize>
		<setTextColors public="1" set="method" line="92"><f a="value">
	<c path="Array"><d/></c>
	<e path="Void"/>
</f></setTextColors>
		<setType public="1" set="method" line="87"><f a="type">
	<c path="Int"/>
	<e path="Void"/>
</f></setType>
		<setTextSpace public="1" set="method" line="82"><f a="r:c">
	<c path="Int"/>
	<c path="Int"/>
	<e path="Void"/>
</f></setTextSpace>
		<autoCenter public="1" set="method" line="75"><f a=""><e path="Void"/></f></autoCenter>
		<getDefaultTextColor public="1" set="method" line="70"><f a=""><c path="Array"><d/></c></f></getDefaultTextColor>
		<mouseClickHandler set="method" line="59" override="1"><f a="evt">
	<c path="flash.events.MouseEvent"/>
	<e path="Void"/>
</f></mouseClickHandler>
		<draw public="1" set="method" line="52" override="1"><f a=""><e path="Void"/></f></draw>
		<textColors><c path="Array"><d/></c></textColors>
		<btnLabelText><c path="cn.royan.hl.uis.normal.bases.UiNText"/></btnLabelText>
		<btnLabel><c path="String"/></btnLabel>
		<isCenter><e path="Bool"/></isCenter>
		<new public="1" set="method" line="29"><f a="?label:?texture:?frames">
	<c path="String"/>
	<d/>
	<c path="Int"/>
	<e path="Void"/>
</f></new>
		<haxe_doc>* ...
 * @author RoYan</haxe_doc>
	</class>
	<class path="cn.royan.hl.uis.normal.bases.UiNLoader" params="" file="cn/royan/hl/uis/normal/bases/UiNLoader.hx">
		<extends path="cn.royan.hl.uis.normal.InteractiveUiN"/>
		<loaderCompleteHandler set="method" line="60"><f a="evt">
	<c path="cn.royan.hl.events.DatasEvent"/>
	<e path="Void"/>
</f></loaderCompleteHandler>
		<loaderProgressHandler set="method" line="55"><f a="evt">
	<c path="cn.royan.hl.events.DatasEvent"/>
	<e path="Void"/>
</f></loaderProgressHandler>
		<loaderComplete public="1" set="method" line="50"><f a=""><e path="Void"/></f></loaderComplete>
		<loaderProgress public="1" set="method" line="45"><f a="data">
	<a>
		<total><c path="Int"/></total>
		<loaded><c path="Int"/></loaded>
	</a>
	<e path="Void"/>
</f></loaderProgress>
		<setLoaderData public="1" set="method" line="37"><f a="loader">
	<c path="cn.royan.hl.bases.DispatcherBase"/>
	<e path="Void"/>
</f></setLoaderData>
		<progressBar><c path="flash.display.Sprite"/></progressBar>
		<progressTxt><c path="flash.text.TextField"/></progressTxt>
		<currentFileName><c path="flash.text.TextField"/></currentFileName>
		<loaderData><c path="cn.royan.hl.bases.DispatcherBase"/></loaderData>
		<new public="1" set="method" line="24"><f a="?loader">
	<c path="cn.royan.hl.bases.DispatcherBase"/>
	<e path="Void"/>
</f></new>
		<haxe_doc>* ...
 * @author RoYan</haxe_doc>
	</class>
	<class path="cn.royan.hl.uis.normal.bases.UiNScrollBar" params="" file="cn/royan/hl/uis/normal/bases/UiNScrollBar.hx">
		<extends path="cn.royan.hl.uis.normal.bases.UiNContainerAlign"/>
		<implements path="cn.royan.hl.interfaces.uis.IUiScrollBarBase"/>
		<setBackgroundTextrue public="1" set="method" line="257"><f a="texture">
	<d/>
	<e path="Void"/>
</f></setBackgroundTextrue>
		<setMaxTexture public="1" set="method" line="252"><f a="texture">
	<d/>
	<e path="Void"/>
</f></setMaxTexture>
		<setMinTexture public="1" set="method" line="247"><f a="texture">
	<d/>
	<e path="Void"/>
</f></setMinTexture>
		<setThumbTexture public="1" set="method" line="242"><f a="texture">
	<d/>
	<e path="Void"/>
</f></setThumbTexture>
		<setType public="1" set="method" line="228"><f a="type">
	<c path="Int"/>
	<e path="Void"/>
</f></setType>
		<getValue public="1" set="method" line="217"><f a=""><c path="Int"/></f></getValue>
		<setValue public="1" set="method" line="207"><f a="value">
	<c path="Int"/>
	<e path="Void"/>
</f></setValue>
		<setSize public="1" set="method" line="175" override="1"><f a="w:h">
	<c path="Float"/>
	<c path="Float"/>
	<e path="Void"/>
</f></setSize>
		<thumbEnterFrameHandler set="method" line="169"><f a="evt">
	<c path="flash.events.Event"/>
	<e path="Void"/>
</f></thumbEnterFrameHandler>
		<thumbMouseUpHandler set="method" line="160"><f a="evt">
	<c path="flash.events.MouseEvent"/>
	<e path="Void"/>
</f></thumbMouseUpHandler>
		<thumbMouseDownHandler set="method" line="151"><f a="evt">
	<c path="flash.events.MouseEvent"/>
	<e path="Void"/>
</f></thumbMouseDownHandler>
		<backgroundClickHandler set="method" line="130"><f a="evt">
	<c path="flash.events.MouseEvent"/>
	<e path="Void"/>
</f></backgroundClickHandler>
		<maxMouseUpHandler set="method" line="122"><f a="evt">
	<c path="flash.events.MouseEvent"/>
	<e path="Void"/>
</f></maxMouseUpHandler>
		<maxEnterHandler set="method" line="105"><f a="evt">
	<c path="flash.events.Event"/>
	<e path="Void"/>
</f></maxEnterHandler>
		<maxMouseDownHandler set="method" line="97"><f a="evt">
	<c path="flash.events.MouseEvent"/>
	<e path="Void"/>
</f></maxMouseDownHandler>
		<minMouseUpHandler set="method" line="89"><f a="evt">
	<c path="flash.events.MouseEvent"/>
	<e path="Void"/>
</f></minMouseUpHandler>
		<minEnterHandler set="method" line="73"><f a="evt">
	<c path="flash.events.Event"/>
	<e path="Void"/>
</f></minEnterHandler>
		<minMouseDownHandler set="method" line="65"><f a="evt">
	<c path="flash.events.MouseEvent"/>
	<e path="Void"/>
</f></minMouseDownHandler>
		<addToStageHandler set="method" line="53" override="1"><f a="?evt">
	<c path="flash.events.Event"/>
	<e path="Void"/>
</f></addToStageHandler>
		<scrollerType><c path="Int"/></scrollerType>
		<rect><c path="flash.geom.Rectangle"/></rect>
		<bar><c path="cn.royan.hl.uis.normal.InteractiveUiN"/></bar>
		<thumb><c path="cn.royan.hl.uis.normal.bases.UiNLabelButton"/></thumb>
		<max><c path="cn.royan.hl.uis.normal.bases.UiNLabelButton"/></max>
		<min><c path="cn.royan.hl.uis.normal.bases.UiNLabelButton"/></min>
		<new public="1" set="method" line="27"><f a="?type">
	<c path="Int"/>
	<e path="Void"/>
</f></new>
		<haxe_doc>* ...
 * @author RoYan</haxe_doc>
	</class>
	<class path="cn.royan.hl.uis.normal.bases.UiNScrollPane" params="" file="cn/royan/hl/uis/normal/bases/UiNScrollPane.hx">
		<extends path="cn.royan.hl.uis.normal.InteractiveUiN"/>
		<implements path="cn.royan.hl.interfaces.uis.IUiScrollPaneBase"/>
		<setBackgroundTextrue public="1" set="method" line="179"><f a="texture">
	<d/>
	<e path="Void"/>
</f></setBackgroundTextrue>
		<setMaxTexture public="1" set="method" line="173"><f a="texture">
	<d/>
	<e path="Void"/>
</f></setMaxTexture>
		<setMinTexture public="1" set="method" line="167"><f a="texture">
	<d/>
	<e path="Void"/>
</f></setMinTexture>
		<setThumbTexture public="1" set="method" line="161"><f a="texture">
	<d/>
	<e path="Void"/>
</f></setThumbTexture>
		<vChangeHandler set="method" line="156"><f a="evt">
	<c path="cn.royan.hl.events.DatasEvent"/>
	<e path="Void"/>
</f></vChangeHandler>
		<hChangeHandler set="method" line="151"><f a="evt">
	<c path="cn.royan.hl.events.DatasEvent"/>
	<e path="Void"/>
</f></hChangeHandler>
		<setType public="1" set="method" line="111"><f a="type">
	<c path="Int"/>
	<e path="Void"/>
</f></setType>
		<setSize public="1" set="method" line="83" override="1"><f a="cWidth:cHeight">
	<c path="Float"/>
	<c path="Float"/>
	<e path="Void"/>
</f></setSize>
		<changeHandler set="method" line="66"><f a="?evt">
	<c path="cn.royan.hl.events.DatasEvent"/>
	<e path="Void"/>
</f></changeHandler>
		<addToStageHandler set="method" line="55" override="1"><f a="?evt">
	<c path="flash.events.Event"/>
	<e path="Void"/>
</f></addToStageHandler>
		<vScrollBar><c path="cn.royan.hl.uis.normal.bases.UiNScrollBar"/></vScrollBar>
		<hScrollBar><c path="cn.royan.hl.uis.normal.bases.UiNScrollBar"/></hScrollBar>
		<scrollerType><c path="Int"/></scrollerType>
		<containerMask><c path="cn.royan.hl.uis.normal.UninteractiveUiN"/></containerMask>
		<container><c path="cn.royan.hl.uis.normal.InteractiveUiN"/></container>
		<new public="1" set="method" line="32"><f a="container:?type">
	<c path="cn.royan.hl.uis.normal.InteractiveUiN"/>
	<c path="Int"/>
	<e path="Void"/>
</f></new>
		<haxe_doc>* ...
 * @author RoYan</haxe_doc>
	</class>
	<class path="cn.royan.hl.uis.normal.bases.UiNText" params="" file="cn/royan/hl/uis/normal/bases/UiNText.hx">
		<extends path="cn.royan.hl.uis.normal.InteractiveUiN"/>
		<implements path="cn.royan.hl.interfaces.uis.IUiTextBase"/>
		<setMaxChars public="1" set="method" line="225"><f a="value">
	<c path="Int"/>
	<e path="Void"/>
</f></setMaxChars>
		<setMultiLine public="1" set="method" line="219"><f a="value">
	<e path="Bool"/>
	<e path="Void"/>
</f></setMultiLine>
		<getMaxScroll public="1" set="method" line="214"><f a=""><t path="cn.royan.hl.geom.Range"/></f></getMaxScroll>
		<getScroll public="1" set="method" line="209"><f a=""><t path="cn.royan.hl.geom.Range"/></f></getScroll>
		<setScroll public="1" set="method" line="203"><f a="?sx:?sy">
	<c path="Int"/>
	<c path="Int"/>
	<e path="Void"/>
</f></setScroll>
		<getDispatcher public="1" set="method" line="197" override="1"><f a=""><c path="flash.events.EventDispatcher"/></f></getDispatcher>
		<getDefaultFormat public="1" set="method" line="192"><f a=""><c path="flash.text.TextFormat"/></f></getDefaultFormat>
		<setDefaultFormat public="1" set="method" line="187"><f a="value">
	<c path="flash.text.TextFormat"/>
	<e path="Void"/>
</f></setDefaultFormat>
		<getFormat public="1" set="method" line="178"><f a="?begin:?end">
	<c path="Int"/>
	<c path="Int"/>
	<c path="flash.text.TextFormat"/>
</f></getFormat>
		<setFormat public="1" set="method" line="173"><f a="value:?begin:?end">
	<c path="flash.text.TextFormat"/>
	<c path="Int"/>
	<c path="Int"/>
	<e path="Void"/>
</f></setFormat>
		<setEmbedFont public="1" set="method" line="168"><f a="value">
	<e path="Bool"/>
	<e path="Void"/>
</f></setEmbedFont>
		<setTextSize public="1" set="method" line="159"><f a="value">
	<c path="Int"/>
	<e path="Void"/>
</f></setTextSize>
		<setTextColor public="1" set="method" line="154"><f a="value">
	<c path="Int"/>
	<e path="Void"/>
</f></setTextColor>
		<setTextAlign public="1" set="method" line="140"><f a="value">
	<c path="Int"/>
	<e path="Void"/>
</f></setTextAlign>
		<getHTMLText public="1" set="method" line="135"><f a=""><c path="String"/></f></getHTMLText>
		<appendHTMLText public="1" set="method" line="130"><f a="value">
	<c path="String"/>
	<e path="Void"/>
</f></appendHTMLText>
		<setHTMLText public="1" set="method" line="125"><f a="value">
	<c path="String"/>
	<e path="Void"/>
</f></setHTMLText>
		<getText public="1" set="method" line="120"><f a=""><c path="String"/></f></getText>
		<appendText public="1" set="method" line="115"><f a="value">
	<c path="String"/>
	<e path="Void"/>
</f></appendText>
		<setText public="1" set="method" line="110"><f a="value">
	<c path="String"/>
	<e path="Void"/>
</f></setText>
		<autoSize public="1" set="method" line="95"><f a="value">
	<c path="Int"/>
	<e path="Void"/>
</f></autoSize>
		<setType public="1" set="method" line="81"><f a="type">
	<c path="Int"/>
	<e path="Void"/>
</f></setType>
		<setTextSpace public="1" set="method" line="71"><f a="r:c">
	<c path="Int"/>
	<c path="Int"/>
	<e path="Void"/>
</f></setTextSpace>
		<setRestrict public="1" set="method" line="65"><f a="value">
	<c path="String"/>
	<e path="Void"/>
</f></setRestrict>
		<setScale public="1" set="method" line="50" override="1"><f a="value">
	<c path="Float"/>
	<e path="Void"/>
</f></setScale>
		<setSize public="1" set="method" line="42" override="1"><f a="w:h">
	<c path="Float"/>
	<c path="Float"/>
	<e path="Void"/>
</f></setSize>
		<defaultSize><c path="Float"/></defaultSize>
		<inputText><c path="flash.text.TextField"/></inputText>
		<new public="1" set="method" line="24"><f a="?label">
	<c path="String"/>
	<e path="Void"/>
</f></new>
		<haxe_doc>* ...
 * @author RoYan</haxe_doc>
	</class>
	<class path="cn.royan.hl.uis.normal.bases.UiNWindow" params="" file="cn/royan/hl/uis/normal/bases/UiNWindow.hx">
		<extends path="cn.royan.hl.uis.normal.bases.UiNContainer"/>
		<upHandler set="method" line="35"><f a="obj">
	<c path="cn.royan.hl.uis.normal.bases.UiNLabelButton"/>
	<e path="Void"/>
</f></upHandler>
		<downHandler set="method" line="30"><f a="obj">
	<c path="cn.royan.hl.uis.normal.bases.UiNLabelButton"/>
	<e path="Void"/>
</f></downHandler>
		<setHeaderHeight public="1" set="method" line="25"><f a="value">
	<c path="Int"/>
	<e path="Void"/>
</f></setHeaderHeight>
		<header><c path="cn.royan.hl.uis.normal.bases.UiNLabelButton"/></header>
		<new public="1" set="method" line="13"><f a="?texture">
	<c path="cn.royan.hl.uis.sparrow.Sparrow"/>
	<e path="Void"/>
</f></new>
		<haxe_doc>* ...
 * @author RoYan</haxe_doc>
	</class>
	<class path="cn.royan.hl.uis.normal.exts.UiNExtBmpNumberText" params="" file="cn/royan/hl/uis/normal/exts/UiNExtBmpNumberText.hx">
		<extends path="cn.royan.hl.uis.normal.bases.UiNContainerAlign"/>
		<getValue public="1" set="method" line="71"><f a=""><c path="Int"/></f></getValue>
		<setValue public="1" set="method" line="39"><f a="value">
	<c path="Int"/>
	<e path="Void"/>
</f></setValue>
		<setIsAlwaysShow public="1" set="method" line="28"><f a="value">
	<e path="Bool"/>
	<e path="Void"/>
</f></setIsAlwaysShow>
		<length><c path="Int"/></length>
		<num><c path="Int"/></num>
		<isAlwaysShow><e path="Bool"/></isAlwaysShow>
		<instance><c path="cn.royan.hl.uis.normal.bases.UiNBmpdMovieClip"/></instance>
		<new public="1" set="method" line="20"><f a="texture:?len">
	<c path="Array"><c path="starling.textures.Texture"/></c>
	<c path="Int"/>
	<e path="Void"/>
</f></new>
		<haxe_doc>* ...
 * @author RoYan</haxe_doc>
	</class>
	<typedef path="cn.royan.hl.uis.normal.exts.ItemType" params="" file="cn/royan/hl/uis/normal/exts/UiNExtCombobox.hx" module="cn.royan.hl.uis.normal.exts.UiNExtCombobox">
		<a>
			<value><d/></value>
			<label><c path="String"/></label>
		</a>
		<haxe_doc>* ...
 * @author RoYan</haxe_doc>
	</typedef>
	<class path="cn.royan.hl.uis.normal.exts.UiNExtCombobox" params="" file="cn/royan/hl/uis/normal/exts/UiNExtCombobox.hx">
		<extends path="cn.royan.hl.uis.normal.InteractiveUiN"/>
		<setMaxLen public="1" set="method" line="196"><f a="value">
	<c path="Int"/>
	<e path="Void"/>
</f></setMaxLen>
		<setIsMulti public="1" set="method" line="191"><f a="value">
	<e path="Bool"/>
	<e path="Void"/>
</f></setIsMulti>
		<setIsMust public="1" set="method" line="186"><f a="value">
	<e path="Bool"/>
	<e path="Void"/>
</f></setIsMust>
		<getValues public="1" set="method" line="181"><f a=""><c path="Array"><d/></c></f></getValues>
		<getSelectedItems public="1" set="method" line="169"><f a=""><c path="Array"><t path="cn.royan.hl.uis.normal.exts.ItemType"/></c></f></getSelectedItems>
		<getItems public="1" set="method" line="164"><f a=""><c path="Array"><t path="cn.royan.hl.uis.normal.exts.ItemType"/></c></f></getItems>
		<getIndexByItem public="1" set="method" line="159"><f a="item">
	<t path="cn.royan.hl.uis.normal.exts.ItemType"/>
	<c path="Int"/>
</f></getIndexByItem>
		<getItemAt public="1" set="method" line="154"><f a="index">
	<c path="Int"/>
	<t path="cn.royan.hl.uis.normal.exts.ItemType"/>
</f></getItemAt>
		<removeAllItems public="1" set="method" line="148"><f a=""><e path="Void"/></f></removeAllItems>
		<removeItemAt public="1" set="method" line="136"><f a="index">
	<c path="Int"/>
	<e path="Void"/>
</f></removeItemAt>
		<removeItem public="1" set="method" line="128"><f a="item">
	<t path="cn.royan.hl.uis.normal.exts.ItemType"/>
	<e path="Void"/>
</f></removeItem>
		<addItemAt public="1" set="method" line="112"><f a="item:index">
	<t path="cn.royan.hl.uis.normal.exts.ItemType"/>
	<c path="Int"/>
	<e path="Void"/>
</f></addItemAt>
		<addItem public="1" set="method" line="100"><f a="item">
	<t path="cn.royan.hl.uis.normal.exts.ItemType"/>
	<e path="Void"/>
</f></addItem>
		<setSize public="1" set="method" line="86" override="1"><f a="w:h">
	<c path="Float"/>
	<c path="Float"/>
	<e path="Void"/>
</f></setSize>
		<getShowLine public="1" set="method" line="81"><f a=""><c path="Int"/></f></getShowLine>
		<setShowLine public="1" set="method" line="76"><f a="value">
	<c path="Int"/>
	<e path="Void"/>
</f></setShowLine>
		<getTitle public="1" set="method" line="71"><f a=""><c path="cn.royan.hl.uis.normal.bases.UiNLabelButton"/></f></getTitle>
		<groupDoingHandler set="method" line="64"><f a="evt">
	<c path="cn.royan.hl.events.DatasEvent"/>
	<e path="Void"/>
</f></groupDoingHandler>
		<titleClickHandler set="method" line="52"><f a="obj">
	<c path="cn.royan.hl.uis.normal.bases.UiNLabelButton"/>
	<e path="Void"/>
</f></titleClickHandler>
		<line><c path="Int"/></line>
		<title><c path="cn.royan.hl.uis.normal.bases.UiNLabelButton"/></title>
		<items><c path="Array"><t path="cn.royan.hl.uis.normal.exts.ItemType"/></c></items>
		<listView><c path="cn.royan.hl.uis.normal.bases.UiNScrollPane"/></listView>
		<group><c path="cn.royan.hl.uis.normal.bases.UiNContainerGroup"/></group>
		<new public="1" set="method" line="29"><f a=""><e path="Void"/></f></new>
	</class>
	<class path="cn.royan.hl.uis.normal.exts.UiNExtImageLoader" params="" file="cn/royan/hl/uis/normal/exts/UiNExtImageLoader.hx">
		<extends path="cn.royan.hl.uis.normal.bases.UiNContainerAlign"/>
		<load public="1" set="method" line="39"><f a="url">
	<c path="String"/>
	<e path="Void"/>
</f></load>
		<doneHandler set="method" line="34"><f a="data">
	<c path="flash.display.BitmapData"/>
	<e path="Void"/>
</f></doneHandler>
		<image><c path="cn.royan.hl.uis.normal.InteractiveUiN"/></image>
		<takeService><c path="cn.royan.hl.services.TakeService"/></takeService>
		<new public="1" set="method" line="19"><f a="?url">
	<c path="String"/>
	<e path="Void"/>
</f></new>
		<haxe_doc>* ...
 * @author RoYan</haxe_doc>
	</class>
	<class path="cn.royan.hl.uis.sparrow.Sparrow" params="" file="cn/royan/hl/uis/sparrow/Sparrow.hx">
		<implements path="cn.royan.hl.interfaces.IDisposeBase"/>
		<fromSparrow public="1" set="method" line="37" static="1"><f a="texture:?region:?frame">
	<c path="cn.royan.hl.uis.sparrow.Sparrow"/>
	<c path="flash.geom.Rectangle"/>
	<c path="flash.geom.Rectangle"/>
	<c path="cn.royan.hl.uis.sparrow.Sparrow"/>
</f></fromSparrow>
		<fromBitmap public="1" set="method" line="44" static="1"><f a="bitmap">
	<c path="flash.display.Bitmap"/>
	<c path="cn.royan.hl.uis.sparrow.Sparrow"/>
</f></fromBitmap>
		<fromBitmapData public="1" set="method" line="49" static="1"><f a="bitmapdata">
	<c path="flash.display.BitmapData"/>
	<c path="cn.royan.hl.uis.sparrow.Sparrow"/>
</f></fromBitmapData>
		<frame public="1"><c path="flash.geom.Rectangle"/></frame>
		<regin public="1"><c path="flash.geom.Rectangle"/></regin>
		<getBitmapdata set="method" line="29"><f a=""><c path="flash.display.BitmapData"/></f></getBitmapdata>
		<bitmapdata public="1" get="getBitmapdata" set="null"><c path="flash.display.BitmapData"/></bitmapdata>
		<dispose public="1" set="method" line="23"><f a=""><e path="Void"/></f></dispose>
		<new public="1" set="method" line="15"><f a="source:?rect">
	<c path="flash.display.BitmapData"/>
	<c path="flash.geom.Rectangle"/>
	<e path="Void"/>
</f></new>
		<haxe_doc>* ...
 * @author RoYan</haxe_doc>
	</class>
	<class path="cn.royan.hl.uis.sparrow.SparrowAtlas" params="" file="cn/royan/hl/uis/sparrow/SparrowAtlas.hx">
		<implements path="cn.royan.hl.interfaces.IDisposeBase"/>
		<dispose public="1" set="method" line="128"><f a=""><e path="Void"/></f></dispose>
		<getTexture set="method" line="123"><f a=""><c path="cn.royan.hl.uis.sparrow.Sparrow"/></f></getTexture>
		<sparrow public="1" get="getTexture" set="null">
			<c path="cn.royan.hl.uis.sparrow.Sparrow"/>
			<haxe_doc>The base texture that makes up the atlas.</haxe_doc>
		</sparrow>
		<removeRegion public="1" set="method" line="115">
			<f a="name">
				<c path="String"/>
				<e path="Void"/>
			</f>
			<haxe_doc>Removes a region with a certain name.</haxe_doc>
		</removeRegion>
		<addRegion public="1" set="method" line="108">
			<f a="name:region:?frame">
				<c path="String"/>
				<c path="flash.geom.Rectangle"/>
				<c path="flash.geom.Rectangle"/>
				<e path="Void"/>
			</f>
			<haxe_doc>Adds a named region for a subtexture (described by rectangle with coordinates in 
	 *  pixels) with an optional frame.</haxe_doc>
		</addRegion>
		<getFrame public="1" set="method" line="101">
			<f a="name">
				<c path="String"/>
				<c path="flash.geom.Rectangle"/>
			</f>
			<haxe_doc><![CDATA[Returns the frame rectangle of a specific region, or <code>null</code> if that region 
	 *  has no frame.]]></haxe_doc>
		</getFrame>
		<getRegion public="1" set="method" line="94">
			<f a="name">
				<c path="String"/>
				<c path="flash.geom.Rectangle"/>
			</f>
			<haxe_doc>Returns the region rectangle associated with a specific name.</haxe_doc>
		</getRegion>
		<getNames public="1" set="method" line="81">
			<f a="?prefix:?result">
				<c path="String"/>
				<c path="Array"><c path="String"/></c>
				<c path="Array"><c path="String"/></c>
			</f>
			<haxe_doc>Returns all texture names that start with a certain string, sorted alphabetically.</haxe_doc>
		</getNames>
		<getSparrows public="1" set="method" line="69">
			<f a="?prefix:?result">
				<c path="String"/>
				<c path="Array"><c path="cn.royan.hl.uis.sparrow.Sparrow"/></c>
				<c path="Array"><c path="cn.royan.hl.uis.sparrow.Sparrow"/></c>
			</f>
			<haxe_doc>Returns all textures that start with a certain string, sorted alphabetically
	 *  (especially useful for "MovieClip").</haxe_doc>
		</getSparrows>
		<getSparrow public="1" set="method" line="59">
			<f a="name">
				<c path="String"/>
				<c path="cn.royan.hl.uis.sparrow.Sparrow"/>
			</f>
			<haxe_doc><![CDATA[Retrieves a subtexture by name. Returns <code>null</code> if it is not found.]]></haxe_doc>
		</getSparrow>
		<parseAtlasXml set="method" line="34"><f a="xml">
	<c path="Xml"/>
	<e path="Void"/>
</f></parseAtlasXml>
		<sNames><c path="Array"><c path="String"/></c></sNames>
		<mSparrowFrames><t path="cn.royan.hl.bases.Dictionary"/></mSparrowFrames>
		<mSparrowRegions><t path="cn.royan.hl.bases.Dictionary"/></mSparrowRegions>
		<mSparrowAtlas><c path="cn.royan.hl.uis.sparrow.Sparrow"/></mSparrowAtlas>
		<new public="1" set="method" line="22"><f a="texture:xml">
	<c path="cn.royan.hl.uis.sparrow.Sparrow"/>
	<c path="Xml"/>
	<e path="Void"/>
</f></new>
		<haxe_doc>* ...
 * @author RoYan</haxe_doc>
	</class>
	<class path="cn.royan.hl.uis.sparrow.SparrowManager" params="" file="cn/royan/hl/uis/sparrow/SparrowManager.hx">
		<gameBitmaps line="15" static="1"><t path="cn.royan.hl.bases.Dictionary"/></gameBitmaps>
		<gameXMLs line="16" static="1"><t path="cn.royan.hl.bases.Dictionary"/></gameXMLs>
		<gameSparrows line="17" static="1"><t path="cn.royan.hl.bases.Dictionary"/></gameSparrows>
		<gameSparrowAtlases line="18" static="1"><t path="cn.royan.hl.bases.Dictionary"/></gameSparrowAtlases>
		<setAtlas public="1" get="inline" set="null" line="20" static="1"><f a="type:bitmap:xml">
	<c path="String"/>
	<c path="flash.display.Bitmap"/>
	<c path="Xml"/>
	<e path="Void"/>
</f></setAtlas>
		<getAtlas public="1" get="inline" set="null" line="27" static="1"><f a="type">
	<c path="String"/>
	<c path="cn.royan.hl.uis.sparrow.SparrowAtlas"/>
</f></getAtlas>
		<haxe_doc>* ...
 * @author RoYan</haxe_doc>
	</class>
	<class path="starling.events.EventDispatcher" params="" file="starling/events/EventDispatcher.hx" extern="1">
		<hasEventListener public="1" set="method"><f a="type">
	<c path="String"/>
	<e path="Bool"/>
</f></hasEventListener>
		<dispatchEventWith public="1" set="method"><f a="type:?bubbles:?data">
	<c path="String"/>
	<e path="Bool"/>
	<d/>
	<e path="Void"/>
</f></dispatchEventWith>
		<dispatchEvent public="1" set="method"><f a="event">
	<c path="starling.events.Event"/>
	<e path="Void"/>
</f></dispatchEvent>
		<removeEventListeners public="1" set="method"><f a="?type">
	<c path="String"/>
	<e path="Void"/>
</f></removeEventListeners>
		<removeEventListener public="1" set="method"><f a="type:listener">
	<c path="String"/>
	<d/>
	<e path="Void"/>
</f></removeEventListener>
		<addEventListener public="1" set="method"><f a="type:listener">
	<c path="String"/>
	<d/>
	<e path="Void"/>
</f></addEventListener>
		<new public="1" set="method"><f a=""><e path="Void"/></f></new>
	</class>
	<class path="starling.display.DisplayObject" params="" file="starling/display/DisplayObject.hx" extern="1">
		<extends path="starling.events.EventDispatcher"/>
		<stage public="1" set="null"><c path="starling.display.Stage"/></stage>
		<base public="1" set="null"><c path="starling.display.DisplayObject"/></base>
		<parent public="1" set="null"><c path="starling.display.DisplayObjectContainer"/></parent>
		<name public="1"><c path="String"/></name>
		<blendMode public="1"><c path="String"/></blendMode>
		<touchable public="1"><e path="Bool"/></touchable>
		<visible public="1"><e path="Bool"/></visible>
		<alpha public="1"><c path="Float"/></alpha>
		<rotation public="1"><c path="Float"/></rotation>
		<skewY public="1"><c path="Float"/></skewY>
		<skewX public="1"><c path="Float"/></skewX>
		<scaleY public="1"><c path="Float"/></scaleY>
		<scaleX public="1"><c path="Float"/></scaleX>
		<pivotY public="1"><c path="Float"/></pivotY>
		<pivotX public="1"><c path="Float"/></pivotX>
		<y public="1"><c path="Float"/></y>
		<x public="1"><c path="Float"/></x>
		<root public="1" set="null"><c path="starling.display.DisplayObject"/></root>
		<height public="1"><c path="Float"/></height>
		<width public="1"><c path="Float"/></width>
		<bounds public="1" set="null"><c path="flash.geom.Rectangle"/></bounds>
		<render public="1" set="method"><f a="support:parentAlpha">
	<c path="starling.core.RenderSupport"/>
	<c path="Float"/>
	<e path="Void"/>
</f></render>
		<globalToLocal public="1" set="method"><f a="globalPoint:?resultPoint">
	<c path="flash.geom.Point"/>
	<c path="flash.geom.Point"/>
	<c path="flash.geom.Point"/>
</f></globalToLocal>
		<localToGlobal public="1" set="method"><f a="localPoint:?resultPoint">
	<c path="flash.geom.Point"/>
	<c path="flash.geom.Point"/>
	<c path="flash.geom.Point"/>
</f></localToGlobal>
		<hitTest public="1" set="method"><f a="localPoint:?forTouch">
	<c path="flash.geom.Point"/>
	<e path="Bool"/>
	<c path="starling.display.DisplayObject"/>
</f></hitTest>
		<getBounds public="1" set="method"><f a="targetSpace:?resultRect">
	<c path="starling.display.DisplayObject"/>
	<c path="flash.geom.Rectangle"/>
	<c path="flash.geom.Rectangle"/>
</f></getBounds>
		<transformationMatrix public="1"><c path="flash.geom.Matrix"/></transformationMatrix>
		<getTransformationMatrix public="1" set="method"><f a="targetSpace:?resultMatrix">
	<c path="starling.display.DisplayObject"/>
	<c path="flash.geom.Matrix"/>
	<c path="flash.geom.Matrix"/>
</f></getTransformationMatrix>
		<removeFromParent public="1" set="method"><f a="?dispose">
	<e path="Bool"/>
	<e path="Void"/>
</f></removeFromParent>
		<dispose public="1" set="method"><f a=""><e path="Void"/></f></dispose>
	</class>
	<class path="starling.display.DisplayObjectContainer" params="" file="starling/display/DisplayObjectContainer.hx" extern="1">
		<extends path="starling.display.DisplayObject"/>
		<numChildren public="1" set="null"><c path="Int"/></numChildren>
		<broadcastEventWith public="1" set="method"><f a="type:?data">
	<c path="String"/>
	<d/>
	<e path="Void"/>
</f></broadcastEventWith>
		<broadcastEvent public="1" set="method"><f a="event">
	<c path="starling.events.Event"/>
	<e path="Void"/>
</f></broadcastEvent>
		<contains public="1" set="method"><f a="child">
	<c path="starling.display.DisplayObject"/>
	<e path="Bool"/>
</f></contains>
		<sortChildren public="1" set="method"><f a="compareFunction">
	<d/>
	<e path="Void"/>
</f></sortChildren>
		<swapChildrenAt public="1" set="method"><f a="index1:index2">
	<c path="Int"/>
	<c path="Int"/>
	<e path="Void"/>
</f></swapChildrenAt>
		<swapChildren public="1" set="method"><f a="child1:child2">
	<c path="starling.display.DisplayObject"/>
	<c path="starling.display.DisplayObject"/>
	<e path="Void"/>
</f></swapChildren>
		<setChildIndex public="1" set="method"><f a="child:index">
	<c path="starling.display.DisplayObject"/>
	<c path="Int"/>
	<e path="Void"/>
</f></setChildIndex>
		<getChildIndex public="1" set="method"><f a="child">
	<c path="starling.display.DisplayObject"/>
	<c path="Int"/>
</f></getChildIndex>
		<getChildByName public="1" set="method"><f a="name">
	<c path="String"/>
	<c path="starling.display.DisplayObject"/>
</f></getChildByName>
		<getChildAt public="1" set="method"><f a="index">
	<c path="Int"/>
	<c path="starling.display.DisplayObject"/>
</f></getChildAt>
		<removeChildren public="1" set="method"><f a="?beginIndex:?endIndex:?dispose">
	<c path="Int"/>
	<c path="Int"/>
	<e path="Bool"/>
	<e path="Void"/>
</f></removeChildren>
		<removeChildAt public="1" set="method"><f a="index:?dispose">
	<c path="Int"/>
	<e path="Bool"/>
	<c path="starling.display.DisplayObject"/>
</f></removeChildAt>
		<removeChild public="1" set="method"><f a="child:?dispose">
	<c path="starling.display.DisplayObject"/>
	<e path="Bool"/>
	<c path="starling.display.DisplayObject"/>
</f></removeChild>
		<addChildAt public="1" set="method"><f a="child:index">
	<c path="starling.display.DisplayObject"/>
	<c path="Int"/>
	<c path="starling.display.DisplayObject"/>
</f></addChildAt>
		<addChild public="1" set="method"><f a="child">
	<c path="starling.display.DisplayObject"/>
	<c path="starling.display.DisplayObject"/>
</f></addChild>
	</class>
	<class path="starling.display.Sprite" params="" file="starling/display/Sprite.hx" extern="1">
		<extends path="starling.display.DisplayObjectContainer"/>
		<isFlattened public="1" set="null"><e path="Bool"/></isFlattened>
		<unflatten public="1" set="method"><f a=""><e path="Void"/></f></unflatten>
		<flatten public="1" set="method"><f a=""><e path="Void"/></f></flatten>
		<new public="1" set="method"><f a=""><e path="Void"/></f></new>
	</class>
	<class path="cn.royan.hl.uis.starling.InteractiveUiS" params="" file="cn/royan/hl/uis/starling/InteractiveUiS.hx">
		<extends path="starling.display.Sprite"/>
		<implements path="cn.royan.hl.interfaces.uis.IUiBase"/>
		<removeFromStageHandler set="method" line="399"><f a="evt">
	<c path="starling.events.Event"/>
	<e path="Void"/>
</f></removeFromStageHandler>
		<addToStageHandler set="method" line="384"><f a="?evt">
	<c path="starling.events.Event"/>
	<e path="Void"/>
</f></addToStageHandler>
		<mouseClickHandler set="method" line="378"><f a="touch">
	<c path="starling.events.Touch"/>
	<e path="Void"/>
</f></mouseClickHandler>
		<mouseMoveHandler set="method" line="372"><f a="touch">
	<c path="starling.events.Touch"/>
	<e path="Void"/>
</f></mouseMoveHandler>
		<mouseUpHandler set="method" line="364"><f a="touch">
	<c path="starling.events.Touch"/>
	<e path="Void"/>
</f></mouseUpHandler>
		<mouseDownHandler set="method" line="356"><f a="touch">
	<c path="starling.events.Touch"/>
	<e path="Void"/>
</f></mouseDownHandler>
		<mouseOutHandler set="method" line="346"><f a=""><e path="Void"/></f></mouseOutHandler>
		<mouseOverHandler set="method" line="335"><f a="touch">
	<c path="starling.events.Touch"/>
	<e path="Void"/>
</f></mouseOverHandler>
		<mouseTouchHandler set="method" line="308"><f a="evt">
	<c path="starling.events.TouchEvent"/>
	<e path="Void"/>
</f></mouseTouchHandler>
		<dispose public="1" set="method" line="300" override="1"><f a=""><e path="Void"/></f></dispose>
		<removeAllChildren public="1" set="method" line="295"><f a=""><e path="Void"/></f></removeAllChildren>
		<getInclude public="1" set="method" line="290"><f a=""><c path="Array"><c path="String"/></c></f></getInclude>
		<setInclude public="1" set="method" line="285"><f a="args">
	<c path="Array"><c path="String"/></c>
	<e path="Void"/>
</f></setInclude>
		<getExclude public="1" set="method" line="280"><f a=""><c path="Array"><c path="String"/></c></f></getExclude>
		<setExclude public="1" set="method" line="275"><f a="args">
	<c path="Array"><c path="String"/></c>
	<e path="Void"/>
</f></setExclude>
		<setMouseRender public="1" set="method" line="268"><f a="value">
	<e path="Bool"/>
	<e path="Void"/>
</f></setMouseRender>
		<getEnabled public="1" set="method" line="263"><f a=""><e path="Bool"/></f></getEnabled>
		<setEnabled public="1" set="method" line="254"><f a="value">
	<e path="Bool"/>
	<e path="Void"/>
</f></setEnabled>
		<getDispatcher public="1" set="method" line="249"><f a=""><c path="flash.events.EventDispatcher"/></f></getDispatcher>
		<setStyle public="1" set="method" line="244"><f a="value">
	<c path="cn.royan.hl.uis.style.Style"/>
	<e path="Void"/>
</f></setStyle>
		<getScale public="1" set="method" line="239"><f a=""><c path="Float"/></f></getScale>
		<setScale public="1" set="method" line="229"><f a="value">
	<c path="Float"/>
	<e path="Void"/>
</f></setScale>
		<getTexture public="1" set="method" line="224"><f a=""><d/></f></getTexture>
		<setTexture public="1" set="method" line="206"><f a="texture:?frames">
	<d/>
	<c path="Int"/>
	<e path="Void"/>
</f></setTexture>
		<getRange public="1" set="method" line="201"><f a=""><t path="cn.royan.hl.geom.Range"/></f></getRange>
		<setRange public="1" set="method" line="195"><f a="value">
	<t path="cn.royan.hl.geom.Range"/>
	<e path="Void"/>
</f></setRange>
		<setPosition public="1" set="method" line="185"><f a="cx:cy">
	<c path="Float"/>
	<c path="Float"/>
	<e path="Void"/>
</f></setPosition>
		<setSize public="1" set="method" line="173"><f a="w:h">
	<c path="Float"/>
	<c path="Float"/>
	<e path="Void"/>
</f></setSize>
		<setCallbacks public="1" set="method" line="168"><f a="value">
	<d/>
	<e path="Void"/>
</f></setCallbacks>
		<setBorder public="1" set="method" line="159"><f a="thick:color:alpha:?rx:?ry">
	<c path="Int"/>
	<c path="Int"/>
	<c path="Float"/>
	<c path="Int"/>
	<c path="Int"/>
	<e path="Void"/>
</f></setBorder>
		<getAlphas public="1" set="method" line="154"><f a=""><c path="Array"><d/></c></f></getAlphas>
		<getColors public="1" set="method" line="149"><f a=""><c path="Array"><d/></c></f></getColors>
		<setColorsAndAplhas public="1" set="method" line="123"><f a="color:alpha">
	<c path="Array"><d/></c>
	<c path="Array"><d/></c>
	<e path="Void"/>
</f></setColorsAndAplhas>
		<getDefaultTexture public="1" set="method" line="117"><f a=""><d/></f></getDefaultTexture>
		<draw public="1" set="method" line="103"><f a=""><e path="Void"/></f></draw>
		<buttonMode public="1"><e path="Bool"/></buttonMode>
		<graphics public="1"><c path="starling.display.Image"/></graphics>
		<evtListenerDirectory><c path="Array"><d/></c></evtListenerDirectory>
		<evtListenerType><c path="Array"><c path="String"/></c></evtListenerType>
		<includes><c path="Array"><c path="String"/></c></includes>
		<excludes><c path="Array"><c path="String"/></c></excludes>
		<mouseEnabled><e path="Bool"/></mouseEnabled>
		<positionY><c path="Float"/></positionY>
		<positionX><c path="Float"/></positionX>
		<containerHeight><c path="Float"/></containerHeight>
		<containerWidth><c path="Float"/></containerWidth>
		<borderRy><c path="Int"/></borderRy>
		<borderRx><c path="Int"/></borderRx>
		<borderAlpha><c path="Float"/></borderAlpha>
		<borderColor><c path="Int"/></borderColor>
		<borderThick><c path="Int"/></borderThick>
		<isOnStage><e path="Bool"/></isOnStage>
		<selected><e path="Bool"/></selected>
		<status><c path="Int"/></status>
		<isMouseRender><e path="Bool"/></isMouseRender>
		<callbacks><d/></callbacks>
		<bgTexture><c path="starling.textures.Texture"/></bgTexture>
		<defaultTexture><c path="starling.textures.Texture"/></defaultTexture>
		<bgAlphas><c path="Array"><d/></c></bgAlphas>
		<bgColors><c path="Array"><d/></c></bgColors>
		<scale><c path="Float"/></scale>
		<originalDPI><c path="Int"/></originalDPI>
		<new public="1" set="method" line="70"><f a="?texture">
	<c path="starling.textures.Texture"/>
	<e path="Void"/>
</f></new>
		<haxe_doc>* ...
 * @author RoYan</haxe_doc>
	</class>
	<class path="cn.royan.hl.uis.starling.UninteractiveUiS" params="" file="cn/royan/hl/uis/starling/UninteractiveUiS.hx">
		<extends path="starling.display.Sprite"/>
		<implements path="cn.royan.hl.interfaces.uis.IUiBase"/>
		<dispose public="1" set="method" line="256" override="1"><f a=""><e path="Void"/></f></dispose>
		<getInclude public="1" set="method" line="251"><f a=""><c path="Array"><c path="String"/></c></f></getInclude>
		<setInclude public="1" set="method" line="246"><f a="args">
	<c path="Array"><c path="String"/></c>
	<e path="Void"/>
</f></setInclude>
		<getExclude public="1" set="method" line="241"><f a=""><c path="Array"><c path="String"/></c></f></getExclude>
		<setExclude public="1" set="method" line="236"><f a="args">
	<c path="Array"><c path="String"/></c>
	<e path="Void"/>
</f></setExclude>
		<getDispatcher public="1" set="method" line="231"><f a=""><c path="flash.events.EventDispatcher"/></f></getDispatcher>
		<setStyle public="1" set="method" line="226"><f a="value">
	<c path="cn.royan.hl.uis.style.Style"/>
	<e path="Void"/>
</f></setStyle>
		<getScale public="1" set="method" line="221"><f a=""><c path="Float"/></f></getScale>
		<setScale public="1" set="method" line="211"><f a="value">
	<c path="Float"/>
	<e path="Void"/>
</f></setScale>
		<getTexture public="1" set="method" line="206"><f a=""><d/></f></getTexture>
		<setTexture public="1" set="method" line="187"><f a="texture:?frames">
	<d/>
	<c path="Int"/>
	<e path="Void"/>
</f></setTexture>
		<getRange public="1" set="method" line="182"><f a=""><t path="cn.royan.hl.geom.Range"/></f></getRange>
		<setRange public="1" set="method" line="176"><f a="value">
	<t path="cn.royan.hl.geom.Range"/>
	<e path="Void"/>
</f></setRange>
		<setPosition public="1" set="method" line="166"><f a="cx:cy">
	<c path="Float"/>
	<c path="Float"/>
	<e path="Void"/>
</f></setPosition>
		<setSize public="1" set="method" line="154"><f a="w:h">
	<c path="Float"/>
	<c path="Float"/>
	<e path="Void"/>
</f></setSize>
		<setCallbacks public="1" set="method" line="149"><f a="value">
	<d/>
	<e path="Void"/>
</f></setCallbacks>
		<setBorder public="1" set="method" line="140"><f a="thick:color:alpha:?rx:?ry">
	<c path="Int"/>
	<c path="Int"/>
	<c path="Float"/>
	<c path="Int"/>
	<c path="Int"/>
	<e path="Void"/>
</f></setBorder>
		<getAlphas public="1" set="method" line="135"><f a=""><c path="Array"><d/></c></f></getAlphas>
		<getColors public="1" set="method" line="130"><f a=""><c path="Array"><d/></c></f></getColors>
		<setColorsAndAplhas public="1" set="method" line="104"><f a="color:alpha">
	<c path="Array"><d/></c>
	<c path="Array"><d/></c>
	<e path="Void"/>
</f></setColorsAndAplhas>
		<getDefaultTexture public="1" set="method" line="98"><f a=""><d/></f></getDefaultTexture>
		<draw public="1" set="method" line="85"><f a=""><e path="Void"/></f></draw>
		<isInit><e path="Bool"/></isInit>
		<graphics public="1"><c path="starling.display.Image"/></graphics>
		<includes><c path="Array"><c path="String"/></c></includes>
		<excludes><c path="Array"><c path="String"/></c></excludes>
		<positionY><c path="Float"/></positionY>
		<positionX><c path="Float"/></positionX>
		<containerHeight><c path="Float"/></containerHeight>
		<containerWidth><c path="Float"/></containerWidth>
		<borderRy><c path="Int"/></borderRy>
		<borderRx><c path="Int"/></borderRx>
		<borderAlpha><c path="Float"/></borderAlpha>
		<borderColor><c path="Int"/></borderColor>
		<borderThick><c path="Int"/></borderThick>
		<bgTexture><c path="starling.textures.Texture"/></bgTexture>
		<defaultTexture><c path="starling.textures.Texture"/></defaultTexture>
		<bgAlphas><c path="Array"><d/></c></bgAlphas>
		<bgColors><c path="Array"><d/></c></bgColors>
		<scale><c path="Float"/></scale>
		<originalDPI><c path="Int"/></originalDPI>
		<new public="1" set="method" line="53"><f a="?texture">
	<c path="starling.textures.Texture"/>
	<e path="Void"/>
</f></new>
		<haxe_doc>* ...
 * @author RoYan</haxe_doc>
	</class>
	<class path="cn.royan.hl.uis.starling.bases.UiSBmpdButton" params="" file="cn/royan/hl/uis/starling/bases/UiSBmpdButton.hx">
		<extends path="cn.royan.hl.uis.starling.InteractiveUiS"/>
		<implements path="cn.royan.hl.interfaces.uis.IUiItemGroupBase"/>
		<dispose public="1" set="method" line="125" override="1"><f a=""><e path="Void"/></f></dispose>
		<setTexture public="1" set="method" line="123" override="1"><f a="value:?frames">
	<c path="starling.textures.Texture"/>
	<c path="Int"/>
	<e path="Void"/>
</f></setTexture>
		<clone public="1" set="method" line="118"><f a=""><c path="cn.royan.hl.uis.starling.bases.UiSBmpdButton"/></f></clone>
		<getSelected public="1" set="method" line="113"><f a=""><e path="Bool"/></f></getSelected>
		<setSelected public="1" set="method" line="106"><f a="value">
	<e path="Bool"/>
	<e path="Void"/>
</f></setSelected>
		<setColorsAndAplhas public="1" set="method" line="76" override="1"><f a="color:alpha">
	<c path="Array"><d/></c>
	<c path="Array"><d/></c>
	<e path="Void"/>
</f></setColorsAndAplhas>
		<draw public="1" set="method" line="67" override="1"><f a=""><e path="Void"/></f></draw>
		<setInGroup public="1" set="method" line="61"><f a="value">
	<e path="Bool"/>
	<e path="Void"/>
</f></setInGroup>
		<freshRect><c path="flash.geom.Rectangle"/></freshRect>
		<isInGroup><e path="Bool"/></isInGroup>
		<currentStatus><c path="starling.display.Image"/></currentStatus>
		<bgTextures><c path="Array"><c path="starling.textures.Texture"/></c></bgTextures>
		<new public="1" set="method" line="29"><f a="texture">
	<c path="Array"><c path="starling.textures.Texture"/></c>
	<e path="Void"/>
</f></new>
		<haxe_doc>* ...
 * @author RoYan</haxe_doc>
	</class>
	<class path="cn.royan.hl.uis.starling.bases.UiSBmpdMovieClip" params="" file="cn/royan/hl/uis/starling/bases/UiSBmpdMovieClip.hx">
		<extends path="cn.royan.hl.uis.starling.InteractiveUiS"/>
		<implements path="cn.royan.hl.interfaces.uis.IUiItemPlayBase"/>
		<dispose public="1" set="method" line="168" override="1"><f a=""><e path="Void"/></f></dispose>
		<draw public="1" set="method" line="166" override="1"><f a=""><e path="Void"/></f></draw>
		<timerHandler set="method" line="133"><f a=""><e path="Void"/></f></timerHandler>
		<removeFromStageHandler set="method" line="126" override="1"><f a="evt">
	<c path="starling.events.Event"/>
	<e path="Void"/>
</f></removeFromStageHandler>
		<addToStageHandler set="method" line="119" override="1"><f a="?evt">
	<c path="starling.events.Event"/>
	<e path="Void"/>
</f></addToStageHandler>
		<stop public="1" set="method" line="114"><f a=""><e path="Void"/></f></stop>
		<play public="1" set="method" line="109"><f a=""><e path="Void"/></f></play>
		<goFromTo public="1" set="method" line="91"><f a="from:to">
	<c path="Int"/>
	<c path="Int"/>
	<e path="Void"/>
</f></goFromTo>
		<jumpTo public="1" set="method" line="77"><f a="frame">
	<c path="Int"/>
	<e path="Void"/>
</f></jumpTo>
		<goTo public="1" set="method" line="71"><f a="frame">
	<c path="Int"/>
	<e path="Void"/>
</f></goTo>
		<getOut public="1" set="method" line="66"><f a=""><e path="Void"/></f></getOut>
		<getIn public="1" set="method" line="61"><f a=""><e path="Void"/></f></getIn>
		<clone public="1" set="method" line="56"><f a=""><c path="cn.royan.hl.uis.starling.bases.UiSBmpdMovieClip"/></f></clone>
		<currentFrame><c path="starling.display.Image"/></currentFrame>
		<autoPlay><e path="Bool"/></autoPlay>
		<loop><e path="Bool"/></loop>
		<sequence><e path="Bool"/></sequence>
		<frameRate><c path="Int"/></frameRate>
		<toFrame><c path="Int"/></toFrame>
		<current><c path="Int"/></current>
		<timer><c path="cn.royan.hl.bases.TimerBase"/></timer>
		<bgTextures><c path="Array"><c path="starling.textures.Texture"/></c></bgTextures>
		<new public="1" set="method" line="31"><f a="texture:?rate:?auto">
	<c path="Array"><c path="starling.textures.Texture"/></c>
	<c path="Int"/>
	<e path="Bool"/>
	<e path="Void"/>
</f></new>
		<haxe_doc>* ...
 * @author RoYan</haxe_doc>
	</class>
	<class path="cn.royan.hl.uis.starling.bases.UiSContainer" params="" file="cn/royan/hl/uis/starling/bases/UiSContainer.hx">
		<extends path="cn.royan.hl.uis.starling.InteractiveUiS"/>
		<implements path="cn.royan.hl.interfaces.uis.IUiContainerBase"/>
		<setHide public="1" set="method" line="208"><f a="effect">
	<f a=":">
		<d/>
		<d/>
		<e path="Void"/>
	</f>
	<e path="Void"/>
</f></setHide>
		<setShow public="1" set="method" line="203"><f a="effect">
	<f a="">
		<d/>
		<e path="Void"/>
	</f>
	<e path="Void"/>
</f></setShow>
		<getState public="1" set="method" line="198"><f a=""><c path="String"/></f></getState>
		<setState public="1" set="method" line="169"><f a="value">
	<c path="String"/>
	<e path="Void"/>
</f></setState>
		<getItems public="1" set="method" line="164"><f a=""><c path="Array"><c path="cn.royan.hl.interfaces.uis.IUiBase"/></c></f></getItems>
		<getIndexByItem public="1" set="method" line="156"><f a="item">
	<c path="cn.royan.hl.interfaces.uis.IUiBase"/>
	<c path="Int"/>
</f></getIndexByItem>
		<getItemAt public="1" set="method" line="151"><f a="index">
	<c path="Int"/>
	<c path="cn.royan.hl.interfaces.uis.IUiBase"/>
</f></getItemAt>
		<removeAllItems public="1" set="method" line="133"><f a=""><e path="Void"/></f></removeAllItems>
		<removeItemAt public="1" set="method" line="120"><f a="index">
	<c path="Int"/>
	<c path="cn.royan.hl.interfaces.uis.IUiBase"/>
</f></removeItemAt>
		<removeItem public="1" set="method" line="101"><f a="item">
	<c path="cn.royan.hl.interfaces.uis.IUiBase"/>
	<c path="cn.royan.hl.interfaces.uis.IUiBase"/>
</f></removeItem>
		<addItemAt public="1" set="method" line="75"><f a="item:index">
	<c path="cn.royan.hl.interfaces.uis.IUiBase"/>
	<c path="Int"/>
	<c path="cn.royan.hl.interfaces.uis.IUiBase"/>
</f></addItemAt>
		<addItem public="1" set="method" line="54"><f a="item">
	<c path="cn.royan.hl.interfaces.uis.IUiBase"/>
	<c path="cn.royan.hl.interfaces.uis.IUiBase"/>
</f></addItem>
		<setScale public="1" set="method" line="45" override="1"><f a="value">
	<c path="Float"/>
	<e path="Void"/>
</f></setScale>
		<addToStageHandler set="method" line="37" override="1"><f a="?evt">
	<c path="starling.events.Event"/>
	<e path="Void"/>
</f></addToStageHandler>
		<hideProp><f a=":">
	<d/>
	<d/>
	<e path="Void"/>
</f></hideProp>
		<showProp><f a="">
	<d/>
	<e path="Void"/>
</f></showProp>
		<items><c path="Array"><c path="cn.royan.hl.interfaces.uis.IUiBase"/></c></items>
		<current><c path="String"/></current>
		<states><c path="Array"><c path="String"/></c></states>
		<new public="1" set="method" line="28"><f a="?texture">
	<c path="starling.textures.Texture"/>
	<e path="Void"/>
</f></new>
		<haxe_doc>* ...
 * @author RoYan</haxe_doc>
	</class>
	<typedef path="cn.royan.hl.uis.starling.bases._UiSContainerAlign.ContainerGap" params="" file="cn/royan/hl/uis/starling/bases/UiSContainerAlign.hx" private="1" module="cn.royan.hl.uis.starling.bases.UiSContainerAlign">
		<a>
			<y><c path="Int"/></y>
			<x><c path="Int"/></x>
		</a>
		<haxe_doc>* ...
 * @author RoYan</haxe_doc>
	</typedef>
	<typedef path="cn.royan.hl.uis.starling.bases._UiSContainerAlign.ContainerMargin" params="" file="cn/royan/hl/uis/starling/bases/UiSContainerAlign.hx" private="1" module="cn.royan.hl.uis.starling.bases.UiSContainerAlign"><a>
	<top><c path="Int"/></top>
	<right><c path="Int"/></right>
	<left><c path="Int"/></left>
	<bottom><c path="Int"/></bottom>
</a></typedef>
	<typedef path="cn.royan.hl.uis.starling.bases._UiSContainerAlign.ContainerRowConfig" params="" file="cn/royan/hl/uis/starling/bases/UiSContainerAlign.hx" private="1" module="cn.royan.hl.uis.starling.bases.UiSContainerAlign"><a>
	<width><c path="Float"/></width>
	<length><c path="Int"/></length>
	<height><c path="Float"/></height>
</a></typedef>
	<class path="cn.royan.hl.uis.starling.bases.UiSContainerAlign" params="" file="cn/royan/hl/uis/starling/bases/UiSContainerAlign.hx">
		<extends path="cn.royan.hl.uis.starling.bases.UiSContainer"/>
		<implements path="cn.royan.hl.interfaces.uis.IUiContainerAlignBase"/>
		<drawRow set="method" line="149"><f a=""><e path="Void"/></f></drawRow>
		<fillRow set="method" line="102"><f a=""><e path="Void"/></f></fillRow>
		<setMove public="1" set="method" line="97"><f a="effect">
	<f a="">
		<d/>
		<e path="Void"/>
	</f>
	<e path="Void"/>
</f></setMove>
		<setMargins public="1" set="method" line="92"><f a="left:top:right:bottom">
	<c path="Int"/>
	<c path="Int"/>
	<c path="Int"/>
	<c path="Int"/>
	<e path="Void"/>
</f></setMargins>
		<setGaps public="1" set="method" line="87"><f a="gapX:gapY">
	<c path="Int"/>
	<c path="Int"/>
	<e path="Void"/>
</f></setGaps>
		<setContentAlign public="1" set="method" line="82"><f a="value">
	<c path="Int"/>
	<e path="Void"/>
</f></setContentAlign>
		<setVerticalAlign public="1" set="method" line="77"><f a="value">
	<c path="Int"/>
	<e path="Void"/>
</f></setVerticalAlign>
		<setHorizontalAlign public="1" set="method" line="72"><f a="value">
	<c path="Int"/>
	<e path="Void"/>
</f></setHorizontalAlign>
		<dispose public="1" set="method" line="61" override="1"><f a=""><e path="Void"/></f></dispose>
		<draw public="1" set="method" line="52" override="1"><f a=""><e path="Void"/></f></draw>
		<moveProp><f a="">
	<d/>
	<e path="Void"/>
</f></moveProp>
		<itemsHeight><c path="Float"/></itemsHeight>
		<itemsWidth><c path="Float"/></itemsWidth>
		<margins><t path="cn.royan.hl.uis.starling.bases._UiSContainerAlign.ContainerMargin"/></margins>
		<gaps><t path="cn.royan.hl.uis.starling.bases._UiSContainerAlign.ContainerGap"/></gaps>
		<rows><c path="Array"><t path="cn.royan.hl.uis.starling.bases._UiSContainerAlign.ContainerRowConfig"/></c></rows>
		<contentAlign><c path="Int"/></contentAlign>
		<verticalAlign><c path="Int"/></verticalAlign>
		<horizontalAlign><c path="Int"/></horizontalAlign>
		<new public="1" set="method" line="46"><f a="?texture">
	<c path="starling.textures.Texture"/>
	<e path="Void"/>
</f></new>
	</class>
	<class path="cn.royan.hl.uis.starling.bases.UiSContainerGroup" params="" file="cn/royan/hl/uis/starling/bases/UiSContainerGroup.hx">
		<extends path="cn.royan.hl.uis.starling.bases.UiSContainerAlign"/>
		<implements path="cn.royan.hl.interfaces.uis.IUiContainerGroupBase"/>
		<removeAllItems public="1" set="method" line="287" override="1"><f a=""><e path="Void"/></f></removeAllItems>
		<removeItemAt public="1" set="method" line="285" override="1"><f a="index">
	<c path="Int"/>
	<c path="cn.royan.hl.interfaces.uis.IUiBase"/>
</f></removeItemAt>
		<removeItem public="1" set="method" line="283" override="1"><f a="item">
	<c path="cn.royan.hl.interfaces.uis.IUiBase"/>
	<c path="cn.royan.hl.interfaces.uis.IUiBase"/>
</f></removeItem>
		<addItemAt public="1" set="method" line="281" override="1"><f a="item:index">
	<c path="cn.royan.hl.interfaces.uis.IUiBase"/>
	<c path="Int"/>
	<c path="cn.royan.hl.interfaces.uis.IUiBase"/>
</f></addItemAt>
		<addItem public="1" set="method" line="279" override="1"><f a="item">
	<c path="cn.royan.hl.interfaces.uis.IUiBase"/>
	<c path="cn.royan.hl.interfaces.uis.IUiBase"/>
</f></addItem>
		<addToStageHandler set="method" line="270" override="1"><f a="?evt">
	<c path="starling.events.Event"/>
	<e path="Void"/>
</f></addToStageHandler>
		<getKey set="method" line="260"><f a="value">
	<c path="cn.royan.hl.interfaces.uis.IUiItemGroupBase"/>
	<d/>
</f></getKey>
		<itemSelectHandler set="method" line="207"><f a="obj:touch">
	<c path="cn.royan.hl.interfaces.uis.IUiItemGroupBase"/>
	<c path="starling.events.Touch"/>
	<e path="Void"/>
</f></itemSelectHandler>
		<dispose public="1" set="method" line="198" override="1"><f a=""><e path="Void"/></f></dispose>
		<setMaxLen public="1" set="method" line="193"><f a="value">
	<c path="Int"/>
	<e path="Void"/>
</f></setMaxLen>
		<setIsMulti public="1" set="method" line="188"><f a="value">
	<e path="Bool"/>
	<e path="Void"/>
</f></setIsMulti>
		<setIsMust public="1" set="method" line="183"><f a="value">
	<e path="Bool"/>
	<e path="Void"/>
</f></setIsMust>
		<getValue set="method" line="171"><f a="key">
	<d/>
	<c path="cn.royan.hl.interfaces.uis.IUiItemGroupBase"/>
</f></getValue>
		<setValues public="1" set="method" line="159"><f a="array">
	<c path="Array"><d/></c>
	<e path="Void"/>
</f></setValues>
		<getValues public="1" set="method" line="154"><f a=""><c path="Array"><d/></c></f></getValues>
		<getSelectedItems public="1" set="method" line="149"><f a=""><c path="Array"><c path="cn.royan.hl.interfaces.uis.IUiItemGroupBase"/></c></f></getSelectedItems>
		<getGroupItems public="1" set="method" line="144"><f a=""><c path="Array"><c path="cn.royan.hl.interfaces.uis.IUiItemGroupBase"/></c></f></getGroupItems>
		<getIndexByGroupItem public="1" set="method" line="139"><f a="item">
	<c path="cn.royan.hl.interfaces.uis.IUiItemGroupBase"/>
	<c path="Int"/>
</f></getIndexByGroupItem>
		<getGroupItemAt public="1" set="method" line="134"><f a="index">
	<c path="Int"/>
	<c path="cn.royan.hl.interfaces.uis.IUiItemGroupBase"/>
</f></getGroupItemAt>
		<removeAllGroupItems public="1" set="method" line="123"><f a=""><e path="Void"/></f></removeAllGroupItems>
		<removeGroupItemAt public="1" set="method" line="111"><f a="index">
	<c path="Int"/>
	<c path="cn.royan.hl.interfaces.uis.IUiItemGroupBase"/>
</f></removeGroupItemAt>
		<removeGroupItem public="1" set="method" line="93"><f a="item">
	<c path="cn.royan.hl.interfaces.uis.IUiItemGroupBase"/>
	<c path="cn.royan.hl.interfaces.uis.IUiItemGroupBase"/>
</f></removeGroupItem>
		<addGroupItemAt public="1" set="method" line="63"><f a="item:index:?key">
	<c path="cn.royan.hl.interfaces.uis.IUiItemGroupBase"/>
	<c path="Int"/>
	<d/>
	<c path="cn.royan.hl.interfaces.uis.IUiItemGroupBase"/>
</f></addGroupItemAt>
		<addGroupItem public="1" set="method" line="42"><f a="item:?key">
	<c path="cn.royan.hl.interfaces.uis.IUiItemGroupBase"/>
	<d/>
	<c path="cn.royan.hl.interfaces.uis.IUiItemGroupBase"/>
</f></addGroupItem>
		<values><c path="Array"><d/></c></values>
		<selects><c path="Array"><c path="cn.royan.hl.interfaces.uis.IUiItemGroupBase"/></c></selects>
		<keys><c path="Array"><d/></c></keys>
		<maxLen><c path="Int"/></maxLen>
		<isMust><e path="Bool"/></isMust>
		<isMulti><e path="Bool"/></isMulti>
		<new public="1" set="method" line="28"><f a="?texture">
	<c path="starling.textures.Texture"/>
	<e path="Void"/>
</f></new>
		<haxe_doc>* ...
 * @author RoYan</haxe_doc>
	</class>
	<class path="cn.royan.hl.uis.starling.bases.UiSLabelButton" params="" file="cn/royan/hl/uis/starling/bases/UiSLabelButton.hx">
		<extends path="cn.royan.hl.uis.starling.bases.UiSBmpdButton"/>
		<implements path="cn.royan.hl.interfaces.uis.IUiItemGroupBase"/>
		<implements path="cn.royan.hl.interfaces.uis.IUiTextBase"/>
		<setMultiLine public="1" set="method" line="196"><f a="value">
	<e path="Bool"/>
	<e path="Void"/>
</f></setMultiLine>
		<getMaxScroll public="1" set="method" line="191"><f a=""><t path="cn.royan.hl.geom.Range"/></f></getMaxScroll>
		<getScroll public="1" set="method" line="186"><f a=""><t path="cn.royan.hl.geom.Range"/></f></getScroll>
		<setScroll public="1" set="method" line="181"><f a="?sx:?sy">
	<c path="Int"/>
	<c path="Int"/>
	<e path="Void"/>
</f></setScroll>
		<getDefaultFormat public="1" set="method" line="176"><f a=""><c path="flash.text.TextFormat"/></f></getDefaultFormat>
		<setDefaultFormat public="1" set="method" line="171"><f a="value">
	<c path="flash.text.TextFormat"/>
	<e path="Void"/>
</f></setDefaultFormat>
		<getFormat public="1" set="method" line="166"><f a="?begin:?end">
	<c path="Int"/>
	<c path="Int"/>
	<c path="flash.text.TextFormat"/>
</f></getFormat>
		<setFormat public="1" set="method" line="161"><f a="value:?begin:?end">
	<c path="flash.text.TextFormat"/>
	<c path="Int"/>
	<c path="Int"/>
	<e path="Void"/>
</f></setFormat>
		<setEmbedFont public="1" set="method" line="156"><f a="value">
	<e path="Bool"/>
	<e path="Void"/>
</f></setEmbedFont>
		<setTextSize public="1" set="method" line="151"><f a="value">
	<c path="Int"/>
	<e path="Void"/>
</f></setTextSize>
		<setTextColor public="1" set="method" line="146"><f a="value">
	<c path="Int"/>
	<e path="Void"/>
</f></setTextColor>
		<setTextAlign public="1" set="method" line="141"><f a="value">
	<c path="Int"/>
	<e path="Void"/>
</f></setTextAlign>
		<getHTMLText public="1" set="method" line="136"><f a=""><c path="String"/></f></getHTMLText>
		<appendHTMLText public="1" set="method" line="131"><f a="value">
	<c path="String"/>
	<e path="Void"/>
</f></appendHTMLText>
		<setHTMLText public="1" set="method" line="126"><f a="value">
	<c path="String"/>
	<e path="Void"/>
</f></setHTMLText>
		<getText public="1" set="method" line="121"><f a=""><c path="String"/></f></getText>
		<appendText public="1" set="method" line="116"><f a="value">
	<c path="String"/>
	<e path="Void"/>
</f></appendText>
		<setText public="1" set="method" line="111"><f a="value">
	<c path="String"/>
	<e path="Void"/>
</f></setText>
		<setTextMargin public="1" set="method" line="106"><f a="t:r:b:l">
	<c path="Int"/>
	<c path="Int"/>
	<c path="Int"/>
	<c path="Int"/>
	<e path="Void"/>
</f></setTextMargin>
		<setScale public="1" set="method" line="100" override="1"><f a="value">
	<c path="Float"/>
	<e path="Void"/>
</f></setScale>
		<setSize public="1" set="method" line="94" override="1"><f a="cWidth:cHeight">
	<c path="Float"/>
	<c path="Float"/>
	<e path="Void"/>
</f></setSize>
		<setTextColors public="1" set="method" line="88"><f a="value">
	<c path="Array"><d/></c>
	<e path="Void"/>
</f></setTextColors>
		<setType public="1" set="method" line="83"><f a="type">
	<c path="Int"/>
	<e path="Void"/>
</f></setType>
		<setTextSpace public="1" set="method" line="78"><f a="r:c">
	<c path="Int"/>
	<c path="Int"/>
	<e path="Void"/>
</f></setTextSpace>
		<autoSize public="1" set="method" line="73"><f a="value">
	<c path="Int"/>
	<e path="Void"/>
</f></autoSize>
		<getDefaultTextColor public="1" set="method" line="68"><f a=""><c path="Array"><d/></c></f></getDefaultTextColor>
		<mouseClickHandler set="method" line="57" override="1"><f a="touch">
	<c path="starling.events.Touch"/>
	<e path="Void"/>
</f></mouseClickHandler>
		<draw public="1" set="method" line="50" override="1"><f a=""><e path="Void"/></f></draw>
		<textColors><c path="Array"><d/></c></textColors>
		<btnLabelText><c path="cn.royan.hl.uis.starling.bases.UiSText"/></btnLabelText>
		<btnLabel><c path="String"/></btnLabel>
		<new public="1" set="method" line="30"><f a="?label:?texture">
	<c path="String"/>
	<c path="Array"><c path="starling.textures.Texture"/></c>
	<e path="Void"/>
</f></new>
		<haxe_doc>* ...
 * @author RoYan</haxe_doc>
	</class>
	<class path="cn.royan.hl.uis.starling.bases.UiSScrollBar" params="" file="cn/royan/hl/uis/starling/bases/UiSScrollBar.hx">
		<extends path="cn.royan.hl.uis.starling.bases.UiSContainerAlign"/>
		<implements path="cn.royan.hl.interfaces.uis.IUiScrollBarBase"/>
		<setBackgroundTextrue public="1" set="method" line="224"><f a="texture">
	<d/>
	<e path="Void"/>
</f></setBackgroundTextrue>
		<setMaxTexture public="1" set="method" line="219"><f a="texture">
	<d/>
	<e path="Void"/>
</f></setMaxTexture>
		<setMinTexture public="1" set="method" line="214"><f a="texture">
	<d/>
	<e path="Void"/>
</f></setMinTexture>
		<setThumbTexture public="1" set="method" line="209"><f a="texture">
	<d/>
	<e path="Void"/>
</f></setThumbTexture>
		<setType public="1" set="method" line="195"><f a="type">
	<c path="Int"/>
	<e path="Void"/>
</f></setType>
		<getValue public="1" set="method" line="184"><f a=""><c path="Int"/></f></getValue>
		<setValue public="1" set="method" line="174"><f a="value">
	<c path="Int"/>
	<e path="Void"/>
</f></setValue>
		<setSize public="1" set="method" line="142" override="1"><f a="w:h">
	<c path="Float"/>
	<c path="Float"/>
	<e path="Void"/>
</f></setSize>
		<thumbMoveHandler set="method" line="129"><f a="obj:touch">
	<c path="cn.royan.hl.uis.starling.bases.UiSLabelButton"/>
	<c path="starling.events.Touch"/>
	<e path="Void"/>
</f></thumbMoveHandler>
		<backgroundClickHandler set="method" line="108"><f a="obj:touch">
	<c path="cn.royan.hl.uis.starling.bases.UiSLabelButton"/>
	<c path="starling.events.Touch"/>
	<e path="Void"/>
</f></backgroundClickHandler>
		<maxMouseUpHandler set="method" line="103"><f a="obj:touch">
	<c path="cn.royan.hl.uis.starling.bases.UiSLabelButton"/>
	<c path="starling.events.Touch"/>
	<e path="Void"/>
</f></maxMouseUpHandler>
		<maxEnterHandler set="method" line="86"><f a="evt">
	<c path="starling.events.Event"/>
	<e path="Void"/>
</f></maxEnterHandler>
		<maxMouseDownHandler set="method" line="81"><f a="obj:touch">
	<c path="cn.royan.hl.uis.starling.bases.UiSLabelButton"/>
	<c path="starling.events.Touch"/>
	<e path="Void"/>
</f></maxMouseDownHandler>
		<minMouseUpHandler set="method" line="76"><f a="obj:touch">
	<c path="cn.royan.hl.uis.starling.bases.UiSLabelButton"/>
	<c path="starling.events.Touch"/>
	<e path="Void"/>
</f></minMouseUpHandler>
		<minEnterHandler set="method" line="60"><f a="evt">
	<c path="starling.events.Event"/>
	<e path="Void"/>
</f></minEnterHandler>
		<minMouseDownHandler set="method" line="55"><f a="obj:touch">
	<c path="cn.royan.hl.uis.starling.bases.UiSLabelButton"/>
	<c path="starling.events.Touch"/>
	<e path="Void"/>
</f></minMouseDownHandler>
		<scrollerType><c path="Int"/></scrollerType>
		<rect><c path="flash.geom.Rectangle"/></rect>
		<bar><c path="cn.royan.hl.uis.starling.InteractiveUiS"/></bar>
		<thumb><c path="cn.royan.hl.uis.starling.bases.UiSLabelButton"/></thumb>
		<max><c path="cn.royan.hl.uis.starling.bases.UiSLabelButton"/></max>
		<min><c path="cn.royan.hl.uis.starling.bases.UiSLabelButton"/></min>
		<new public="1" set="method" line="29"><f a="?type">
	<c path="Int"/>
	<e path="Void"/>
</f></new>
		<haxe_doc>* ...
 * @author RoYan</haxe_doc>
	</class>
	<class path="cn.royan.hl.uis.starling.bases.UiSScrollPane" params="" file="cn/royan/hl/uis/starling/bases/UiSScrollPane.hx">
		<extends path="cn.royan.hl.uis.starling.InteractiveUiS"/>
		<implements path="cn.royan.hl.interfaces.uis.IUiScrollPaneBase"/>
		<setBackgroundTextrue public="1" set="method" line="162"><f a="texture">
	<d/>
	<e path="Void"/>
</f></setBackgroundTextrue>
		<setMaxTexture public="1" set="method" line="156"><f a="texture">
	<d/>
	<e path="Void"/>
</f></setMaxTexture>
		<setMinTexture public="1" set="method" line="150"><f a="texture">
	<d/>
	<e path="Void"/>
</f></setMinTexture>
		<setThumbTexture public="1" set="method" line="144"><f a="texture">
	<d/>
	<e path="Void"/>
</f></setThumbTexture>
		<vChangeHandler set="method" line="139"><f a="evt">
	<c path="cn.royan.hl.events.DatasEvent"/>
	<e path="Void"/>
</f></vChangeHandler>
		<hChangeHandler set="method" line="134"><f a="evt">
	<c path="cn.royan.hl.events.DatasEvent"/>
	<e path="Void"/>
</f></hChangeHandler>
		<setType public="1" set="method" line="94"><f a="type">
	<c path="Int"/>
	<e path="Void"/>
</f></setType>
		<setSize public="1" set="method" line="71" override="1"><f a="cWidth:cHeight">
	<c path="Float"/>
	<c path="Float"/>
	<e path="Void"/>
</f></setSize>
		<changeHandler set="method" line="54"><f a="?evt">
	<c path="cn.royan.hl.events.DatasEvent"/>
	<e path="Void"/>
</f></changeHandler>
		<addToStageHandler set="method" line="45" override="1"><f a="?evt">
	<c path="starling.events.Event"/>
	<e path="Void"/>
</f></addToStageHandler>
		<vScrollBar><c path="cn.royan.hl.uis.starling.bases.UiSScrollBar"/></vScrollBar>
		<hScrollBar><c path="cn.royan.hl.uis.starling.bases.UiSScrollBar"/></hScrollBar>
		<scrollerType><c path="Int"/></scrollerType>
		<containerMask><c path="cn.royan.hl.uis.starling.UninteractiveUiS"/></containerMask>
		<container><c path="cn.royan.hl.uis.starling.InteractiveUiS"/></container>
		<new public="1" set="method" line="27"><f a="container:?type">
	<c path="cn.royan.hl.uis.starling.InteractiveUiS"/>
	<c path="Int"/>
	<e path="Void"/>
</f></new>
		<haxe_doc>* ...
 * @author RoYan</haxe_doc>
	</class>
	<class path="cn.royan.hl.uis.starling.bases.UiSText" params="" file="cn/royan/hl/uis/starling/bases/UiSText.hx">
		<extends path="cn.royan.hl.uis.starling.InteractiveUiS"/>
		<implements path="cn.royan.hl.interfaces.uis.IUiTextBase"/>
		<setMaxChars public="1" set="method" line="166"><f a="value">
	<c path="Int"/>
	<e path="Void"/>
</f></setMaxChars>
		<setMultiLine public="1" set="method" line="161"><f a="value">
	<e path="Bool"/>
	<e path="Void"/>
</f></setMultiLine>
		<getMaxScroll public="1" set="method" line="156"><f a=""><t path="cn.royan.hl.geom.Range"/></f></getMaxScroll>
		<getScroll public="1" set="method" line="151"><f a=""><t path="cn.royan.hl.geom.Range"/></f></getScroll>
		<setScroll public="1" set="method" line="146"><f a="?sx:?sy">
	<c path="Int"/>
	<c path="Int"/>
	<e path="Void"/>
</f></setScroll>
		<getDefaultFormat public="1" set="method" line="141"><f a=""><c path="flash.text.TextFormat"/></f></getDefaultFormat>
		<setDefaultFormat public="1" set="method" line="136"><f a="value">
	<c path="flash.text.TextFormat"/>
	<e path="Void"/>
</f></setDefaultFormat>
		<getFormat public="1" set="method" line="131"><f a="?begin:?end">
	<c path="Int"/>
	<c path="Int"/>
	<c path="flash.text.TextFormat"/>
</f></getFormat>
		<setFormat public="1" set="method" line="126"><f a="value:?begin:?end">
	<c path="flash.text.TextFormat"/>
	<c path="Int"/>
	<c path="Int"/>
	<e path="Void"/>
</f></setFormat>
		<setEmbedFont public="1" set="method" line="121"><f a="value">
	<e path="Bool"/>
	<e path="Void"/>
</f></setEmbedFont>
		<setTextSize public="1" set="method" line="114"><f a="value">
	<c path="Int"/>
	<e path="Void"/>
</f></setTextSize>
		<setTextColor public="1" set="method" line="109"><f a="value">
	<c path="Int"/>
	<e path="Void"/>
</f></setTextColor>
		<setTextAlign public="1" set="method" line="97"><f a="value">
	<c path="Int"/>
	<e path="Void"/>
</f></setTextAlign>
		<getHTMLText public="1" set="method" line="92"><f a=""><c path="String"/></f></getHTMLText>
		<appendHTMLText public="1" set="method" line="87"><f a="value">
	<c path="String"/>
	<e path="Void"/>
</f></appendHTMLText>
		<setHTMLText public="1" set="method" line="82"><f a="value">
	<c path="String"/>
	<e path="Void"/>
</f></setHTMLText>
		<getText public="1" set="method" line="77"><f a=""><c path="String"/></f></getText>
		<appendText public="1" set="method" line="72"><f a="value">
	<c path="String"/>
	<e path="Void"/>
</f></appendText>
		<setText public="1" set="method" line="67"><f a="value">
	<c path="String"/>
	<e path="Void"/>
</f></setText>
		<autoSize public="1" set="method" line="62"><f a="value">
	<c path="Int"/>
	<e path="Void"/>
</f></autoSize>
		<setType public="1" set="method" line="58"><f a="type">
	<c path="Int"/>
	<e path="Void"/>
</f></setType>
		<setTextSpace public="1" set="method" line="53"><f a="r:c">
	<c path="Int"/>
	<c path="Int"/>
	<e path="Void"/>
</f></setTextSpace>
		<setScale public="1" set="method" line="44" override="1"><f a="value">
	<c path="Float"/>
	<e path="Void"/>
</f></setScale>
		<setSize public="1" set="method" line="36" override="1"><f a="w:h">
	<c path="Float"/>
	<c path="Float"/>
	<e path="Void"/>
</f></setSize>
		<fontSize><c path="Float"/></fontSize>
		<inputText><c path="starling.text.TextField"/></inputText>
		<new public="1" set="method" line="23"><f a="?label:?fontN:?fontS:?fontC:?fontB">
	<c path="String"/>
	<c path="String"/>
	<c path="Int"/>
	<t path="UInt"/>
	<e path="Bool"/>
	<e path="Void"/>
</f></new>
		<haxe_doc>* ...
 * @author RoYan</haxe_doc>
	</class>
	<class path="cn.royan.hl.uis.starling.bases.UiSWindow" params="" file="cn/royan/hl/uis/starling/bases/UiSWindow.hx">
		<extends path="cn.royan.hl.uis.starling.bases.UiSContainer"/>
		<moveHandler set="method" line="30"><f a="obj:touch">
	<c path="cn.royan.hl.uis.starling.bases.UiSLabelButton"/>
	<c path="starling.events.Touch"/>
	<e path="Void"/>
</f></moveHandler>
		<setHeaderHeight public="1" set="method" line="25"><f a="value">
	<c path="Int"/>
	<e path="Void"/>
</f></setHeaderHeight>
		<header><c path="cn.royan.hl.uis.starling.bases.UiSLabelButton"/></header>
		<new public="1" set="method" line="13"><f a="?texture">
	<c path="starling.textures.Texture"/>
	<e path="Void"/>
</f></new>
		<haxe_doc>* ...
 * @author RoYan</haxe_doc>
	</class>
	<class path="cn.royan.hl.uis.starling.exts.UiSExtBmpNumberText" params="" file="cn/royan/hl/uis/starling/exts/UiSExtBmpNumberText.hx">
		<extends path="cn.royan.hl.uis.starling.bases.UiSContainerAlign"/>
		<getValue public="1" set="method" line="73"><f a=""><c path="Int"/></f></getValue>
		<setValue public="1" set="method" line="41"><f a="value">
	<c path="Int"/>
	<e path="Void"/>
</f></setValue>
		<setIsAlwaysShow public="1" set="method" line="30"><f a="value">
	<e path="Bool"/>
	<e path="Void"/>
</f></setIsAlwaysShow>
		<length><c path="Int"/></length>
		<num><c path="Int"/></num>
		<isAlwaysShow><e path="Bool"/></isAlwaysShow>
		<instance><c path="cn.royan.hl.uis.starling.bases.UiSBmpdMovieClip"/></instance>
		<new public="1" set="method" line="20"><f a="texture:?len">
	<c path="Array"><c path="starling.textures.Texture"/></c>
	<c path="Int"/>
	<e path="Void"/>
</f></new>
		<haxe_doc>* ...
 * @author RoYan</haxe_doc>
	</class>
	<class path="cn.royan.hl.uis.starling.exts.UiSExtImageLoader" params="" file="cn/royan/hl/uis/starling/exts/UiSExtImageLoader.hx">
		<extends path="cn.royan.hl.uis.starling.bases.UiSContainerAlign"/>
		<load public="1" set="method" line="39"><f a="url">
	<c path="String"/>
	<e path="Void"/>
</f></load>
		<doneHandler set="method" line="34"><f a="data">
	<c path="flash.display.BitmapData"/>
	<e path="Void"/>
</f></doneHandler>
		<image><c path="cn.royan.hl.uis.starling.InteractiveUiS"/></image>
		<takeService><c path="cn.royan.hl.services.TakeService"/></takeService>
		<new public="1" set="method" line="19"><f a="?url">
	<c path="String"/>
	<e path="Void"/>
</f></new>
		<haxe_doc>* ...
 * @author RoYan</haxe_doc>
	</class>
	<class path="cn.royan.hl.uis.style.Style" params="" file="cn/royan/hl/uis/style/Style.hx">
		<copyFrom public="1" set="method" line="41"><f a="source">
	<c path="cn.royan.hl.uis.style.Style"/>
	<e path="Void"/>
</f></copyFrom>
		<parseAtlasCss set="method" line="20"><f a="property">
	<c path="String"/>
	<e path="Void"/>
</f></parseAtlasCss>
		<document><c path="cn.royan.hl.uis.style.StyleCSS"/></document>
		<new public="1" set="method" line="13"><f a="name:property">
	<c path="cn.royan.hl.uis.style.StyleCSS"/>
	<c path="String"/>
	<e path="Void"/>
</f></new>
		<haxe_doc>* ...
 * @author RoYan</haxe_doc>
		<haxe_dynamic><d/></haxe_dynamic>
	</class>
	<class path="cn.royan.hl.uis.style.StyleCSS" params="" file="cn/royan/hl/uis/style/StyleCSS.hx">
		<getStyle public="1" set="method" line="41"><f a="name">
	<c path="String"/>
	<c path="cn.royan.hl.uis.style.Style"/>
</f></getStyle>
		<parseAtlasCss set="method" line="25"><f a="value">
	<c path="String"/>
	<e path="Void"/>
</f></parseAtlasCss>
		<styles><t path="cn.royan.hl.bases.Dictionary"/></styles>
		<css><c path="String"/></css>
		<new public="1" set="method" line="16"><f a="name:value">
	<c path="String"/>
	<c path="String"/>
	<e path="Void"/>
</f></new>
		<haxe_doc>* ...
 * @author RoYan</haxe_doc>
	</class>
	<class path="cn.royan.hl.uis.style.StyleManager" params="" file="cn/royan/hl/uis/style/StyleManager.hx">
		<gameCSSs line="13" static="1"><t path="cn.royan.hl.bases.Dictionary"/></gameCSSs>
		<gameStyles line="14" static="1"><t path="cn.royan.hl.bases.Dictionary"/></gameStyles>
		<setCSS public="1" set="method" line="16" static="1"><f a="type:value">
	<c path="String"/>
	<c path="String"/>
	<e path="Void"/>
</f></setCSS>
		<getCSS public="1" set="method" line="21" static="1"><f a="type">
	<c path="String"/>
	<c path="cn.royan.hl.uis.style.StyleCSS"/>
</f></getCSS>
		<haxe_doc>* ...
 * @author RoYan</haxe_doc>
	</class>
	<class path="cn.royan.hl.utils.BindUtils" params="" file="cn/royan/hl/utils/BindUtils.hx">
		<toProperty public="1" set="method" line="20" static="1">
			<f a="oa:fa:ob:fb">
				<c path="cn.royan.hl.bases.DispatcherBase"/>
				<c path="String"/>
				<c path="cn.royan.hl.bases.DispatcherBase"/>
				<c path="String"/>
				<e path="Void"/>
			</f>
			<haxe_doc>* 将A对象的A属性与B对象的B属性进行绑定
	 * @param	oa
	 * @param	fa
	 * @param	ob
	 * @param	fb</haxe_doc>
		</toProperty>
		<toFunction public="1" set="method" line="37" static="1">
			<f a="oa:fa:call">
				<c path="cn.royan.hl.bases.DispatcherBase"/>
				<c path="String"/>
				<f a="">
					<d/>
					<e path="Void"/>
				</f>
				<e path="Void"/>
			</f>
			<haxe_doc>* 将A对象的A属性与函数进行绑定
	 * @param	oa
	 * @param	fa
	 * @param	call</haxe_doc>
		</toFunction>
		<haxe_doc>* ...
 * 绑定工具类
 * @author RoYan</haxe_doc>
	</class>
	<class path="cn.royan.hl.utils.BitmapDataUtils" params="" file="cn/royan/hl/utils/BitmapDataUtils.hx">
		<fromColors public="1" set="method" line="31" static="1">
			<f a="width:height:colors:alphas:?length:?border:?thick:?alpha:?rx:?ry">
				<c path="Int"/>
				<c path="Int"/>
				<c path="Array"><d/></c>
				<c path="Array"><d/></c>
				<c path="Int"/>
				<c path="Int"/>
				<c path="Int"/>
				<c path="Float"/>
				<c path="Int"/>
				<c path="Int"/>
				<c path="flash.display.BitmapData"/>
			</f>
			<haxe_doc>* 创建图像
	 * @param	width
	 * @param	height
	 * @param	colors
	 * @param	alphas
	 * @param	length
	 * @param	border
	 * @param	thick
	 * @param	alpha
	 * @param	rx
	 * @param	ry
	 * @return</haxe_doc>
		</fromColors>
		<fromDisplayObject public="1" set="method" line="98" static="1">
			<f a="displayObject">
				<c path="flash.display.DisplayObject"/>
				<c path="flash.display.BitmapData"/>
			</f>
			<haxe_doc>* 获取可视对象的图像
	 * @param	displayObject
	 * @return</haxe_doc>
		</fromDisplayObject>
		<haxe_doc>* ...
 * 图像工具类
 * @author RoYan</haxe_doc>
	</class>
	<class path="cn.royan.hl.utils.BytesUtils" params="" file="cn/royan/hl/utils/BytesUtils.hx">
		<getType public="1" set="method" line="17" static="1">
			<f a="bytes">
				<c path="flash.utils.ByteArray"/>
				<c path="String"/>
			</f>
			<haxe_doc>* 数据类型
	 * @param	bytes
	 * @return</haxe_doc>
		</getType>
		<isPNG public="1" set="method" line="51" static="1">
			<f a="bytes">
				<c path="flash.utils.ByteArray"/>
				<e path="Bool"/>
			</f>
			<haxe_doc>* 是否为PNG
	 * @param	bytes
	 * @return</haxe_doc>
		</isPNG>
		<isJPEG public="1" set="method" line="83" static="1">
			<f a="bytes">
				<c path="flash.utils.ByteArray"/>
				<e path="Bool"/>
			</f>
			<haxe_doc>* 是否为JPEG
	 * @param	bytes
	 * @return</haxe_doc>
		</isJPEG>
		<isSWF public="1" set="method" line="127" static="1">
			<f a="bytes">
				<c path="flash.utils.ByteArray"/>
				<e path="Bool"/>
			</f>
			<haxe_doc>* 是否为SWF
	 * @param	bytes
	 * @return</haxe_doc>
		</isSWF>
		<isXML public="1" set="method" line="140" static="1">
			<f a="bytes">
				<c path="flash.utils.ByteArray"/>
				<e path="Bool"/>
			</f>
			<haxe_doc>* 是否为XML
	 * @param	bytes
	 * @return</haxe_doc>
		</isXML>
		<isGIF public="1" set="method" line="153" static="1">
			<f a="bytes">
				<c path="flash.utils.ByteArray"/>
				<e path="Bool"/>
			</f>
			<haxe_doc>* 是否为GIF
	 * @param	bytes
	 * @return</haxe_doc>
		</isGIF>
		<isBMP public="1" set="method" line="187" static="1">
			<f a="bytes">
				<c path="flash.utils.ByteArray"/>
				<e path="Bool"/>
			</f>
			<haxe_doc>* 是否BMP
	 * @param	bytes
	 * @return</haxe_doc>
		</isBMP>
		<isFLV public="1" set="method" line="206" static="1">
			<f a="bytes">
				<c path="flash.utils.ByteArray"/>
				<e path="Bool"/>
			</f>
			<haxe_doc>* 是否为FLV
	 * @param	bytes
	 * @return</haxe_doc>
		</isFLV>
		<isMP3 public="1" set="method" line="219" static="1">
			<f a="bytes">
				<c path="flash.utils.ByteArray"/>
				<e path="Bool"/>
			</f>
			<haxe_doc>* 是否为MP3
	 * @param	bytes
	 * @return</haxe_doc>
		</isMP3>
		<isEncrypt public="1" set="method" line="232" static="1">
			<f a="bytes">
				<c path="flash.utils.ByteArray"/>
				<e path="Bool"/>
			</f>
			<haxe_doc>* 是否进行了编码
	 * @param	bytes
	 * @return</haxe_doc>
		</isEncrypt>
		<simpleDecode public="1" set="method" line="252" static="1">
			<f a="bytes:key">
				<c path="flash.utils.ByteArray"/>
				<c path="String"/>
				<c path="flash.utils.ByteArray"/>
			</f>
			<haxe_doc>* 进行解码
	 * @param	bytes
	 * @param	key
	 * @return</haxe_doc>
		</simpleDecode>
		<haxe_doc>* ...
 * 数据工具类
 * @author RoYan</haxe_doc>
	</class>
	<class path="cn.royan.hl.utils.KeyBoardUtils" params="" file="cn/royan/hl/utils/KeyBoardUtils.hx">
		<keyObj static="1"><c path="cn.royan.hl.utils.KeyBoardUtils"/></keyObj>
		<keys static="1"><t path="cn.royan.hl.bases.Dictionary"/></keys>
		<init public="1" set="method" line="26" static="1">
			<f a="display">
				<c path="flash.display.DisplayObject"/>
				<e path="Void"/>
			</f>
			<haxe_doc>* 初始化
	 * @param	display</haxe_doc>
		</init>
		<isDown public="1" set="method" line="43" static="1">
			<f a="code">
				<t path="UInt"/>
				<e path="Bool"/>
			</f>
			<haxe_doc>* 检测键位状态
	 * @param	code
	 * @return</haxe_doc>
		</isDown>
		<keyDownHandler set="method" line="48" static="1"><f a="evt">
	<c path="flash.events.KeyboardEvent"/>
	<e path="Void"/>
</f></keyDownHandler>
		<keyUpHandler set="method" line="53" static="1"><f a="evt">
	<c path="flash.events.KeyboardEvent"/>
	<e path="Void"/>
</f></keyUpHandler>
		<new set="method" line="18"><f a=""><e path="Void"/></f></new>
		<haxe_doc>* ...
 * 键盘工具类
 * @author RoYan</haxe_doc>
	</class>
	<class path="cn.royan.hl.utils.StarlingUtils" params="" file="cn/royan/hl/utils/StarlingUtils.hx">
		<toArray public="1" set="method" line="18" static="1">
			<f a="vector">
				<c path="flash.Vector"><c path="starling.textures.Texture"/></c>
				<c path="Array"><d/></c>
			</f>
			<haxe_doc>* 切换列表类型
	 * @param	vector
	 * @return</haxe_doc>
		</toArray>
		<haxe_doc>* ...
 * Starling工具类
 * @author RoYan</haxe_doc>
	</class>
	<class path="cn.royan.hl.utils.SystemUtils" params="" file="cn/royan/hl/utils/SystemUtils.hx">
		<ukey get="inline" set="null" line="22" static="1"><c path="Array"><c path="String"/></c></ukey>
		<UID_CHARS get="inline" set="null" line="23" static="1"><c path="String"/></UID_CHARS>
		<showDebug public="1" line="25" static="1"><c path="Int"/></showDebug>
		<print public="1" set="method" line="33" static="1">
			<f a="v:?level:?info">
				<d/>
				<c path="Int"/>
				<t path="haxe.PosInfos"/>
				<e path="Void"/>
			</f>
			<haxe_doc>* 打印调试代码
	 * @param	v
	 * @param	level
	 * @param	?info</haxe_doc>
		</print>
		<arrayIndexOf public="1" set="method" line="51" static="1">
			<f a="array:value">
				<c path="Array"><d/></c>
				<d/>
				<c path="Int"/>
			</f>
			<haxe_doc>* 查找索引
	 * @param	array
	 * @param	value
	 * @return</haxe_doc>
		</arrayIndexOf>
		<replace public="1" set="method" line="66" static="1">
			<f a="orgin:args">
				<c path="String"/>
				<c path="Array"><d/></c>
				<c path="String"/>
			</f>
			<haxe_doc>* 替换
	 * @param	orgin
	 * @param	args
	 * @return</haxe_doc>
		</replace>
		<createUniqueID public="1" set="method" line="78" static="1">
			<f a=""><c path="String"/></f>
			<haxe_doc>* 创建唯一值
	 * @return</haxe_doc>
		</createUniqueID>
		<random get="inline" set="null" line="83" static="1"><f a="?size">
	<c path="Int"/>
	<c path="String"/>
</f></random>
		<readObject public="1" set="method" line="104" static="1">
			<f a="object:?index">
				<d/>
				<c path="Int"/>
				<e path="Void"/>
			</f>
			<haxe_doc>* 读取对象
	 * @param	object
	 * @param	index</haxe_doc>
		</readObject>
		<__loaderContext static="1"><c path="flash.system.LoaderContext"/></__loaderContext>
		<getLoaderContext public="1" set="method" line="123" static="1">
			<f a=""><c path="flash.system.LoaderContext"/></f>
			<haxe_doc>* 获取加载配置
	 * @return</haxe_doc>
		</getLoaderContext>
		<getInstanceByClassName public="1" set="method" line="144" static="1">
			<f a="className:?parameters">
				<c path="String"/>
				<c path="Array"><d/></c>
				<d/>
			</f>
			<haxe_doc>* 创建对象
	 * @param	className
	 * @param	?parameters
	 * @return</haxe_doc>
		</getInstanceByClassName>
		<copyToClipboard public="1" set="method" line="157" static="1">
			<f a="value">
				<c path="String"/>
				<e path="Void"/>
			</f>
			<haxe_doc>* 复制
	 * @param	value</haxe_doc>
		</copyToClipboard>
		<gc public="1" set="method" line="165" static="1">
			<f a=""><e path="Void"/></f>
			<haxe_doc>* 内存回收</haxe_doc>
		</gc>
		<haxe_doc>* ...
 * 系统工具类
 * @author RoYan</haxe_doc>
	</class>
	<class path="flash.display.MovieClip" params="" file="C:\Motion-Twin\Haxe/std/flash/display/MovieClip.hx" extern="1">
		<extends path="flash.display.Sprite"/>
		<stop public="1" set="method"><f a=""><e path="Void"/></f></stop>
		<prevScene public="1" set="method"><f a=""><e path="Void"/></f></prevScene>
		<prevFrame public="1" set="method"><f a=""><e path="Void"/></f></prevFrame>
		<play public="1" set="method"><f a=""><e path="Void"/></f></play>
		<nextScene public="1" set="method"><f a=""><e path="Void"/></f></nextScene>
		<nextFrame public="1" set="method"><f a=""><e path="Void"/></f></nextFrame>
		<gotoAndStop public="1" set="method"><f a="frame:?scene">
	<d/>
	<c path="String"/>
	<e path="Void"/>
</f></gotoAndStop>
		<gotoAndPlay public="1" set="method"><f a="frame:?scene">
	<d/>
	<c path="String"/>
	<e path="Void"/>
</f></gotoAndPlay>
		<addFrameScript public="1" set="method"><f a="?p1:?p2:?p3:?p4:?p5">
	<d/>
	<d/>
	<d/>
	<d/>
	<d/>
	<e path="Void"/>
</f></addFrameScript>
		<trackAsMenu public="1"><e path="Bool"/></trackAsMenu>
		<totalFrames public="1" set="null"><c path="Int"/></totalFrames>
		<scenes public="1" set="null"><c path="Array"><c path="flash.display.Scene"/></c></scenes>
		<isPlaying public="1">
			<e path="Bool"/>
			<meta><m n=":require"><e>flash11</e></m></meta>
		</isPlaying>
		<framesLoaded public="1" set="null"><c path="Int"/></framesLoaded>
		<enabled public="1"><e path="Bool"/></enabled>
		<currentScene public="1" set="null"><c path="flash.display.Scene"/></currentScene>
		<currentLabels public="1" set="null"><c path="Array"><c path="flash.display.FrameLabel"/></c></currentLabels>
		<currentLabel public="1" set="null"><c path="String"/></currentLabel>
		<currentFrameLabel public="1" set="null">
			<c path="String"/>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</currentFrameLabel>
		<currentFrame public="1" set="null"><c path="Int"/></currentFrame>
		<new public="1" set="method"><f a=""><e path="Void"/></f></new>
		<haxe_dynamic><d/></haxe_dynamic>
	</class>
	<class path="flash.Boot" params="" file="C:\Motion-Twin\Haxe/std/flash/Boot.hx">
		<extends path="flash.display.MovieClip"/>
		<tf static="1"><c path="flash.text.TextField"/></tf>
		<lines static="1"><c path="Array"><c path="String"/></c></lines>
		<lastError static="1"><c path="flash.errors.Error"/></lastError>
		<skip_constructor public="1" line="54" static="1"><e path="Bool"/></skip_constructor>
		<enum_to_string public="1" set="method" line="86" static="1"><f a="e">
	<a>
		<tag><c path="String"/></tag>
		<params><c path="Array"><d/></c></params>
	</a>
	<c path="String"/>
</f></enum_to_string>
		<__instanceof public="1" set="method" line="95" static="1"><f a="v:t">
	<d/>
	<d/>
	<e path="Bool"/>
</f></__instanceof>
		<__clear_trace public="1" set="method" line="105" static="1"><f a=""><e path="Void"/></f></__clear_trace>
		<__set_trace_color public="1" set="method" line="113" static="1"><f a="rgb">
	<t path="UInt"/>
	<e path="Void"/>
</f></__set_trace_color>
		<getTrace public="1" set="method" line="119" static="1"><f a=""><c path="flash.text.TextField"/></f></getTrace>
		<__trace public="1" set="method" line="147" static="1"><f a="v:pos">
	<d/>
	<t path="haxe.PosInfos"/>
	<e path="Void"/>
</f></__trace>
		<__string_rec public="1" set="method" line="162" static="1"><f a="v:str">
	<d/>
	<c path="String"/>
	<c path="String"/>
</f></__string_rec>
		<__unprotect__ set="method" line="206" static="1"><f a="s">
	<c path="String"/>
	<c path="String"/>
</f></__unprotect__>
		<init set="method" line="82"><f a=""><e path="Void"/></f></init>
		<doInitDelay set="method" line="77"><f a="_">
	<unknown/>
	<e path="Void"/>
</f></doInitDelay>
		<start set="method" line="56"><f a=""><e path="Void"/></f></start>
		<new public="1" set="method" line="48"><f a=""><e path="Void"/></f></new>
		<meta><m n=":keep"/></meta>
	</class>
	<class path="flash._Boot.RealBoot" params="" file="C:\Motion-Twin\Haxe/std/flash/Boot.hx" private="1" module="flash.Boot">
		<extends path="flash.Boot"/>
		<new set="method" line="38"><f a=""><e path="Void"/></f></new>
		<meta><m n=":keep"/></meta>
		<haxe_dynamic><d/></haxe_dynamic>
	</class>
	<class path="flash.Lib" params="" file="C:\Motion-Twin\Haxe/std/flash/Lib.hx">
		<current public="1" static="1"><c path="flash.display.MovieClip"/></current>
		<getTimer public="1" get="inline" set="null" line="31" static="1"><f a=""><c path="Int"/></f></getTimer>
		<eval public="1" set="method" line="35" static="1"><f a="path">
	<c path="String"/>
	<d/>
</f></eval>
		<getURL public="1" set="method" line="55" static="1"><f a="url:?target">
	<c path="flash.net.URLRequest"/>
	<c path="String"/>
	<e path="Void"/>
</f></getURL>
		<fscommand public="1" set="method" line="63" static="1"><f a="cmd:?param">
	<c path="String"/>
	<c path="String"/>
	<e path="Void"/>
</f></fscommand>
		<trace public="1" set="method" line="67" static="1"><f a="arg">
	<d/>
	<e path="Void"/>
</f></trace>
		<attach public="1" set="method" line="71" static="1"><f a="name">
	<c path="String"/>
	<c path="flash.display.MovieClip"/>
</f></attach>
		<as public="1" params="T" get="inline" set="null" line="76" static="1"><f a="v:c">
	<d/>
	<c path="Class"><c path="as.T"/></c>
	<t path="Null"><c path="as.T"/></t>
</f></as>
	</class>
	<class path="flash.Vector" params="T" file="C:\Motion-Twin\Haxe/std/flash/Vector.hx" extern="1">
		<ofArray public="1" params="T" get="inline" set="null" line="26" static="1"><f a="v">
	<c path="Array"><c path="ofArray.T"/></c>
	<c path="flash.Vector"><c path="ofArray.T"/></c>
</f></ofArray>
		<convert public="1" params="T:U" get="inline" set="null" line="30" static="1"><f a="v">
	<c path="flash.Vector"><c path="convert.T"/></c>
	<c path="flash.Vector"><c path="convert.U"/></c>
</f></convert>
		<lastIndexOf public="1" set="method"><f a="x:?from">
	<c path="flash.Vector.T"/>
	<c path="Int"/>
	<c path="Int"/>
</f></lastIndexOf>
		<indexOf public="1" set="method"><f a="x:?from">
	<c path="flash.Vector.T"/>
	<c path="Int"/>
	<c path="Int"/>
</f></indexOf>
		<toString public="1" set="method"><f a=""><c path="String"/></f></toString>
		<splice public="1" set="method"><f a="pos:len">
	<c path="Int"/>
	<c path="Int"/>
	<c path="flash.Vector"><c path="flash.Vector.T"/></c>
</f></splice>
		<sort public="1" set="method"><f a="f">
	<f a=":">
		<c path="flash.Vector.T"/>
		<c path="flash.Vector.T"/>
		<c path="Int"/>
	</f>
	<e path="Void"/>
</f></sort>
		<slice public="1" set="method"><f a="pos:?end">
	<c path="Int"/>
	<c path="Int"/>
	<c path="flash.Vector"><c path="flash.Vector.T"/></c>
</f></slice>
		<unshift public="1" set="method"><f a="x">
	<c path="flash.Vector.T"/>
	<e path="Void"/>
</f></unshift>
		<shift public="1" set="method"><f a=""><t path="Null"><c path="flash.Vector.T"/></t></f></shift>
		<reverse public="1" set="method"><f a=""><e path="Void"/></f></reverse>
		<push public="1" set="method"><f a="x">
	<c path="flash.Vector.T"/>
	<c path="Int"/>
</f></push>
		<pop public="1" set="method"><f a=""><t path="Null"><c path="flash.Vector.T"/></t></f></pop>
		<join public="1" set="method"><f a="sep">
	<c path="String"/>
	<c path="String"/>
</f></join>
		<concat public="1" set="method"><f a="?a">
	<c path="flash.Vector"><c path="flash.Vector.T"/></c>
	<c path="flash.Vector"><c path="flash.Vector.T"/></c>
</f></concat>
		<fixed public="1"><e path="Bool"/></fixed>
		<length public="1"><t path="UInt"/></length>
		<new public="1" set="method"><f a="?length:?fixed">
	<t path="UInt"/>
	<e path="Bool"/>
	<e path="Void"/>
</f></new>
		<haxe_doc>The Vector class is very similar to Array but is only supported by the Flash Player 10+</haxe_doc>
		<meta><m n=":require"><e>flash10</e></m></meta>
	</class>
	<class path="flash.accessibility.AccessibilityImplementation" params="" file="C:\Motion-Twin\Haxe/std/flash/accessibility/AccessibilityImplementation.hx" extern="1">
		<isLabeledBy public="1" set="method"><f a="labelBounds">
	<c path="flash.geom.Rectangle"/>
	<e path="Bool"/>
</f></isLabeledBy>
		<get_selectionAnchorIndex public="1" set="method"><f a=""><d/></f></get_selectionAnchorIndex>
		<get_selectionActiveIndex public="1" set="method"><f a=""><d/></f></get_selectionActiveIndex>
		<get_accValue public="1" set="method"><f a="childID">
	<t path="UInt"/>
	<c path="String"/>
</f></get_accValue>
		<get_accState public="1" set="method"><f a="childID">
	<t path="UInt"/>
	<t path="UInt"/>
</f></get_accState>
		<get_accSelection public="1" set="method"><f a=""><c path="Array"><d/></c></f></get_accSelection>
		<get_accRole public="1" set="method"><f a="childID">
	<t path="UInt"/>
	<t path="UInt"/>
</f></get_accRole>
		<get_accName public="1" set="method"><f a="childID">
	<t path="UInt"/>
	<c path="String"/>
</f></get_accName>
		<get_accFocus public="1" set="method"><f a=""><t path="UInt"/></f></get_accFocus>
		<get_accDefaultAction public="1" set="method"><f a="childID">
	<t path="UInt"/>
	<c path="String"/>
</f></get_accDefaultAction>
		<getChildIDArray public="1" set="method"><f a=""><c path="Array"><d/></c></f></getChildIDArray>
		<accSelect public="1" set="method"><f a="operation:childID">
	<t path="UInt"/>
	<t path="UInt"/>
	<e path="Void"/>
</f></accSelect>
		<accLocation public="1" set="method"><f a="childID">
	<t path="UInt"/>
	<d/>
</f></accLocation>
		<accDoDefaultAction public="1" set="method"><f a="childID">
	<t path="UInt"/>
	<e path="Void"/>
</f></accDoDefaultAction>
		<stub public="1"><e path="Bool"/></stub>
		<errno public="1"><t path="UInt"/></errno>
		<new public="1" set="method"><f a=""><e path="Void"/></f></new>
	</class>
	<class path="flash.accessibility.AccessibilityProperties" params="" file="C:\Motion-Twin\Haxe/std/flash/accessibility/AccessibilityProperties.hx" extern="1">
		<silent public="1"><e path="Bool"/></silent>
		<shortcut public="1"><c path="String"/></shortcut>
		<noAutoLabeling public="1"><e path="Bool"/></noAutoLabeling>
		<name public="1"><c path="String"/></name>
		<forceSimple public="1"><e path="Bool"/></forceSimple>
		<description public="1"><c path="String"/></description>
		<new public="1" set="method"><f a=""><e path="Void"/></f></new>
	</class>
	<enum path="flash.display.ActionScriptVersion" params="" file="C:\Motion-Twin\Haxe/std/flash/display/ActionScriptVersion.hx">
		<ACTIONSCRIPT3/>
		<ACTIONSCRIPT2/>
		<meta><m n=":fakeEnum"><e>UInt</e></m></meta>
	</enum>
	<class path="flash.display.Bitmap" params="" file="C:\Motion-Twin\Haxe/std/flash/display/Bitmap.hx" extern="1">
		<extends path="flash.display.DisplayObject"/>
		<smoothing public="1"><e path="Bool"/></smoothing>
		<pixelSnapping public="1"><e path="flash.display.PixelSnapping"/></pixelSnapping>
		<bitmapData public="1"><c path="flash.display.BitmapData"/></bitmapData>
		<new public="1" set="method"><f a="?bitmapData:?pixelSnapping:?smoothing">
	<c path="flash.display.BitmapData"/>
	<e path="flash.display.PixelSnapping"/>
	<e path="Bool"/>
	<e path="Void"/>
</f></new>
	</class>
	<class path="flash.display.BitmapData" params="" file="C:\Motion-Twin\Haxe/std/flash/display/BitmapData.hx" extern="1">
		<implements path="flash.display.IBitmapDrawable"/>
		<unlock public="1" set="method"><f a="?changeRect">
	<c path="flash.geom.Rectangle"/>
	<e path="Void"/>
</f></unlock>
		<threshold public="1" set="method"><f a="sourceBitmapData:sourceRect:destPoint:operation:threshold:?color:?mask:?copySource">
	<c path="flash.display.BitmapData"/>
	<c path="flash.geom.Rectangle"/>
	<c path="flash.geom.Point"/>
	<c path="String"/>
	<t path="UInt"/>
	<t path="UInt"/>
	<t path="UInt"/>
	<e path="Bool"/>
	<t path="UInt"/>
</f></threshold>
		<setVector public="1" set="method">
			<f a="rect:inputVector">
				<c path="flash.geom.Rectangle"/>
				<c path="flash.Vector"><t path="UInt"/></c>
				<e path="Void"/>
			</f>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</setVector>
		<setPixels public="1" set="method"><f a="rect:inputByteArray">
	<c path="flash.geom.Rectangle"/>
	<c path="flash.utils.ByteArray"/>
	<e path="Void"/>
</f></setPixels>
		<setPixel32 public="1" set="method"><f a="x:y:color">
	<c path="Int"/>
	<c path="Int"/>
	<t path="UInt"/>
	<e path="Void"/>
</f></setPixel32>
		<setPixel public="1" set="method"><f a="x:y:color">
	<c path="Int"/>
	<c path="Int"/>
	<t path="UInt"/>
	<e path="Void"/>
</f></setPixel>
		<scroll public="1" set="method"><f a="x:y">
	<c path="Int"/>
	<c path="Int"/>
	<e path="Void"/>
</f></scroll>
		<pixelDissolve public="1" set="method"><f a="sourceBitmapData:sourceRect:destPoint:?randomSeed:?numPixels:?fillColor">
	<c path="flash.display.BitmapData"/>
	<c path="flash.geom.Rectangle"/>
	<c path="flash.geom.Point"/>
	<c path="Int"/>
	<c path="Int"/>
	<t path="UInt"/>
	<c path="Int"/>
</f></pixelDissolve>
		<perlinNoise public="1" set="method"><f a="baseX:baseY:numOctaves:randomSeed:stitch:fractalNoise:?channelOptions:?grayScale:?offsets">
	<c path="Float"/>
	<c path="Float"/>
	<t path="UInt"/>
	<c path="Int"/>
	<e path="Bool"/>
	<e path="Bool"/>
	<t path="UInt"/>
	<e path="Bool"/>
	<c path="Array"><c path="flash.geom.Point"/></c>
	<e path="Void"/>
</f></perlinNoise>
		<paletteMap public="1" set="method"><f a="sourceBitmapData:sourceRect:destPoint:?redArray:?greenArray:?blueArray:?alphaArray">
	<c path="flash.display.BitmapData"/>
	<c path="flash.geom.Rectangle"/>
	<c path="flash.geom.Point"/>
	<c path="Array"><c path="Int"/></c>
	<c path="Array"><c path="Int"/></c>
	<c path="Array"><c path="Int"/></c>
	<c path="Array"><c path="Int"/></c>
	<e path="Void"/>
</f></paletteMap>
		<noise public="1" set="method"><f a="randomSeed:?low:?high:?channelOptions:?grayScale">
	<c path="Int"/>
	<t path="UInt"/>
	<t path="UInt"/>
	<t path="UInt"/>
	<e path="Bool"/>
	<e path="Void"/>
</f></noise>
		<merge public="1" set="method"><f a="sourceBitmapData:sourceRect:destPoint:redMultiplier:greenMultiplier:blueMultiplier:alphaMultiplier">
	<c path="flash.display.BitmapData"/>
	<c path="flash.geom.Rectangle"/>
	<c path="flash.geom.Point"/>
	<t path="UInt"/>
	<t path="UInt"/>
	<t path="UInt"/>
	<t path="UInt"/>
	<e path="Void"/>
</f></merge>
		<lock public="1" set="method"><f a=""><e path="Void"/></f></lock>
		<hitTest public="1" set="method"><f a="firstPoint:firstAlphaThreshold:secondObject:?secondBitmapDataPoint:?secondAlphaThreshold">
	<c path="flash.geom.Point"/>
	<t path="UInt"/>
	<d/>
	<c path="flash.geom.Point"/>
	<t path="UInt"/>
	<e path="Bool"/>
</f></hitTest>
		<histogram public="1" set="method">
			<f a="?hRect">
				<c path="flash.geom.Rectangle"/>
				<c path="flash.Vector"><c path="flash.Vector"><c path="Float"/></c></c>
			</f>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</histogram>
		<getVector public="1" set="method">
			<f a="rect">
				<c path="flash.geom.Rectangle"/>
				<c path="flash.Vector"><t path="UInt"/></c>
			</f>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</getVector>
		<getPixels public="1" set="method"><f a="rect">
	<c path="flash.geom.Rectangle"/>
	<c path="flash.utils.ByteArray"/>
</f></getPixels>
		<getPixel32 public="1" set="method"><f a="x:y">
	<c path="Int"/>
	<c path="Int"/>
	<t path="UInt"/>
</f></getPixel32>
		<getPixel public="1" set="method"><f a="x:y">
	<c path="Int"/>
	<c path="Int"/>
	<t path="UInt"/>
</f></getPixel>
		<getColorBoundsRect public="1" set="method"><f a="mask:color:?findColor">
	<t path="UInt"/>
	<t path="UInt"/>
	<e path="Bool"/>
	<c path="flash.geom.Rectangle"/>
</f></getColorBoundsRect>
		<generateFilterRect public="1" set="method"><f a="sourceRect:filter">
	<c path="flash.geom.Rectangle"/>
	<c path="flash.filters.BitmapFilter"/>
	<c path="flash.geom.Rectangle"/>
</f></generateFilterRect>
		<floodFill public="1" set="method"><f a="x:y:color">
	<c path="Int"/>
	<c path="Int"/>
	<t path="UInt"/>
	<e path="Void"/>
</f></floodFill>
		<fillRect public="1" set="method"><f a="rect:color">
	<c path="flash.geom.Rectangle"/>
	<t path="UInt"/>
	<e path="Void"/>
</f></fillRect>
		<encode public="1">
			<f a="rect:compressor:?byteArray">
				<c path="flash.geom.Rectangle"/>
				<d/>
				<c path="flash.utils.ByteArray"/>
				<c path="flash.utils.ByteArray"/>
			</f>
			<meta><m n=":require"><e>flash11_3</e></m></meta>
		</encode>
		<drawWithQuality public="1">
			<f a="source:?matrix:?colorTransform:?blendMode:?clipRect:?smoothing:?quality">
				<c path="flash.display.IBitmapDrawable"/>
				<c path="flash.geom.Matrix"/>
				<c path="flash.geom.ColorTransform"/>
				<e path="flash.display.BlendMode"/>
				<c path="flash.geom.Rectangle"/>
				<e path="Bool"/>
				<e path="flash.display.StageQuality"/>
				<e path="Void"/>
			</f>
			<meta><m n=":require"><e>flash11_3</e></m></meta>
		</drawWithQuality>
		<draw public="1" set="method"><f a="source:?matrix:?colorTransform:?blendMode:?clipRect:?smoothing">
	<c path="flash.display.IBitmapDrawable"/>
	<c path="flash.geom.Matrix"/>
	<c path="flash.geom.ColorTransform"/>
	<e path="flash.display.BlendMode"/>
	<c path="flash.geom.Rectangle"/>
	<e path="Bool"/>
	<e path="Void"/>
</f></draw>
		<dispose public="1" set="method"><f a=""><e path="Void"/></f></dispose>
		<copyPixels public="1" set="method"><f a="sourceBitmapData:sourceRect:destPoint:?alphaBitmapData:?alphaPoint:?mergeAlpha">
	<c path="flash.display.BitmapData"/>
	<c path="flash.geom.Rectangle"/>
	<c path="flash.geom.Point"/>
	<c path="flash.display.BitmapData"/>
	<c path="flash.geom.Point"/>
	<e path="Bool"/>
	<e path="Void"/>
</f></copyPixels>
		<copyChannel public="1" set="method"><f a="sourceBitmapData:sourceRect:destPoint:sourceChannel:destChannel">
	<c path="flash.display.BitmapData"/>
	<c path="flash.geom.Rectangle"/>
	<c path="flash.geom.Point"/>
	<t path="UInt"/>
	<t path="UInt"/>
	<e path="Void"/>
</f></copyChannel>
		<compare public="1" set="method"><f a="otherBitmapData">
	<c path="flash.display.BitmapData"/>
	<d/>
</f></compare>
		<colorTransform public="1" set="method"><f a="rect:colorTransform">
	<c path="flash.geom.Rectangle"/>
	<c path="flash.geom.ColorTransform"/>
	<e path="Void"/>
</f></colorTransform>
		<clone public="1" set="method"><f a=""><c path="flash.display.BitmapData"/></f></clone>
		<applyFilter public="1" set="method"><f a="sourceBitmapData:sourceRect:destPoint:filter">
	<c path="flash.display.BitmapData"/>
	<c path="flash.geom.Rectangle"/>
	<c path="flash.geom.Point"/>
	<c path="flash.filters.BitmapFilter"/>
	<e path="Void"/>
</f></applyFilter>
		<width public="1" set="null"><c path="Int"/></width>
		<transparent public="1" set="null"><e path="Bool"/></transparent>
		<rect public="1" set="null"><c path="flash.geom.Rectangle"/></rect>
		<height public="1" set="null"><c path="Int"/></height>
		<new public="1" set="method"><f a="width:height:?transparent:?fillColor">
	<c path="Int"/>
	<c path="Int"/>
	<e path="Bool"/>
	<t path="UInt"/>
	<e path="Void"/>
</f></new>
	</class>
	<enum path="flash.display.BlendMode" params="" file="C:\Motion-Twin\Haxe/std/flash/display/BlendMode.hx">
		<SUBTRACT/>
		<SHADER/>
		<SCREEN/>
		<OVERLAY/>
		<NORMAL/>
		<MULTIPLY/>
		<LIGHTEN/>
		<LAYER/>
		<INVERT/>
		<HARDLIGHT/>
		<ERASE/>
		<DIFFERENCE/>
		<DARKEN/>
		<ALPHA/>
		<ADD/>
		<meta><m n=":fakeEnum"><e>String</e></m></meta>
	</enum>
	<enum path="flash.display.CapsStyle" params="" file="C:\Motion-Twin\Haxe/std/flash/display/CapsStyle.hx">
		<SQUARE/>
		<ROUND/>
		<NONE/>
		<meta><m n=":fakeEnum"><e>String</e></m></meta>
	</enum>
	<enum path="flash.display.ColorCorrection" params="" file="C:\Motion-Twin\Haxe/std/flash/display/ColorCorrection.hx">
		<ON/>
		<OFF/>
		<DEFAULT/>
		<meta>
			<m n=":fakeEnum"><e>String</e></m>
			<m n=":require"><e>flash10_1</e></m>
		</meta>
	</enum>
	<enum path="flash.display.ColorCorrectionSupport" params="" file="C:\Motion-Twin\Haxe/std/flash/display/ColorCorrectionSupport.hx">
		<UNSUPPORTED/>
		<DEFAULT_ON/>
		<DEFAULT_OFF/>
		<meta>
			<m n=":fakeEnum"><e>String</e></m>
			<m n=":require"><e>flash10_1</e></m>
		</meta>
	</enum>
	<class path="flash.display.FrameLabel" params="" file="C:\Motion-Twin\Haxe/std/flash/display/FrameLabel.hx" extern="1">
		<extends path="flash.events.EventDispatcher"/>
		<name public="1" set="null"><c path="String"/></name>
		<frame public="1" set="null"><c path="Int"/></frame>
		<new public="1" set="method"><f a="name:frame">
	<c path="String"/>
	<c path="Int"/>
	<e path="Void"/>
</f></new>
		<meta><m n=":final"/></meta>
	</class>
	<enum path="flash.display.GradientType" params="" file="C:\Motion-Twin\Haxe/std/flash/display/GradientType.hx">
		<RADIAL/>
		<LINEAR/>
		<meta><m n=":fakeEnum"><e>String</e></m></meta>
	</enum>
	<class path="flash.display.Graphics" params="" file="C:\Motion-Twin\Haxe\lib\nme/3,5,5/flash/display/Graphics.hx" extern="1">
		<drawTiles public="1" get="inline" set="null" line="30"><f a="sheet:tileData:?smooth:?flags">
	<c path="nme.display.Tilesheet"/>
	<c path="Array"><c path="Float"/></c>
	<e path="Bool"/>
	<c path="Int"/>
	<e path="Void"/>
</f></drawTiles>
		<moveTo public="1" set="method"><f a="x:y">
	<c path="Float"/>
	<c path="Float"/>
	<e path="Void"/>
</f></moveTo>
		<lineTo public="1" set="method"><f a="x:y">
	<c path="Float"/>
	<c path="Float"/>
	<e path="Void"/>
</f></lineTo>
		<lineStyle public="1" set="method"><f a="?thickness:?color:?alpha:?pixelHinting:?scaleMode:?caps:?joints:?miterLimit">
	<c path="Float"/>
	<t path="UInt"/>
	<c path="Float"/>
	<e path="Bool"/>
	<e path="flash.display.LineScaleMode"/>
	<e path="flash.display.CapsStyle"/>
	<e path="flash.display.JointStyle"/>
	<c path="Float"/>
	<e path="Void"/>
</f></lineStyle>
		<lineShaderStyle public="1" set="method">
			<f a="shader:?matrix">
				<c path="flash.display.Shader"/>
				<c path="flash.geom.Matrix"/>
				<e path="Void"/>
			</f>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</lineShaderStyle>
		<lineGradientStyle public="1" set="method"><f a="type:colors:alphas:ratios:?matrix:?spreadMethod:?interpolationMethod:?focalPointRatio">
	<e path="flash.display.GradientType"/>
	<c path="Array"><t path="UInt"/></c>
	<c path="Array"><d/></c>
	<c path="Array"><d/></c>
	<c path="flash.geom.Matrix"/>
	<e path="flash.display.SpreadMethod"/>
	<e path="flash.display.InterpolationMethod"/>
	<c path="Float"/>
	<e path="Void"/>
</f></lineGradientStyle>
		<lineBitmapStyle public="1" set="method">
			<f a="bitmap:?matrix:?repeat:?smooth">
				<c path="flash.display.BitmapData"/>
				<c path="flash.geom.Matrix"/>
				<e path="Bool"/>
				<e path="Bool"/>
				<e path="Void"/>
			</f>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</lineBitmapStyle>
		<endFill public="1" set="method"><f a=""><e path="Void"/></f></endFill>
		<drawTriangles public="1" set="method">
			<f a="vertices:?indices:?uvtData:?culling">
				<c path="flash.Vector"><c path="Float"/></c>
				<c path="flash.Vector"><c path="Int"/></c>
				<c path="flash.Vector"><c path="Float"/></c>
				<e path="flash.display.TriangleCulling"/>
				<e path="Void"/>
			</f>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</drawTriangles>
		<drawRoundRectComplex public="1" set="method"><f a="x:y:width:height:topLeftRadius:topRightRadius:bottomLeftRadius:bottomRightRadius">
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<e path="Void"/>
</f></drawRoundRectComplex>
		<drawRoundRect public="1" set="method"><f a="x:y:width:height:ellipseWidth:?ellipseHeight">
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<e path="Void"/>
</f></drawRoundRect>
		<drawRect public="1" set="method"><f a="x:y:width:height">
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<e path="Void"/>
</f></drawRect>
		<drawPath public="1" set="method">
			<f a="commands:data:?winding">
				<c path="flash.Vector"><c path="Int"/></c>
				<c path="flash.Vector"><c path="Float"/></c>
				<e path="flash.display.GraphicsPathWinding"/>
				<e path="Void"/>
			</f>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</drawPath>
		<drawGraphicsData public="1" set="method">
			<f a="graphicsData">
				<c path="flash.Vector"><c path="flash.display.IGraphicsData"/></c>
				<e path="Void"/>
			</f>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</drawGraphicsData>
		<drawEllipse public="1" set="method"><f a="x:y:width:height">
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<e path="Void"/>
</f></drawEllipse>
		<drawCircle public="1" set="method"><f a="x:y:radius">
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<e path="Void"/>
</f></drawCircle>
		<curveTo public="1" set="method"><f a="controlX:controlY:anchorX:anchorY">
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<e path="Void"/>
</f></curveTo>
		<cubicCurveTo public="1">
			<f a="controlX1:controlY1:controlX2:controlY2:anchorX:anchorY">
				<c path="Float"/>
				<c path="Float"/>
				<c path="Float"/>
				<c path="Float"/>
				<c path="Float"/>
				<c path="Float"/>
				<e path="Void"/>
			</f>
			<meta><m n=":require"><e>flash11</e></m></meta>
		</cubicCurveTo>
		<copyFrom public="1" set="method">
			<f a="sourceGraphics">
				<c path="flash.display.Graphics"/>
				<e path="Void"/>
			</f>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</copyFrom>
		<clear public="1" set="method"><f a=""><e path="Void"/></f></clear>
		<beginShaderFill public="1" set="method">
			<f a="shader:?matrix">
				<c path="flash.display.Shader"/>
				<c path="flash.geom.Matrix"/>
				<e path="Void"/>
			</f>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</beginShaderFill>
		<beginGradientFill public="1" set="method"><f a="type:colors:alphas:ratios:?matrix:?spreadMethod:?interpolationMethod:?focalPointRatio">
	<e path="flash.display.GradientType"/>
	<c path="Array"><t path="UInt"/></c>
	<c path="Array"><d/></c>
	<c path="Array"><d/></c>
	<c path="flash.geom.Matrix"/>
	<e path="flash.display.SpreadMethod"/>
	<e path="flash.display.InterpolationMethod"/>
	<c path="Float"/>
	<e path="Void"/>
</f></beginGradientFill>
		<beginFill public="1" set="method"><f a="color:?alpha">
	<t path="UInt"/>
	<c path="Float"/>
	<e path="Void"/>
</f></beginFill>
		<beginBitmapFill public="1" set="method"><f a="bitmap:?matrix:?repeat:?smooth">
	<c path="flash.display.BitmapData"/>
	<c path="flash.geom.Matrix"/>
	<e path="Bool"/>
	<e path="Bool"/>
	<e path="Void"/>
</f></beginBitmapFill>
		<new public="1" set="method"><f a=""><e path="Void"/></f></new>
		<meta><m n=":final"/></meta>
	</class>
	<enum path="flash.display.GraphicsPathWinding" params="" file="C:\Motion-Twin\Haxe/std/flash/display/GraphicsPathWinding.hx">
		<NON_ZERO/>
		<EVEN_ODD/>
		<meta><m n=":fakeEnum"><e>String</e></m></meta>
	</enum>
	<class path="flash.display.IGraphicsData" params="" file="C:\Motion-Twin\Haxe/std/flash/display/IGraphicsData.hx" extern="1" interface="1"/>
	<enum path="flash.display.InterpolationMethod" params="" file="C:\Motion-Twin\Haxe/std/flash/display/InterpolationMethod.hx">
		<RGB/>
		<LINEAR_RGB/>
		<meta><m n=":fakeEnum"><e>String</e></m></meta>
	</enum>
	<enum path="flash.display.JointStyle" params="" file="C:\Motion-Twin\Haxe/std/flash/display/JointStyle.hx">
		<ROUND/>
		<MITER/>
		<BEVEL/>
		<meta><m n=":fakeEnum"><e>String</e></m></meta>
	</enum>
	<enum path="flash.display.LineScaleMode" params="" file="C:\Motion-Twin\Haxe/std/flash/display/LineScaleMode.hx">
		<VERTICAL/>
		<NORMAL/>
		<NONE/>
		<HORIZONTAL/>
		<meta><m n=":fakeEnum"><e>String</e></m></meta>
	</enum>
	<class path="flash.display.Loader" params="" file="C:\Motion-Twin\Haxe/std/flash/display/Loader.hx" extern="1">
		<extends path="flash.display.DisplayObjectContainer"/>
		<unloadAndStop public="1" set="method">
			<f a="?gc">
				<e path="Bool"/>
				<e path="Void"/>
			</f>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</unloadAndStop>
		<unload public="1" set="method"><f a=""><e path="Void"/></f></unload>
		<loadBytes public="1" set="method"><f a="bytes:?context">
	<c path="flash.utils.ByteArray"/>
	<c path="flash.system.LoaderContext"/>
	<e path="Void"/>
</f></loadBytes>
		<load public="1" set="method"><f a="request:?context">
	<c path="flash.net.URLRequest"/>
	<c path="flash.system.LoaderContext"/>
	<e path="Void"/>
</f></load>
		<close public="1" set="method"><f a=""><e path="Void"/></f></close>
		<uncaughtErrorEvents public="1">
			<c path="flash.events.UncaughtErrorEvents"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</uncaughtErrorEvents>
		<contentLoaderInfo public="1" set="null"><c path="flash.display.LoaderInfo"/></contentLoaderInfo>
		<content public="1" set="null"><c path="flash.display.DisplayObject"/></content>
		<new public="1" set="method"><f a=""><e path="Void"/></f></new>
	</class>
	<class path="flash.display.LoaderInfo" params="" file="C:\Motion-Twin\Haxe/std/flash/display/LoaderInfo.hx" extern="1">
		<extends path="flash.events.EventDispatcher"/>
		<getLoaderInfoByDefinition public="1" set="method" static="1"><f a="object">
	<d/>
	<c path="flash.display.LoaderInfo"/>
</f></getLoaderInfoByDefinition>
		<width public="1" set="null"><c path="Int"/></width>
		<url public="1" set="null"><c path="String"/></url>
		<uncaughtErrorEvents public="1">
			<c path="flash.events.UncaughtErrorEvents"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</uncaughtErrorEvents>
		<swfVersion public="1" set="null"><t path="UInt"/></swfVersion>
		<sharedEvents public="1" set="null"><c path="flash.events.EventDispatcher"/></sharedEvents>
		<sameDomain public="1" set="null"><e path="Bool"/></sameDomain>
		<parentAllowsChild public="1" set="null"><e path="Bool"/></parentAllowsChild>
		<parameters public="1" set="null"><d><c path="String"/></d></parameters>
		<loaderURL public="1" set="null"><c path="String"/></loaderURL>
		<loader public="1" set="null"><c path="flash.display.Loader"/></loader>
		<isURLInaccessible public="1">
			<e path="Bool"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</isURLInaccessible>
		<height public="1" set="null"><c path="Int"/></height>
		<frameRate public="1" set="null"><c path="Float"/></frameRate>
		<contentType public="1" set="null"><c path="String"/></contentType>
		<content public="1" set="null"><c path="flash.display.DisplayObject"/></content>
		<childAllowsParent public="1" set="null"><e path="Bool"/></childAllowsParent>
		<bytesTotal public="1" set="null"><t path="UInt"/></bytesTotal>
		<bytesLoaded public="1" set="null"><t path="UInt"/></bytesLoaded>
		<bytes public="1" set="null"><c path="flash.utils.ByteArray"/></bytes>
		<applicationDomain public="1" set="null"><c path="flash.system.ApplicationDomain"/></applicationDomain>
		<actionScriptVersion public="1" set="null"><e path="flash.display.ActionScriptVersion"/></actionScriptVersion>
	</class>
	<class path="flash.display.NativeMenu" params="" file="C:\Motion-Twin\Haxe/std/flash/display/NativeMenu.hx" extern="1">
		<extends path="flash.events.EventDispatcher"/>
		<new public="1"><f a=""><e path="Void"/></f></new>
		<meta><m n=":require"><e>flash10_1</e></m></meta>
	</class>
	<enum path="flash.display.PixelSnapping" params="" file="C:\Motion-Twin\Haxe/std/flash/display/PixelSnapping.hx">
		<NEVER/>
		<AUTO/>
		<ALWAYS/>
		<meta><m n=":fakeEnum"><e>String</e></m></meta>
	</enum>
	<class path="flash.display.Scene" params="" file="C:\Motion-Twin\Haxe/std/flash/display/Scene.hx" extern="1">
		<numFrames public="1" set="null"><c path="Int"/></numFrames>
		<name public="1" set="null"><c path="String"/></name>
		<labels public="1" set="null"><c path="Array"><c path="flash.display.FrameLabel"/></c></labels>
		<new public="1" set="method"><f a="name:labels:numFrames">
	<c path="String"/>
	<c path="Array"><c path="flash.display.FrameLabel"/></c>
	<c path="Int"/>
	<e path="Void"/>
</f></new>
		<meta><m n=":final"/></meta>
	</class>
	<class path="flash.display.Shader" params="" file="C:\Motion-Twin\Haxe/std/flash/display/Shader.hx" extern="1">
		<precisionHint public="1"><e path="flash.display.ShaderPrecision"/></precisionHint>
		<data public="1"><c path="flash.display.ShaderData"/></data>
		<byteCode public="1" get="null"><c path="flash.utils.ByteArray"/></byteCode>
		<new public="1" set="method"><f a="?code">
	<c path="flash.utils.ByteArray"/>
	<e path="Void"/>
</f></new>
		<meta><m n=":require"><e>flash10</e></m></meta>
	</class>
	<class path="flash.display.ShaderData" params="" file="C:\Motion-Twin\Haxe/std/flash/display/ShaderData.hx" extern="1">
		<new public="1" set="method"><f a="byteCode">
	<c path="flash.utils.ByteArray"/>
	<e path="Void"/>
</f></new>
		<haxe_dynamic><d/></haxe_dynamic>
	</class>
	<enum path="flash.display.ShaderPrecision" params="" file="C:\Motion-Twin\Haxe/std/flash/display/ShaderPrecision.hx">
		<FULL/>
		<FAST/>
		<meta><m n=":fakeEnum"><e>String</e></m></meta>
	</enum>
	<class path="flash.display.Shape" params="" file="C:\Motion-Twin\Haxe/std/flash/display/Shape.hx" extern="1">
		<extends path="flash.display.DisplayObject"/>
		<graphics public="1" set="null"><c path="flash.display.Graphics"/></graphics>
		<new public="1" set="method"><f a=""><e path="Void"/></f></new>
	</class>
	<enum path="flash.display.SpreadMethod" params="" file="C:\Motion-Twin\Haxe/std/flash/display/SpreadMethod.hx">
		<REPEAT/>
		<REFLECT/>
		<PAD/>
		<meta><m n=":fakeEnum"><e>String</e></m></meta>
	</enum>
	<class path="flash.display.Stage" params="" file="C:\Motion-Twin\Haxe/std/flash/display/Stage.hx" extern="1">
		<extends path="flash.display.DisplayObjectContainer"/>
		<isFocusInaccessible public="1" set="method"><f a=""><e path="Bool"/></f></isFocusInaccessible>
		<invalidate public="1" set="method"><f a=""><e path="Void"/></f></invalidate>
		<wmodeGPU public="1">
			<e path="Bool"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</wmodeGPU>
		<stageWidth public="1"><c path="Int"/></stageWidth>
		<stageVideos public="1">
			<c path="flash.Vector"><c path="flash.media.StageVideo"/></c>
			<meta><m n=":require"><e>flash10_2</e></m></meta>
		</stageVideos>
		<stageHeight public="1"><c path="Int"/></stageHeight>
		<stageFocusRect public="1"><e path="Bool"/></stageFocusRect>
		<stage3Ds public="1">
			<c path="flash.Vector"><c path="flash.display.Stage3D"/></c>
			<meta><m n=":require"><e>flash11</e></m></meta>
		</stage3Ds>
		<softKeyboardRect public="1">
			<c path="flash.geom.Rectangle"/>
			<meta><m n=":require"><e>flash11</e></m></meta>
		</softKeyboardRect>
		<showDefaultContextMenu public="1"><e path="Bool"/></showDefaultContextMenu>
		<scaleMode public="1"><e path="flash.display.StageScaleMode"/></scaleMode>
		<quality public="1"><e path="flash.display.StageQuality"/></quality>
		<mouseLock public="1">
			<e path="Bool"/>
			<meta><m n=":require"><e>flash11_2</e></m></meta>
		</mouseLock>
		<fullScreenWidth public="1" set="null"><t path="UInt"/></fullScreenWidth>
		<fullScreenSourceRect public="1"><c path="flash.geom.Rectangle"/></fullScreenSourceRect>
		<fullScreenHeight public="1" set="null"><t path="UInt"/></fullScreenHeight>
		<frameRate public="1"><c path="Float"/></frameRate>
		<focus public="1"><c path="flash.display.InteractiveObject"/></focus>
		<displayState public="1"><e path="flash.display.StageDisplayState"/></displayState>
		<displayContextInfo public="1">
			<c path="String"/>
			<meta><m n=":require"><e>flash11</e></m></meta>
		</displayContextInfo>
		<colorCorrectionSupport public="1" set="null">
			<e path="flash.display.ColorCorrectionSupport"/>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</colorCorrectionSupport>
		<colorCorrection public="1">
			<e path="flash.display.ColorCorrection"/>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</colorCorrection>
		<color public="1">
			<t path="UInt"/>
			<meta><m n=":require"><e>flash10_2</e></m></meta>
		</color>
		<allowsFullScreenInteractive public="1">
			<e path="Bool"/>
			<meta><m n=":require"><e>flash11_3</e></m></meta>
		</allowsFullScreenInteractive>
		<allowsFullScreen public="1">
			<e path="Bool"/>
			<meta><m n=":require"><e>flash11</e></m></meta>
		</allowsFullScreen>
		<align public="1"><e path="flash.display.StageAlign"/></align>
	</class>
	<class path="flash.display.Stage3D" params="" file="C:\Motion-Twin\Haxe/std/flash/display/Stage3D.hx" extern="1">
		<extends path="flash.events.EventDispatcher"/>
		<requestContext3D public="1" set="method"><f a="?context3DRenderMode">
	<c path="String"/>
	<e path="Void"/>
</f></requestContext3D>
		<y public="1"><c path="Float"/></y>
		<x public="1"><c path="Float"/></x>
		<visible public="1"><e path="Bool"/></visible>
		<context3D public="1" set="null"><c path="flash.display3D.Context3D"/></context3D>
		<meta><m n=":require"><e>flash11</e></m></meta>
	</class>
	<enum path="flash.display.StageAlign" params="" file="C:\Motion-Twin\Haxe/std/flash/display/StageAlign.hx">
		<TOP_RIGHT/>
		<TOP_LEFT/>
		<TOP/>
		<RIGHT/>
		<LEFT/>
		<BOTTOM_RIGHT/>
		<BOTTOM_LEFT/>
		<BOTTOM/>
		<meta><m n=":fakeEnum"><e>String</e></m></meta>
	</enum>
	<enum path="flash.display.StageDisplayState" params="" file="C:\Motion-Twin\Haxe/std/flash/display/StageDisplayState.hx">
		<NORMAL/>
		<FULL_SCREEN_INTERACTIVE/>
		<FULL_SCREEN/>
		<meta><m n=":fakeEnum"><e>String</e></m></meta>
	</enum>
	<enum path="flash.display.StageQuality" params="" file="C:\Motion-Twin\Haxe/std/flash/display/StageQuality.hx">
		<MEDIUM/>
		<LOW/>
		<HIGH_8X8_LINEAR/>
		<HIGH_8X8/>
		<HIGH_16X16_LINEAR/>
		<HIGH_16X16/>
		<HIGH/>
		<BEST/>
		<meta><m n=":fakeEnum"><e>String</e></m></meta>
	</enum>
	<enum path="flash.display.StageScaleMode" params="" file="C:\Motion-Twin\Haxe/std/flash/display/StageScaleMode.hx">
		<SHOW_ALL/>
		<NO_SCALE/>
		<NO_BORDER/>
		<EXACT_FIT/>
		<meta><m n=":fakeEnum"><e>String</e></m></meta>
	</enum>
	<enum path="flash.display.TriangleCulling" params="" file="C:\Motion-Twin\Haxe/std/flash/display/TriangleCulling.hx">
		<POSITIVE/>
		<NONE/>
		<NEGATIVE/>
		<meta><m n=":fakeEnum"><e>String</e></m></meta>
	</enum>
	<class path="flash.display3D.Context3D" params="" file="C:\Motion-Twin\Haxe/std/flash/display3D/Context3D.hx" extern="1">
		<extends path="flash.events.EventDispatcher"/>
		<setVertexBufferAt public="1" set="method"><f a="index:buffer:?bufferOffset:?format">
	<c path="Int"/>
	<c path="flash.display3D.VertexBuffer3D"/>
	<c path="Int"/>
	<e path="flash.display3D.Context3DVertexBufferFormat"/>
	<e path="Void"/>
</f></setVertexBufferAt>
		<setTextureAt public="1" set="method"><f a="sampler:texture">
	<c path="Int"/>
	<c path="flash.display3D.textures.TextureBase"/>
	<e path="Void"/>
</f></setTextureAt>
		<setStencilReferenceValue public="1" set="method"><f a="referenceValue:?readMask:?writeMask">
	<t path="UInt"/>
	<t path="UInt"/>
	<t path="UInt"/>
	<e path="Void"/>
</f></setStencilReferenceValue>
		<setStencilActions public="1" set="method"><f a="?triangleFace:?compareMode:?actionOnBothPass:?actionOnDepthFail:?actionOnDepthPassStencilFail">
	<e path="flash.display3D.Context3DTriangleFace"/>
	<e path="flash.display3D.Context3DCompareMode"/>
	<e path="flash.display3D.Context3DStencilAction"/>
	<e path="flash.display3D.Context3DStencilAction"/>
	<e path="flash.display3D.Context3DStencilAction"/>
	<e path="Void"/>
</f></setStencilActions>
		<setScissorRectangle public="1" set="method"><f a="rectangle">
	<c path="flash.geom.Rectangle"/>
	<e path="Void"/>
</f></setScissorRectangle>
		<setRenderToTexture public="1" set="method"><f a="texture:?enableDepthAndStencil:?antiAlias:?surfaceSelector">
	<c path="flash.display3D.textures.TextureBase"/>
	<e path="Bool"/>
	<c path="Int"/>
	<c path="Int"/>
	<e path="Void"/>
</f></setRenderToTexture>
		<setRenderToBackBuffer public="1" set="method"><f a=""><e path="Void"/></f></setRenderToBackBuffer>
		<setProgramConstantsFromVector public="1" set="method"><f a="programType:firstRegister:data:?numRegisters">
	<e path="flash.display3D.Context3DProgramType"/>
	<c path="Int"/>
	<c path="flash.Vector"><c path="Float"/></c>
	<c path="Int"/>
	<e path="Void"/>
</f></setProgramConstantsFromVector>
		<setProgramConstantsFromMatrix public="1" set="method"><f a="programType:firstRegister:matrix:?transposedMatrix">
	<e path="flash.display3D.Context3DProgramType"/>
	<c path="Int"/>
	<c path="flash.geom.Matrix3D"/>
	<e path="Bool"/>
	<e path="Void"/>
</f></setProgramConstantsFromMatrix>
		<setProgramConstantsFromByteArray public="1">
			<f a="programType:firstRegister:numRegisters:data:byteArrayOffset">
				<e path="flash.display3D.Context3DProgramType"/>
				<c path="Int"/>
				<c path="Int"/>
				<c path="flash.utils.ByteArray"/>
				<t path="UInt"/>
				<e path="Void"/>
			</f>
			<meta><m n=":require"><e>flash11_2</e></m></meta>
		</setProgramConstantsFromByteArray>
		<setProgram public="1" set="method"><f a="program">
	<c path="flash.display3D.Program3D"/>
	<e path="Void"/>
</f></setProgram>
		<setDepthTest public="1" set="method"><f a="depthMask:passCompareMode">
	<e path="Bool"/>
	<e path="flash.display3D.Context3DCompareMode"/>
	<e path="Void"/>
</f></setDepthTest>
		<setCulling public="1" set="method"><f a="triangleFaceToCull">
	<e path="flash.display3D.Context3DTriangleFace"/>
	<e path="Void"/>
</f></setCulling>
		<setColorMask public="1" set="method"><f a="red:green:blue:alpha">
	<e path="Bool"/>
	<e path="Bool"/>
	<e path="Bool"/>
	<e path="Bool"/>
	<e path="Void"/>
</f></setColorMask>
		<setBlendFactors public="1" set="method"><f a="sourceFactor:destinationFactor">
	<e path="flash.display3D.Context3DBlendFactor"/>
	<e path="flash.display3D.Context3DBlendFactor"/>
	<e path="Void"/>
</f></setBlendFactors>
		<present public="1" set="method"><f a=""><e path="Void"/></f></present>
		<drawTriangles public="1" set="method"><f a="indexBuffer:?firstIndex:?numTriangles">
	<c path="flash.display3D.IndexBuffer3D"/>
	<c path="Int"/>
	<c path="Int"/>
	<e path="Void"/>
</f></drawTriangles>
		<drawToBitmapData public="1" set="method"><f a="destination">
	<c path="flash.display.BitmapData"/>
	<e path="Void"/>
</f></drawToBitmapData>
		<dispose public="1" set="method"><f a=""><e path="Void"/></f></dispose>
		<createVertexBuffer public="1" set="method"><f a="numVertices:data32PerVertex">
	<c path="Int"/>
	<c path="Int"/>
	<c path="flash.display3D.VertexBuffer3D"/>
</f></createVertexBuffer>
		<createTexture public="1" set="method"><f a="width:height:format:optimizeForRenderToTexture:?streamingLevels">
	<c path="Int"/>
	<c path="Int"/>
	<e path="flash.display3D.Context3DTextureFormat"/>
	<e path="Bool"/>
	<c path="Int"/>
	<c path="flash.display3D.textures.Texture"/>
</f></createTexture>
		<createProgram public="1" set="method"><f a=""><c path="flash.display3D.Program3D"/></f></createProgram>
		<createIndexBuffer public="1" set="method"><f a="numIndices">
	<c path="Int"/>
	<c path="flash.display3D.IndexBuffer3D"/>
</f></createIndexBuffer>
		<createCubeTexture public="1" set="method"><f a="size:format:optimizeForRenderToTexture:?streamingLevels">
	<c path="Int"/>
	<e path="flash.display3D.Context3DTextureFormat"/>
	<e path="Bool"/>
	<c path="Int"/>
	<c path="flash.display3D.textures.CubeTexture"/>
</f></createCubeTexture>
		<configureBackBuffer public="1" set="method"><f a="width:height:antiAlias:?enableDepthAndStencil">
	<c path="Int"/>
	<c path="Int"/>
	<c path="Int"/>
	<e path="Bool"/>
	<e path="Void"/>
</f></configureBackBuffer>
		<clear public="1" set="method"><f a="?red:?green:?blue:?alpha:?depth:?stencil:?mask">
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<t path="UInt"/>
	<t path="UInt"/>
	<e path="Void"/>
</f></clear>
		<enableErrorChecking public="1"><e path="Bool"/></enableErrorChecking>
		<driverInfo public="1" set="null"><c path="String"/></driverInfo>
		<meta><m n=":final"/></meta>
	</class>
	<enum path="flash.display3D.Context3DBlendFactor" params="" file="C:\Motion-Twin\Haxe/std/flash/display3D/Context3DBlendFactor.hx">
		<ZERO/>
		<SOURCE_COLOR/>
		<SOURCE_ALPHA/>
		<ONE_MINUS_SOURCE_COLOR/>
		<ONE_MINUS_SOURCE_ALPHA/>
		<ONE_MINUS_DESTINATION_COLOR/>
		<ONE_MINUS_DESTINATION_ALPHA/>
		<ONE/>
		<DESTINATION_COLOR/>
		<DESTINATION_ALPHA/>
		<meta><m n=":fakeEnum"><e>String</e></m></meta>
	</enum>
	<enum path="flash.display3D.Context3DCompareMode" params="" file="C:\Motion-Twin\Haxe/std/flash/display3D/Context3DCompareMode.hx">
		<NOT_EQUAL/>
		<NEVER/>
		<LESS_EQUAL/>
		<LESS/>
		<GREATER_EQUAL/>
		<GREATER/>
		<EQUAL/>
		<ALWAYS/>
		<meta><m n=":fakeEnum"><e>String</e></m></meta>
	</enum>
	<enum path="flash.display3D.Context3DProgramType" params="" file="C:\Motion-Twin\Haxe/std/flash/display3D/Context3DProgramType.hx">
		<VERTEX/>
		<FRAGMENT/>
		<meta><m n=":fakeEnum"><e>String</e></m></meta>
	</enum>
	<enum path="flash.display3D.Context3DStencilAction" params="" file="C:\Motion-Twin\Haxe/std/flash/display3D/Context3DStencilAction.hx">
		<ZERO/>
		<SET/>
		<KEEP/>
		<INVERT/>
		<INCREMENT_WRAP/>
		<INCREMENT_SATURATE/>
		<DECREMENT_WRAP/>
		<DECREMENT_SATURATE/>
		<meta><m n=":fakeEnum"><e>String</e></m></meta>
	</enum>
	<enum path="flash.display3D.Context3DTextureFormat" params="" file="C:\Motion-Twin\Haxe/std/flash/display3D/Context3DTextureFormat.hx">
		<COMPRESSED/>
		<BGRA/>
		<meta><m n=":fakeEnum"><e>String</e></m></meta>
	</enum>
	<enum path="flash.display3D.Context3DTriangleFace" params="" file="C:\Motion-Twin\Haxe/std/flash/display3D/Context3DTriangleFace.hx">
		<NONE/>
		<FRONT_AND_BACK/>
		<FRONT/>
		<BACK/>
		<meta><m n=":fakeEnum"><e>String</e></m></meta>
	</enum>
	<enum path="flash.display3D.Context3DVertexBufferFormat" params="" file="C:\Motion-Twin\Haxe/std/flash/display3D/Context3DVertexBufferFormat.hx">
		<FLOAT_4/>
		<FLOAT_3/>
		<FLOAT_2/>
		<FLOAT_1/>
		<BYTES_4/>
		<meta><m n=":fakeEnum"><e>String</e></m></meta>
	</enum>
	<class path="flash.display3D.IndexBuffer3D" params="" file="C:\Motion-Twin\Haxe/std/flash/display3D/IndexBuffer3D.hx" extern="1">
		<uploadFromVector public="1" set="method"><f a="data:startOffset:count">
	<c path="flash.Vector"><t path="UInt"/></c>
	<c path="Int"/>
	<c path="Int"/>
	<e path="Void"/>
</f></uploadFromVector>
		<uploadFromByteArray public="1" set="method"><f a="data:byteArrayOffset:startOffset:count">
	<c path="flash.utils.ByteArray"/>
	<c path="Int"/>
	<c path="Int"/>
	<c path="Int"/>
	<e path="Void"/>
</f></uploadFromByteArray>
		<dispose public="1" set="method"><f a=""><e path="Void"/></f></dispose>
		<meta><m n=":final"/></meta>
	</class>
	<class path="flash.display3D.Program3D" params="" file="C:\Motion-Twin\Haxe/std/flash/display3D/Program3D.hx" extern="1">
		<upload public="1" set="method"><f a="vertexProgram:fragmentProgram">
	<c path="flash.utils.ByteArray"/>
	<c path="flash.utils.ByteArray"/>
	<e path="Void"/>
</f></upload>
		<dispose public="1" set="method"><f a=""><e path="Void"/></f></dispose>
		<meta><m n=":final"/></meta>
	</class>
	<class path="flash.display3D.VertexBuffer3D" params="" file="C:\Motion-Twin\Haxe/std/flash/display3D/VertexBuffer3D.hx" extern="1">
		<uploadFromVector public="1" set="method"><f a="data:startVertex:numVertices">
	<c path="flash.Vector"><c path="Float"/></c>
	<c path="Int"/>
	<c path="Int"/>
	<e path="Void"/>
</f></uploadFromVector>
		<uploadFromByteArray public="1" set="method"><f a="data:byteArrayOffset:startVertex:numVertices">
	<c path="flash.utils.ByteArray"/>
	<c path="Int"/>
	<c path="Int"/>
	<c path="Int"/>
	<e path="Void"/>
</f></uploadFromByteArray>
		<dispose public="1" set="method"><f a=""><e path="Void"/></f></dispose>
	</class>
	<class path="flash.display3D.textures.TextureBase" params="" file="C:\Motion-Twin\Haxe/std/flash/display3D/textures/TextureBase.hx" extern="1">
		<extends path="flash.events.EventDispatcher"/>
		<dispose public="1" set="method"><f a=""><e path="Void"/></f></dispose>
	</class>
	<class path="flash.display3D.textures.CubeTexture" params="" file="C:\Motion-Twin\Haxe/std/flash/display3D/textures/CubeTexture.hx" extern="1">
		<extends path="flash.display3D.textures.TextureBase"/>
		<uploadFromByteArray public="1" set="method"><f a="data:byteArrayOffset:side:?miplevel">
	<c path="flash.utils.ByteArray"/>
	<t path="UInt"/>
	<t path="UInt"/>
	<t path="UInt"/>
	<e path="Void"/>
</f></uploadFromByteArray>
		<uploadFromBitmapData public="1" set="method"><f a="source:side:?miplevel">
	<c path="flash.display.BitmapData"/>
	<t path="UInt"/>
	<t path="UInt"/>
	<e path="Void"/>
</f></uploadFromBitmapData>
		<uploadCompressedTextureFromByteArray public="1" set="method"><f a="data:byteArrayOffset:?async">
	<c path="flash.utils.ByteArray"/>
	<t path="UInt"/>
	<e path="Bool"/>
	<e path="Void"/>
</f></uploadCompressedTextureFromByteArray>
		<meta><m n=":final"/></meta>
	</class>
	<class path="flash.display3D.textures.Texture" params="" file="C:\Motion-Twin\Haxe/std/flash/display3D/textures/Texture.hx" extern="1">
		<extends path="flash.display3D.textures.TextureBase"/>
		<uploadFromByteArray public="1" set="method"><f a="data:byteArrayOffset:?miplevel">
	<c path="flash.utils.ByteArray"/>
	<t path="UInt"/>
	<t path="UInt"/>
	<e path="Void"/>
</f></uploadFromByteArray>
		<uploadFromBitmapData public="1" set="method"><f a="source:?miplevel">
	<c path="flash.display.BitmapData"/>
	<t path="UInt"/>
	<e path="Void"/>
</f></uploadFromBitmapData>
		<uploadCompressedTextureFromByteArray public="1" set="method"><f a="data:byteArrayOffset:?async">
	<c path="flash.utils.ByteArray"/>
	<t path="UInt"/>
	<e path="Bool"/>
	<e path="Void"/>
</f></uploadCompressedTextureFromByteArray>
		<meta><m n=":final"/></meta>
	</class>
	<class path="flash.errors.Error" params="" file="C:\Motion-Twin\Haxe/std/flash/errors/Error.hx" extern="1">
		<length public="1" static="1"><c path="Int"/></length>
		<getErrorMessage public="1" set="method" static="1"><f a="index">
	<c path="Int"/>
	<c path="String"/>
</f></getErrorMessage>
		<throwError public="1" set="method" static="1"><f a="type:index:?p1:?p2:?p3:?p4:?p5">
	<c path="Class"><d/></c>
	<t path="UInt"/>
	<d/>
	<d/>
	<d/>
	<d/>
	<d/>
	<d/>
</f></throwError>
		<getStackTrace public="1" set="method"><f a=""><c path="String"/></f></getStackTrace>
		<name public="1"><d/></name>
		<message public="1"><d/></message>
		<errorID public="1" set="null"><c path="Int"/></errorID>
		<new public="1" set="method"><f a="?message:?id">
	<d/>
	<d/>
	<e path="Void"/>
</f></new>
		<haxe_dynamic><d/></haxe_dynamic>
	</class>
	<class path="flash.errors.TypeError" params="" file="C:\Motion-Twin\Haxe/std/flash/errors/TypeError.hx" extern="1">
		<extends path="flash.errors.Error"/>
		<meta><m n=":native"><e>TypeError</e></m></meta>
	</class>
	<class path="flash.events.TextEvent" params="" file="C:\Motion-Twin\Haxe/std/flash/events/TextEvent.hx" extern="1">
		<extends path="flash.events.Event"/>
		<LINK public="1" static="1"><c path="String"/></LINK>
		<TEXT_INPUT public="1" static="1"><c path="String"/></TEXT_INPUT>
		<text public="1"><c path="String"/></text>
		<new public="1" set="method"><f a="type:?bubbles:?cancelable:?text">
	<c path="String"/>
	<e path="Bool"/>
	<e path="Bool"/>
	<c path="String"/>
	<e path="Void"/>
</f></new>
	</class>
	<class path="flash.events.ErrorEvent" params="" file="C:\Motion-Twin\Haxe/std/flash/events/ErrorEvent.hx" extern="1">
		<extends path="flash.events.TextEvent"/>
		<ERROR public="1" static="1"><c path="String"/></ERROR>
		<errorID public="1">
			<c path="Int"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</errorID>
		<new public="1" set="method"><f a="type:?bubbles:?cancelable:?text:?id">
	<c path="String"/>
	<e path="Bool"/>
	<e path="Bool"/>
	<c path="String"/>
	<c path="Int"/>
	<e path="Void"/>
</f></new>
	</class>
	<enum path="flash.events.EventPhase" params="" file="C:\Motion-Twin\Haxe/std/flash/events/EventPhase.hx">
		<CAPTURING_PHASE/>
		<BUBBLING_PHASE/>
		<AT_TARGET/>
		<meta><m n=":fakeEnum"><e>UInt</e></m></meta>
	</enum>
	<class path="flash.events.IOErrorEvent" params="" file="C:\Motion-Twin\Haxe/std/flash/events/IOErrorEvent.hx" extern="1">
		<extends path="flash.events.ErrorEvent"/>
		<DISK_ERROR public="1" static="1"><c path="String"/></DISK_ERROR>
		<IO_ERROR public="1" static="1"><c path="String"/></IO_ERROR>
		<NETWORK_ERROR public="1" static="1"><c path="String"/></NETWORK_ERROR>
		<VERIFY_ERROR public="1" static="1"><c path="String"/></VERIFY_ERROR>
		<new public="1" set="method"><f a="type:?bubbles:?cancelable:?text:?id">
	<c path="String"/>
	<e path="Bool"/>
	<e path="Bool"/>
	<c path="String"/>
	<c path="Int"/>
	<e path="Void"/>
</f></new>
	</class>
	<class path="flash.events.KeyboardEvent" params="" file="C:\Motion-Twin\Haxe/std/flash/events/KeyboardEvent.hx" extern="1">
		<extends path="flash.events.Event"/>
		<KEY_DOWN public="1" static="1"><c path="String"/></KEY_DOWN>
		<KEY_UP public="1" static="1"><c path="String"/></KEY_UP>
		<updateAfterEvent public="1" set="method"><f a=""><e path="Void"/></f></updateAfterEvent>
		<shiftKey public="1"><e path="Bool"/></shiftKey>
		<keyLocation public="1"><e path="flash.ui.KeyLocation"/></keyLocation>
		<keyCode public="1"><t path="UInt"/></keyCode>
		<ctrlKey public="1"><e path="Bool"/></ctrlKey>
		<charCode public="1"><t path="UInt"/></charCode>
		<altKey public="1"><e path="Bool"/></altKey>
		<new public="1" set="method"><f a="type:?bubbles:?cancelable:?charCodeValue:?keyCodeValue:?keyLocationValue:?ctrlKeyValue:?altKeyValue:?shiftKeyValue">
	<c path="String"/>
	<e path="Bool"/>
	<e path="Bool"/>
	<t path="UInt"/>
	<t path="UInt"/>
	<e path="flash.ui.KeyLocation"/>
	<e path="Bool"/>
	<e path="Bool"/>
	<e path="Bool"/>
	<e path="Void"/>
</f></new>
	</class>
	<class path="flash.events.MouseEvent" params="" file="C:\Motion-Twin\Haxe/std/flash/events/MouseEvent.hx" extern="1">
		<extends path="flash.events.Event"/>
		<CLICK public="1" static="1"><c path="String"/></CLICK>
		<CONTEXT_MENU public="1" static="1">
			<c path="String"/>
			<meta><m n=":require"><e>flash11_2</e></m></meta>
		</CONTEXT_MENU>
		<DOUBLE_CLICK public="1" static="1"><c path="String"/></DOUBLE_CLICK>
		<MIDDLE_CLICK public="1" static="1">
			<c path="String"/>
			<meta><m n=":require"><e>flash11_2</e></m></meta>
		</MIDDLE_CLICK>
		<MIDDLE_MOUSE_DOWN public="1" static="1">
			<c path="String"/>
			<meta><m n=":require"><e>flash11_2</e></m></meta>
		</MIDDLE_MOUSE_DOWN>
		<MIDDLE_MOUSE_UP public="1" static="1">
			<c path="String"/>
			<meta><m n=":require"><e>flash11_2</e></m></meta>
		</MIDDLE_MOUSE_UP>
		<MOUSE_DOWN public="1" static="1"><c path="String"/></MOUSE_DOWN>
		<MOUSE_MOVE public="1" static="1"><c path="String"/></MOUSE_MOVE>
		<MOUSE_OUT public="1" static="1"><c path="String"/></MOUSE_OUT>
		<MOUSE_OVER public="1" static="1"><c path="String"/></MOUSE_OVER>
		<MOUSE_UP public="1" static="1"><c path="String"/></MOUSE_UP>
		<MOUSE_WHEEL public="1" static="1"><c path="String"/></MOUSE_WHEEL>
		<RELEASE_OUTSIDE public="1" static="1">
			<c path="String"/>
			<meta><m n=":require"><e>flash11_3</e></m></meta>
		</RELEASE_OUTSIDE>
		<RIGHT_CLICK public="1" static="1">
			<c path="String"/>
			<meta><m n=":require"><e>flash11_2</e></m></meta>
		</RIGHT_CLICK>
		<RIGHT_MOUSE_DOWN public="1" static="1">
			<c path="String"/>
			<meta><m n=":require"><e>flash11_2</e></m></meta>
		</RIGHT_MOUSE_DOWN>
		<RIGHT_MOUSE_UP public="1" static="1">
			<c path="String"/>
			<meta><m n=":require"><e>flash11_2</e></m></meta>
		</RIGHT_MOUSE_UP>
		<ROLL_OUT public="1" static="1"><c path="String"/></ROLL_OUT>
		<ROLL_OVER public="1" static="1"><c path="String"/></ROLL_OVER>
		<updateAfterEvent public="1" set="method"><f a=""><e path="Void"/></f></updateAfterEvent>
		<stageY public="1" set="null"><c path="Float"/></stageY>
		<stageX public="1" set="null"><c path="Float"/></stageX>
		<shiftKey public="1"><e path="Bool"/></shiftKey>
		<relatedObject public="1"><c path="flash.display.InteractiveObject"/></relatedObject>
		<movementY public="1">
			<c path="Float"/>
			<meta><m n=":require"><e>flash11_2</e></m></meta>
		</movementY>
		<movementX public="1">
			<c path="Float"/>
			<meta><m n=":require"><e>flash11_2</e></m></meta>
		</movementX>
		<localY public="1"><c path="Float"/></localY>
		<localX public="1"><c path="Float"/></localX>
		<isRelatedObjectInaccessible public="1">
			<e path="Bool"/>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</isRelatedObjectInaccessible>
		<delta public="1"><c path="Int"/></delta>
		<ctrlKey public="1"><e path="Bool"/></ctrlKey>
		<buttonDown public="1"><e path="Bool"/></buttonDown>
		<altKey public="1"><e path="Bool"/></altKey>
		<new public="1" set="method"><f a="type:?bubbles:?cancelable:?localX:?localY:?relatedObject:?ctrlKey:?altKey:?shiftKey:?buttonDown:?delta">
	<c path="String"/>
	<e path="Bool"/>
	<e path="Bool"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="flash.display.InteractiveObject"/>
	<e path="Bool"/>
	<e path="Bool"/>
	<e path="Bool"/>
	<e path="Bool"/>
	<c path="Int"/>
	<e path="Void"/>
</f></new>
	</class>
	<class path="flash.events.ProgressEvent" params="" file="C:\Motion-Twin\Haxe/std/flash/events/ProgressEvent.hx" extern="1">
		<extends path="flash.events.Event"/>
		<PROGRESS public="1" static="1"><c path="String"/></PROGRESS>
		<SOCKET_DATA public="1" static="1"><c path="String"/></SOCKET_DATA>
		<bytesTotal public="1"><c path="Float"/></bytesTotal>
		<bytesLoaded public="1"><c path="Float"/></bytesLoaded>
		<new public="1" set="method"><f a="type:?bubbles:?cancelable:?bytesLoaded:?bytesTotal">
	<c path="String"/>
	<e path="Bool"/>
	<e path="Bool"/>
	<c path="Float"/>
	<c path="Float"/>
	<e path="Void"/>
</f></new>
	</class>
	<class path="flash.events.SecurityErrorEvent" params="" file="C:\Motion-Twin\Haxe/std/flash/events/SecurityErrorEvent.hx" extern="1">
		<extends path="flash.events.ErrorEvent"/>
		<SECURITY_ERROR public="1" static="1"><c path="String"/></SECURITY_ERROR>
		<new public="1" set="method"><f a="type:?bubbles:?cancelable:?text:?id">
	<c path="String"/>
	<e path="Bool"/>
	<e path="Bool"/>
	<c path="String"/>
	<c path="Int"/>
	<e path="Void"/>
</f></new>
	</class>
	<class path="flash.events.UncaughtErrorEvents" params="" file="C:\Motion-Twin\Haxe/std/flash/events/UncaughtErrorEvents.hx" extern="1">
		<extends path="flash.events.EventDispatcher"/>
		<new public="1"><f a=""><e path="Void"/></f></new>
		<meta><m n=":require"><e>flash10_1</e></m></meta>
	</class>
	<class path="flash.external.ExternalInterface" params="" file="C:\Motion-Twin\Haxe/std/flash/external/ExternalInterface.hx" extern="1">
		<available public="1" set="null" static="1"><e path="Bool"/></available>
		<marshallExceptions public="1" static="1"><e path="Bool"/></marshallExceptions>
		<objectID public="1" set="null" static="1"><c path="String"/></objectID>
		<addCallback public="1" set="method" static="1"><f a="functionName:closure">
	<c path="String"/>
	<d/>
	<e path="Void"/>
</f></addCallback>
		<call public="1" set="method" static="1"><f a="functionName:?p1:?p2:?p3:?p4:?p5">
	<c path="String"/>
	<d/>
	<d/>
	<d/>
	<d/>
	<d/>
	<d/>
</f></call>
	</class>
	<class path="flash.filters.BitmapFilter" params="" file="C:\Motion-Twin\Haxe/std/flash/filters/BitmapFilter.hx" extern="1">
		<clone public="1" set="method"><f a=""><c path="flash.filters.BitmapFilter"/></f></clone>
		<new public="1" set="method"><f a=""><e path="Void"/></f></new>
	</class>
	<class path="flash.geom.ColorTransform" params="" file="C:\Motion-Twin\Haxe/std/flash/geom/ColorTransform.hx" extern="1">
		<toString public="1" set="method"><f a=""><c path="String"/></f></toString>
		<concat public="1" set="method"><f a="second">
	<c path="flash.geom.ColorTransform"/>
	<e path="Void"/>
</f></concat>
		<redOffset public="1"><c path="Float"/></redOffset>
		<redMultiplier public="1"><c path="Float"/></redMultiplier>
		<greenOffset public="1"><c path="Float"/></greenOffset>
		<greenMultiplier public="1"><c path="Float"/></greenMultiplier>
		<color public="1"><t path="UInt"/></color>
		<blueOffset public="1"><c path="Float"/></blueOffset>
		<blueMultiplier public="1"><c path="Float"/></blueMultiplier>
		<alphaOffset public="1"><c path="Float"/></alphaOffset>
		<alphaMultiplier public="1"><c path="Float"/></alphaMultiplier>
		<new public="1" set="method"><f a="?redMultiplier:?greenMultiplier:?blueMultiplier:?alphaMultiplier:?redOffset:?greenOffset:?blueOffset:?alphaOffset">
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<e path="Void"/>
</f></new>
	</class>
	<class path="flash.geom.Matrix" params="" file="C:\Motion-Twin\Haxe/std/flash/geom/Matrix.hx" extern="1">
		<translate public="1" set="method"><f a="dx:dy">
	<c path="Float"/>
	<c path="Float"/>
	<e path="Void"/>
</f></translate>
		<transformPoint public="1" set="method"><f a="point">
	<c path="flash.geom.Point"/>
	<c path="flash.geom.Point"/>
</f></transformPoint>
		<toString public="1" set="method"><f a=""><c path="String"/></f></toString>
		<setTo public="1">
			<f a="aa:ba:ca:da:txa:tya">
				<c path="Float"/>
				<c path="Float"/>
				<c path="Float"/>
				<c path="Float"/>
				<c path="Float"/>
				<c path="Float"/>
				<e path="Void"/>
			</f>
			<meta><m n=":require"><e>flash11</e></m></meta>
		</setTo>
		<scale public="1" set="method"><f a="sx:sy">
	<c path="Float"/>
	<c path="Float"/>
	<e path="Void"/>
</f></scale>
		<rotate public="1" set="method"><f a="angle">
	<c path="Float"/>
	<e path="Void"/>
</f></rotate>
		<invert public="1" set="method"><f a=""><e path="Void"/></f></invert>
		<identity public="1" set="method"><f a=""><e path="Void"/></f></identity>
		<deltaTransformPoint public="1" set="method"><f a="point">
	<c path="flash.geom.Point"/>
	<c path="flash.geom.Point"/>
</f></deltaTransformPoint>
		<createGradientBox public="1" set="method"><f a="width:height:?rotation:?tx:?ty">
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<e path="Void"/>
</f></createGradientBox>
		<createBox public="1" set="method"><f a="scaleX:scaleY:?rotation:?tx:?ty">
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<e path="Void"/>
</f></createBox>
		<copyRowTo public="1">
			<f a="row:vector3D">
				<t path="UInt"/>
				<c path="flash.geom.Vector3D"/>
				<e path="Void"/>
			</f>
			<meta><m n=":require"><e>flash11</e></m></meta>
		</copyRowTo>
		<copyRowFrom public="1">
			<f a="row:vector3D">
				<t path="UInt"/>
				<c path="flash.geom.Vector3D"/>
				<e path="Void"/>
			</f>
			<meta><m n=":require"><e>flash11</e></m></meta>
		</copyRowFrom>
		<copyFrom public="1">
			<f a="sourceMatrix">
				<c path="flash.geom.Matrix"/>
				<e path="Void"/>
			</f>
			<meta><m n=":require"><e>flash11</e></m></meta>
		</copyFrom>
		<copyColumnTo public="1">
			<f a="column:vector3D">
				<t path="UInt"/>
				<c path="flash.geom.Vector3D"/>
				<e path="Void"/>
			</f>
			<meta><m n=":require"><e>flash11</e></m></meta>
		</copyColumnTo>
		<copyColumnFrom public="1">
			<f a="column:vector3D">
				<t path="UInt"/>
				<c path="flash.geom.Vector3D"/>
				<e path="Void"/>
			</f>
			<meta><m n=":require"><e>flash11</e></m></meta>
		</copyColumnFrom>
		<concat public="1" set="method"><f a="m">
	<c path="flash.geom.Matrix"/>
	<e path="Void"/>
</f></concat>
		<clone public="1" set="method"><f a=""><c path="flash.geom.Matrix"/></f></clone>
		<ty public="1"><c path="Float"/></ty>
		<tx public="1"><c path="Float"/></tx>
		<d public="1"><c path="Float"/></d>
		<c public="1"><c path="Float"/></c>
		<b public="1"><c path="Float"/></b>
		<a public="1"><c path="Float"/></a>
		<new public="1" set="method"><f a="?a:?b:?c:?d:?tx:?ty">
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<e path="Void"/>
</f></new>
	</class>
	<class path="flash.geom.Matrix3D" params="" file="C:\Motion-Twin\Haxe/std/flash/geom/Matrix3D.hx" extern="1">
		<interpolate public="1" set="method" static="1"><f a="thisMat:toMat:percent">
	<c path="flash.geom.Matrix3D"/>
	<c path="flash.geom.Matrix3D"/>
	<c path="Float"/>
	<c path="flash.geom.Matrix3D"/>
</f></interpolate>
		<transpose public="1" set="method"><f a=""><e path="Void"/></f></transpose>
		<transformVectors public="1" set="method"><f a="vin:vout">
	<c path="flash.Vector"><c path="Float"/></c>
	<c path="flash.Vector"><c path="Float"/></c>
	<e path="Void"/>
</f></transformVectors>
		<transformVector public="1" set="method"><f a="v">
	<c path="flash.geom.Vector3D"/>
	<c path="flash.geom.Vector3D"/>
</f></transformVector>
		<recompose public="1" set="method"><f a="components:?orientationStyle">
	<c path="flash.Vector"><c path="flash.geom.Vector3D"/></c>
	<e path="flash.geom.Orientation3D"/>
	<e path="Bool"/>
</f></recompose>
		<prependTranslation public="1" set="method"><f a="x:y:z">
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<e path="Void"/>
</f></prependTranslation>
		<prependScale public="1" set="method"><f a="xScale:yScale:zScale">
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<e path="Void"/>
</f></prependScale>
		<prependRotation public="1" set="method"><f a="degrees:axis:?pivotPoint">
	<c path="Float"/>
	<c path="flash.geom.Vector3D"/>
	<c path="flash.geom.Vector3D"/>
	<e path="Void"/>
</f></prependRotation>
		<prepend public="1" set="method"><f a="rhs">
	<c path="flash.geom.Matrix3D"/>
	<e path="Void"/>
</f></prepend>
		<pointAt public="1" set="method"><f a="pos:?at:?up">
	<c path="flash.geom.Vector3D"/>
	<c path="flash.geom.Vector3D"/>
	<c path="flash.geom.Vector3D"/>
	<e path="Void"/>
</f></pointAt>
		<invert public="1" set="method"><f a=""><e path="Bool"/></f></invert>
		<interpolateTo public="1" set="method"><f a="toMat:percent">
	<c path="flash.geom.Matrix3D"/>
	<c path="Float"/>
	<e path="Void"/>
</f></interpolateTo>
		<identity public="1" set="method"><f a=""><e path="Void"/></f></identity>
		<deltaTransformVector public="1" set="method"><f a="v">
	<c path="flash.geom.Vector3D"/>
	<c path="flash.geom.Vector3D"/>
</f></deltaTransformVector>
		<decompose public="1" set="method"><f a="?orientationStyle">
	<e path="flash.geom.Orientation3D"/>
	<c path="flash.Vector"><c path="flash.geom.Vector3D"/></c>
</f></decompose>
		<copyToMatrix3D public="1">
			<f a="dest">
				<c path="flash.geom.Matrix3D"/>
				<e path="Void"/>
			</f>
			<meta><m n=":require"><e>flash11</e></m></meta>
		</copyToMatrix3D>
		<copyRowTo public="1">
			<f a="row:vector3D">
				<t path="UInt"/>
				<c path="flash.geom.Vector3D"/>
				<e path="Void"/>
			</f>
			<meta><m n=":require"><e>flash11</e></m></meta>
		</copyRowTo>
		<copyRowFrom public="1">
			<f a="row:vector3D">
				<t path="UInt"/>
				<c path="flash.geom.Vector3D"/>
				<e path="Void"/>
			</f>
			<meta><m n=":require"><e>flash11</e></m></meta>
		</copyRowFrom>
		<copyRawDataTo public="1">
			<f a="vector:?index:?transpose">
				<c path="flash.Vector"><c path="Float"/></c>
				<t path="UInt"/>
				<e path="Bool"/>
				<e path="Void"/>
			</f>
			<meta><m n=":require"><e>flash11</e></m></meta>
		</copyRawDataTo>
		<copyRawDataFrom public="1">
			<f a="vector:?index:?transpose">
				<c path="flash.Vector"><c path="Float"/></c>
				<t path="UInt"/>
				<e path="Bool"/>
				<e path="Void"/>
			</f>
			<meta><m n=":require"><e>flash11</e></m></meta>
		</copyRawDataFrom>
		<copyFrom public="1">
			<f a="sourceMatrix3D">
				<c path="flash.geom.Matrix3D"/>
				<e path="Void"/>
			</f>
			<meta><m n=":require"><e>flash11</e></m></meta>
		</copyFrom>
		<copyColumnTo public="1">
			<f a="column:vector3D">
				<t path="UInt"/>
				<c path="flash.geom.Vector3D"/>
				<e path="Void"/>
			</f>
			<meta><m n=":require"><e>flash11</e></m></meta>
		</copyColumnTo>
		<copyColumnFrom public="1">
			<f a="column:vector3D">
				<t path="UInt"/>
				<c path="flash.geom.Vector3D"/>
				<e path="Void"/>
			</f>
			<meta><m n=":require"><e>flash11</e></m></meta>
		</copyColumnFrom>
		<clone public="1" set="method"><f a=""><c path="flash.geom.Matrix3D"/></f></clone>
		<appendTranslation public="1" set="method"><f a="x:y:z">
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<e path="Void"/>
</f></appendTranslation>
		<appendScale public="1" set="method"><f a="xScale:yScale:zScale">
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<e path="Void"/>
</f></appendScale>
		<appendRotation public="1" set="method"><f a="degrees:axis:?pivotPoint">
	<c path="Float"/>
	<c path="flash.geom.Vector3D"/>
	<c path="flash.geom.Vector3D"/>
	<e path="Void"/>
</f></appendRotation>
		<append public="1" set="method"><f a="lhs">
	<c path="flash.geom.Matrix3D"/>
	<e path="Void"/>
</f></append>
		<rawData public="1"><c path="flash.Vector"><c path="Float"/></c></rawData>
		<position public="1"><c path="flash.geom.Vector3D"/></position>
		<determinant public="1" set="null"><c path="Float"/></determinant>
		<new public="1" set="method"><f a="?v">
	<c path="flash.Vector"><c path="Float"/></c>
	<e path="Void"/>
</f></new>
		<meta><m n=":require"><e>flash10</e></m></meta>
	</class>
	<enum path="flash.geom.Orientation3D" params="" file="C:\Motion-Twin\Haxe/std/flash/geom/Orientation3D.hx">
		<QUATERNION/>
		<EULER_ANGLES/>
		<AXIS_ANGLE/>
		<meta><m n=":fakeEnum"><e>String</e></m></meta>
	</enum>
	<class path="flash.geom.PerspectiveProjection" params="" file="C:\Motion-Twin\Haxe/std/flash/geom/PerspectiveProjection.hx" extern="1">
		<toMatrix3D public="1" set="method"><f a=""><c path="flash.geom.Matrix3D"/></f></toMatrix3D>
		<projectionCenter public="1"><c path="flash.geom.Point"/></projectionCenter>
		<focalLength public="1"><c path="Float"/></focalLength>
		<fieldOfView public="1"><c path="Float"/></fieldOfView>
		<new public="1" set="method"><f a=""><e path="Void"/></f></new>
		<meta><m n=":require"><e>flash10</e></m></meta>
	</class>
	<class path="flash.geom.Point" params="" file="C:\Motion-Twin\Haxe/std/flash/geom/Point.hx" extern="1">
		<distance public="1" set="method" static="1"><f a="pt1:pt2">
	<c path="flash.geom.Point"/>
	<c path="flash.geom.Point"/>
	<c path="Float"/>
</f></distance>
		<interpolate public="1" set="method" static="1"><f a="pt1:pt2:f">
	<c path="flash.geom.Point"/>
	<c path="flash.geom.Point"/>
	<c path="Float"/>
	<c path="flash.geom.Point"/>
</f></interpolate>
		<polar public="1" set="method" static="1"><f a="len:angle">
	<c path="Float"/>
	<c path="Float"/>
	<c path="flash.geom.Point"/>
</f></polar>
		<toString public="1" set="method"><f a=""><c path="String"/></f></toString>
		<subtract public="1" set="method"><f a="v">
	<c path="flash.geom.Point"/>
	<c path="flash.geom.Point"/>
</f></subtract>
		<setTo public="1">
			<f a="xa:ya">
				<c path="Float"/>
				<c path="Float"/>
				<e path="Void"/>
			</f>
			<meta><m n=":require"><e>flash11</e></m></meta>
		</setTo>
		<offset public="1" set="method"><f a="dx:dy">
	<c path="Float"/>
	<c path="Float"/>
	<e path="Void"/>
</f></offset>
		<normalize public="1" set="method"><f a="thickness">
	<c path="Float"/>
	<e path="Void"/>
</f></normalize>
		<equals public="1" set="method"><f a="toCompare">
	<c path="flash.geom.Point"/>
	<e path="Bool"/>
</f></equals>
		<copyFrom public="1">
			<f a="sourcePoint">
				<c path="flash.geom.Point"/>
				<e path="Void"/>
			</f>
			<meta><m n=":require"><e>flash11</e></m></meta>
		</copyFrom>
		<clone public="1" set="method"><f a=""><c path="flash.geom.Point"/></f></clone>
		<add public="1" set="method"><f a="v">
	<c path="flash.geom.Point"/>
	<c path="flash.geom.Point"/>
</f></add>
		<y public="1"><c path="Float"/></y>
		<x public="1"><c path="Float"/></x>
		<length public="1" set="null"><c path="Float"/></length>
		<new public="1" set="method"><f a="?x:?y">
	<c path="Float"/>
	<c path="Float"/>
	<e path="Void"/>
</f></new>
	</class>
	<class path="flash.geom.Rectangle" params="" file="C:\Motion-Twin\Haxe/std/flash/geom/Rectangle.hx" extern="1">
		<union public="1" set="method"><f a="toUnion">
	<c path="flash.geom.Rectangle"/>
	<c path="flash.geom.Rectangle"/>
</f></union>
		<toString public="1" set="method"><f a=""><c path="String"/></f></toString>
		<setTo public="1">
			<f a="xa:ya:widtha:heighta">
				<c path="Float"/>
				<c path="Float"/>
				<c path="Float"/>
				<c path="Float"/>
				<e path="Void"/>
			</f>
			<meta><m n=":require"><e>flash11</e></m></meta>
		</setTo>
		<setEmpty public="1" set="method"><f a=""><e path="Void"/></f></setEmpty>
		<offsetPoint public="1" set="method"><f a="point">
	<c path="flash.geom.Point"/>
	<e path="Void"/>
</f></offsetPoint>
		<offset public="1" set="method"><f a="dx:dy">
	<c path="Float"/>
	<c path="Float"/>
	<e path="Void"/>
</f></offset>
		<isEmpty public="1" set="method"><f a=""><e path="Bool"/></f></isEmpty>
		<intersects public="1" set="method"><f a="toIntersect">
	<c path="flash.geom.Rectangle"/>
	<e path="Bool"/>
</f></intersects>
		<intersection public="1" set="method"><f a="toIntersect">
	<c path="flash.geom.Rectangle"/>
	<c path="flash.geom.Rectangle"/>
</f></intersection>
		<inflatePoint public="1" set="method"><f a="point">
	<c path="flash.geom.Point"/>
	<e path="Void"/>
</f></inflatePoint>
		<inflate public="1" set="method"><f a="dx:dy">
	<c path="Float"/>
	<c path="Float"/>
	<e path="Void"/>
</f></inflate>
		<equals public="1" set="method"><f a="toCompare">
	<c path="flash.geom.Rectangle"/>
	<e path="Bool"/>
</f></equals>
		<copyFrom public="1">
			<f a="sourceRect">
				<c path="flash.geom.Rectangle"/>
				<e path="Void"/>
			</f>
			<meta><m n=":require"><e>flash11</e></m></meta>
		</copyFrom>
		<containsRect public="1" set="method"><f a="rect">
	<c path="flash.geom.Rectangle"/>
	<e path="Bool"/>
</f></containsRect>
		<containsPoint public="1" set="method"><f a="point">
	<c path="flash.geom.Point"/>
	<e path="Bool"/>
</f></containsPoint>
		<contains public="1" set="method"><f a="x:y">
	<c path="Float"/>
	<c path="Float"/>
	<e path="Bool"/>
</f></contains>
		<clone public="1" set="method"><f a=""><c path="flash.geom.Rectangle"/></f></clone>
		<y public="1"><c path="Float"/></y>
		<x public="1"><c path="Float"/></x>
		<width public="1"><c path="Float"/></width>
		<topLeft public="1"><c path="flash.geom.Point"/></topLeft>
		<top public="1"><c path="Float"/></top>
		<size public="1"><c path="flash.geom.Point"/></size>
		<right public="1"><c path="Float"/></right>
		<left public="1"><c path="Float"/></left>
		<height public="1"><c path="Float"/></height>
		<bottomRight public="1"><c path="flash.geom.Point"/></bottomRight>
		<bottom public="1"><c path="Float"/></bottom>
		<new public="1" set="method"><f a="?x:?y:?width:?height">
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<e path="Void"/>
</f></new>
	</class>
	<class path="flash.geom.Transform" params="" file="C:\Motion-Twin\Haxe/std/flash/geom/Transform.hx" extern="1">
		<getRelativeMatrix3D public="1" set="method">
			<f a="relativeTo">
				<c path="flash.display.DisplayObject"/>
				<c path="flash.geom.Matrix3D"/>
			</f>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</getRelativeMatrix3D>
		<pixelBounds public="1" set="null"><c path="flash.geom.Rectangle"/></pixelBounds>
		<perspectiveProjection public="1">
			<c path="flash.geom.PerspectiveProjection"/>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</perspectiveProjection>
		<matrix3D public="1">
			<c path="flash.geom.Matrix3D"/>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</matrix3D>
		<matrix public="1"><c path="flash.geom.Matrix"/></matrix>
		<concatenatedMatrix public="1" set="null"><c path="flash.geom.Matrix"/></concatenatedMatrix>
		<concatenatedColorTransform public="1" set="null"><c path="flash.geom.ColorTransform"/></concatenatedColorTransform>
		<colorTransform public="1"><c path="flash.geom.ColorTransform"/></colorTransform>
		<new public="1" set="method"><f a="displayObject">
	<c path="flash.display.DisplayObject"/>
	<e path="Void"/>
</f></new>
	</class>
	<class path="flash.geom.Vector3D" params="" file="C:\Motion-Twin\Haxe/std/flash/geom/Vector3D.hx" extern="1">
		<X_AXIS public="1" static="1"><c path="flash.geom.Vector3D"/></X_AXIS>
		<Y_AXIS public="1" static="1"><c path="flash.geom.Vector3D"/></Y_AXIS>
		<Z_AXIS public="1" static="1"><c path="flash.geom.Vector3D"/></Z_AXIS>
		<angleBetween public="1" set="method" static="1"><f a="a:b">
	<c path="flash.geom.Vector3D"/>
	<c path="flash.geom.Vector3D"/>
	<c path="Float"/>
</f></angleBetween>
		<distance public="1" set="method" static="1"><f a="pt1:pt2">
	<c path="flash.geom.Vector3D"/>
	<c path="flash.geom.Vector3D"/>
	<c path="Float"/>
</f></distance>
		<toString public="1" set="method"><f a=""><c path="String"/></f></toString>
		<subtract public="1" set="method"><f a="a">
	<c path="flash.geom.Vector3D"/>
	<c path="flash.geom.Vector3D"/>
</f></subtract>
		<setTo public="1">
			<f a="xa:ya:za">
				<c path="Float"/>
				<c path="Float"/>
				<c path="Float"/>
				<e path="Void"/>
			</f>
			<meta><m n=":require"><e>flash11</e></m></meta>
		</setTo>
		<scaleBy public="1" set="method"><f a="s">
	<c path="Float"/>
	<e path="Void"/>
</f></scaleBy>
		<project public="1" set="method"><f a=""><e path="Void"/></f></project>
		<normalize public="1" set="method"><f a=""><c path="Float"/></f></normalize>
		<negate public="1" set="method"><f a=""><e path="Void"/></f></negate>
		<nearEquals public="1" set="method"><f a="toCompare:tolerance:?allFour">
	<c path="flash.geom.Vector3D"/>
	<c path="Float"/>
	<e path="Bool"/>
	<e path="Bool"/>
</f></nearEquals>
		<incrementBy public="1" set="method"><f a="a">
	<c path="flash.geom.Vector3D"/>
	<e path="Void"/>
</f></incrementBy>
		<equals public="1" set="method"><f a="toCompare:?allFour">
	<c path="flash.geom.Vector3D"/>
	<e path="Bool"/>
	<e path="Bool"/>
</f></equals>
		<dotProduct public="1" set="method"><f a="a">
	<c path="flash.geom.Vector3D"/>
	<c path="Float"/>
</f></dotProduct>
		<decrementBy public="1" set="method"><f a="a">
	<c path="flash.geom.Vector3D"/>
	<e path="Void"/>
</f></decrementBy>
		<crossProduct public="1" set="method"><f a="a">
	<c path="flash.geom.Vector3D"/>
	<c path="flash.geom.Vector3D"/>
</f></crossProduct>
		<copyFrom public="1">
			<f a="sourceVector3D">
				<c path="flash.geom.Vector3D"/>
				<e path="Void"/>
			</f>
			<meta><m n=":require"><e>flash11</e></m></meta>
		</copyFrom>
		<clone public="1" set="method"><f a=""><c path="flash.geom.Vector3D"/></f></clone>
		<add public="1" set="method"><f a="a">
	<c path="flash.geom.Vector3D"/>
	<c path="flash.geom.Vector3D"/>
</f></add>
		<z public="1"><c path="Float"/></z>
		<y public="1"><c path="Float"/></y>
		<x public="1"><c path="Float"/></x>
		<w public="1"><c path="Float"/></w>
		<lengthSquared public="1" set="null"><c path="Float"/></lengthSquared>
		<length public="1" set="null"><c path="Float"/></length>
		<new public="1" set="method"><f a="?x:?y:?z:?w">
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<e path="Void"/>
</f></new>
		<meta><m n=":require"><e>flash10</e></m></meta>
	</class>
	<class path="flash.media.Camera" params="" file="C:\Motion-Twin\Haxe/std/flash/media/Camera.hx" extern="1">
		<extends path="flash.events.EventDispatcher"/>
		<isSupported public="1" static="1">
			<e path="Bool"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</isSupported>
		<names public="1" set="null" static="1"><c path="Array"><d/></c></names>
		<_scanHardware public="1" static="1">
			<f a=""><e path="Void"/></f>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</_scanHardware>
		<getCamera public="1" set="method" static="1"><f a="?name">
	<c path="String"/>
	<c path="flash.media.Camera"/>
</f></getCamera>
		<setQuality public="1" set="method"><f a="bandwidth:quality">
	<c path="Int"/>
	<c path="Int"/>
	<e path="Void"/>
</f></setQuality>
		<setMotionLevel public="1" set="method"><f a="motionLevel:?timeout">
	<c path="Int"/>
	<c path="Int"/>
	<e path="Void"/>
</f></setMotionLevel>
		<setMode public="1" set="method"><f a="width:height:fps:?favorArea">
	<c path="Int"/>
	<c path="Int"/>
	<c path="Float"/>
	<e path="Bool"/>
	<e path="Void"/>
</f></setMode>
		<setLoopback public="1" set="method"><f a="?compress">
	<e path="Bool"/>
	<e path="Void"/>
</f></setLoopback>
		<setKeyFrameInterval public="1" set="method"><f a="keyFrameInterval">
	<c path="Int"/>
	<e path="Void"/>
</f></setKeyFrameInterval>
		<setCursor public="1" set="method"><f a="value">
	<e path="Bool"/>
	<e path="Void"/>
</f></setCursor>
		<width public="1" set="null"><c path="Int"/></width>
		<quality public="1" set="null"><c path="Int"/></quality>
		<position public="1">
			<c path="String"/>
			<meta><m n=":require"><e>flash11_2</e></m></meta>
		</position>
		<name public="1" set="null"><c path="String"/></name>
		<muted public="1" set="null"><e path="Bool"/></muted>
		<motionTimeout public="1" set="null"><c path="Int"/></motionTimeout>
		<motionLevel public="1" set="null"><c path="Int"/></motionLevel>
		<loopback public="1" set="null"><e path="Bool"/></loopback>
		<keyFrameInterval public="1" set="null"><c path="Int"/></keyFrameInterval>
		<index public="1" set="null"><c path="Int"/></index>
		<height public="1" set="null"><c path="Int"/></height>
		<fps public="1" set="null"><c path="Float"/></fps>
		<currentFPS public="1" set="null"><c path="Float"/></currentFPS>
		<bandwidth public="1" set="null"><c path="Int"/></bandwidth>
		<activityLevel public="1" set="null"><c path="Float"/></activityLevel>
		<new public="1" set="method"><f a=""><e path="Void"/></f></new>
		<meta><m n=":final"/></meta>
	</class>
	<class path="flash.media.Microphone" params="" file="C:\Motion-Twin\Haxe/std/flash/media/Microphone.hx" extern="1">
		<extends path="flash.events.EventDispatcher"/>
		<isSupported public="1" static="1">
			<e path="Bool"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</isSupported>
		<names public="1" set="null" static="1"><c path="Array"><d/></c></names>
		<getEnhancedMicrophone public="1" static="1">
			<f a="?index">
				<c path="Int"/>
				<c path="flash.media.Microphone"/>
			</f>
			<meta><m n=":require"><e>flash10_2</e></m></meta>
		</getEnhancedMicrophone>
		<getMicrophone public="1" set="method" static="1"><f a="?index">
	<c path="Int"/>
	<c path="flash.media.Microphone"/>
</f></getMicrophone>
		<setUseEchoSuppression public="1" set="method"><f a="useEchoSuppression">
	<e path="Bool"/>
	<e path="Void"/>
</f></setUseEchoSuppression>
		<setSilenceLevel public="1" set="method"><f a="silenceLevel:?timeout">
	<c path="Float"/>
	<c path="Int"/>
	<e path="Void"/>
</f></setSilenceLevel>
		<setLoopBack public="1" set="method"><f a="?state">
	<e path="Bool"/>
	<e path="Void"/>
</f></setLoopBack>
		<useEchoSuppression public="1" set="null"><e path="Bool"/></useEchoSuppression>
		<soundTransform public="1"><c path="flash.media.SoundTransform"/></soundTransform>
		<silenceTimeout public="1" set="null"><c path="Int"/></silenceTimeout>
		<silenceLevel public="1" set="null"><c path="Float"/></silenceLevel>
		<rate public="1"><c path="Int"/></rate>
		<noiseSuppressionLevel public="1">
			<c path="Int"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</noiseSuppressionLevel>
		<name public="1" set="null"><c path="String"/></name>
		<muted public="1" set="null"><e path="Bool"/></muted>
		<index public="1" set="null"><c path="Int"/></index>
		<gain public="1"><c path="Float"/></gain>
		<framesPerPacket public="1">
			<c path="Int"/>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</framesPerPacket>
		<enhancedOptions public="1">
			<c path="flash.media.MicrophoneEnhancedOptions"/>
			<meta><m n=":require"><e>flash10_2</e></m></meta>
		</enhancedOptions>
		<encodeQuality public="1">
			<c path="Int"/>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</encodeQuality>
		<enableVAD public="1">
			<e path="Bool"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</enableVAD>
		<codec public="1">
			<e path="flash.media.SoundCodec"/>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</codec>
		<activityLevel public="1" set="null"><c path="Float"/></activityLevel>
		<new public="1" set="method"><f a=""><e path="Void"/></f></new>
		<meta><m n=":final"/></meta>
	</class>
	<enum path="flash.media.MicrophoneEnhancedMode" params="" file="C:\Motion-Twin\Haxe/std/flash/media/MicrophoneEnhancedMode.hx">
		<SPEAKER_MUTE/>
		<OFF/>
		<HEADSET/>
		<HALF_DUPLEX/>
		<FULL_DUPLEX/>
		<meta>
			<m n=":fakeEnum"><e>String</e></m>
			<m n=":require"><e>flash10_2</e></m>
		</meta>
	</enum>
	<class path="flash.media.MicrophoneEnhancedOptions" params="" file="C:\Motion-Twin\Haxe/std/flash/media/MicrophoneEnhancedOptions.hx" extern="1">
		<nonLinearProcessing public="1"><e path="Bool"/></nonLinearProcessing>
		<mode public="1"><e path="flash.media.MicrophoneEnhancedMode"/></mode>
		<isVoiceDetected public="1"><c path="Int"/></isVoiceDetected>
		<echoPath public="1"><c path="Int"/></echoPath>
		<autoGain public="1"><e path="Bool"/></autoGain>
		<new public="1"><f a=""><e path="Void"/></f></new>
		<meta>
			<m n=":final"/>
			<m n=":require"><e>flash10_2</e></m>
		</meta>
	</class>
	<enum path="flash.media.SoundCodec" params="" file="C:\Motion-Twin\Haxe/std/flash/media/SoundCodec.hx">
		<SPEEX/>
		<PCMU/>
		<PCMA/>
		<NELLYMOSER/>
		<meta><m n=":fakeEnum"><e>String</e></m></meta>
	</enum>
	<class path="flash.media.SoundTransform" params="" file="C:\Motion-Twin\Haxe/std/flash/media/SoundTransform.hx" extern="1">
		<volume public="1"><c path="Float"/></volume>
		<rightToRight public="1"><c path="Float"/></rightToRight>
		<rightToLeft public="1"><c path="Float"/></rightToLeft>
		<pan public="1"><c path="Float"/></pan>
		<leftToRight public="1"><c path="Float"/></leftToRight>
		<leftToLeft public="1"><c path="Float"/></leftToLeft>
		<new public="1" set="method"><f a="?vol:?panning">
	<c path="Float"/>
	<c path="Float"/>
	<e path="Void"/>
</f></new>
		<meta><m n=":final"/></meta>
	</class>
	<class path="flash.media.StageVideo" params="" file="C:\Motion-Twin\Haxe/std/flash/media/StageVideo.hx" extern="1">
		<extends path="flash.events.EventDispatcher"/>
		<attachNetStream public="1" set="method"><f a="netStream">
	<c path="flash.net.NetStream"/>
	<e path="Void"/>
</f></attachNetStream>
		<zoom public="1"><c path="flash.geom.Point"/></zoom>
		<viewPort public="1"><c path="flash.geom.Rectangle"/></viewPort>
		<videoWidth public="1" set="null"><c path="Int"/></videoWidth>
		<videoHeight public="1" set="null"><c path="Int"/></videoHeight>
		<pan public="1"><c path="flash.geom.Point"/></pan>
		<depth public="1"><c path="Int"/></depth>
		<colorSpaces public="1" set="null"><c path="flash.Vector"><c path="String"/></c></colorSpaces>
		<new public="1"><f a=""><e path="Void"/></f></new>
		<meta><m n=":require"><e>flash10_2</e></m></meta>
	</class>
	<class path="flash.media.VideoStreamSettings" params="" file="C:\Motion-Twin\Haxe/std/flash/media/VideoStreamSettings.hx" extern="1">
		<setQuality public="1" set="method"><f a="bandwidth:quality">
	<c path="Int"/>
	<c path="Int"/>
	<e path="Void"/>
</f></setQuality>
		<setMode public="1" set="method"><f a="width:height:fps">
	<c path="Int"/>
	<c path="Int"/>
	<c path="Float"/>
	<e path="Void"/>
</f></setMode>
		<setKeyFrameInterval public="1" set="method"><f a="keyFrameInterval">
	<c path="Int"/>
	<e path="Void"/>
</f></setKeyFrameInterval>
		<width public="1" set="null"><c path="Int"/></width>
		<quality public="1" set="null"><c path="Int"/></quality>
		<keyFrameInterval public="1" set="null"><c path="Int"/></keyFrameInterval>
		<height public="1" set="null"><c path="Int"/></height>
		<fps public="1" set="null"><c path="Float"/></fps>
		<codec public="1" set="null"><c path="String"/></codec>
		<bandwidth public="1" set="null"><c path="Int"/></bandwidth>
		<new public="1" set="method"><f a=""><e path="Void"/></f></new>
	</class>
	<class path="flash.net.LocalConnection" params="" file="C:\Motion-Twin\Haxe/std/flash/net/LocalConnection.hx" extern="1">
		<extends path="flash.events.EventDispatcher"/>
		<isSupported public="1" static="1">
			<e path="Bool"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</isSupported>
		<send public="1" set="method"><f a="connectionName:methodName:?p1:?p2:?p3:?p4:?p5">
	<c path="String"/>
	<c path="String"/>
	<d/>
	<d/>
	<d/>
	<d/>
	<d/>
	<e path="Void"/>
</f></send>
		<connect public="1" set="method"><f a="connectionName">
	<c path="String"/>
	<e path="Void"/>
</f></connect>
		<close public="1" set="method"><f a=""><e path="Void"/></f></close>
		<allowInsecureDomain public="1" set="method"><f a="?p1:?p2:?p3:?p4:?p5">
	<d/>
	<d/>
	<d/>
	<d/>
	<d/>
	<e path="Void"/>
</f></allowInsecureDomain>
		<allowDomain public="1" set="method"><f a="?p1:?p2:?p3:?p4:?p5">
	<d/>
	<d/>
	<d/>
	<d/>
	<d/>
	<e path="Void"/>
</f></allowDomain>
		<isPerUser public="1">
			<e path="Bool"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</isPerUser>
		<domain public="1" set="null"><c path="String"/></domain>
		<client public="1"><d/></client>
		<new public="1" set="method"><f a=""><e path="Void"/></f></new>
	</class>
	<class path="flash.net.NetConnection" params="" file="C:\Motion-Twin\Haxe/std/flash/net/NetConnection.hx" extern="1">
		<extends path="flash.events.EventDispatcher"/>
		<defaultObjectEncoding public="1" static="1"><t path="UInt"/></defaultObjectEncoding>
		<connect public="1" set="method"><f a="command:?p1:?p2:?p3:?p4:?p5">
	<c path="String"/>
	<d/>
	<d/>
	<d/>
	<d/>
	<d/>
	<e path="Void"/>
</f></connect>
		<close public="1" set="method"><f a=""><e path="Void"/></f></close>
		<call public="1" set="method"><f a="command:responder:?p1:?p2:?p3:?p4:?p5">
	<c path="String"/>
	<c path="flash.net.Responder"/>
	<d/>
	<d/>
	<d/>
	<d/>
	<d/>
	<e path="Void"/>
</f></call>
		<addHeader public="1" set="method"><f a="operation:?mustUnderstand:?param">
	<c path="String"/>
	<e path="Bool"/>
	<d/>
	<e path="Void"/>
</f></addHeader>
		<usingTLS public="1" set="null"><e path="Bool"/></usingTLS>
		<uri public="1" set="null"><c path="String"/></uri>
		<unconnectedPeerStreams public="1" set="null">
			<c path="Array"><d/></c>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</unconnectedPeerStreams>
		<proxyType public="1"><c path="String"/></proxyType>
		<protocol public="1" set="null">
			<c path="String"/>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</protocol>
		<objectEncoding public="1"><t path="UInt"/></objectEncoding>
		<nearNonce public="1" set="null">
			<c path="String"/>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</nearNonce>
		<nearID public="1" set="null">
			<c path="String"/>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</nearID>
		<maxPeerConnections public="1">
			<t path="UInt"/>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</maxPeerConnections>
		<farNonce public="1" set="null">
			<c path="String"/>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</farNonce>
		<farID public="1" set="null">
			<c path="String"/>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</farID>
		<connectedProxyType public="1" set="null"><c path="String"/></connectedProxyType>
		<connected public="1" set="null"><e path="Bool"/></connected>
		<client public="1"><d/></client>
		<new public="1" set="method"><f a=""><e path="Void"/></f></new>
	</class>
	<class path="flash.net.NetStream" params="" file="C:\Motion-Twin\Haxe/std/flash/net/NetStream.hx" extern="1">
		<extends path="flash.events.EventDispatcher"/>
		<CONNECT_TO_FMS public="1" static="1">
			<c path="String"/>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</CONNECT_TO_FMS>
		<DIRECT_CONNECTIONS public="1" static="1">
			<c path="String"/>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</DIRECT_CONNECTIONS>
		<togglePause public="1" set="method"><f a=""><e path="Void"/></f></togglePause>
		<step public="1">
			<f a="frames">
				<c path="Int"/>
				<e path="Void"/>
			</f>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</step>
		<send public="1" set="method"><f a="handlerName:?p1:?p2:?p3:?p4:?p5">
	<c path="String"/>
	<d/>
	<d/>
	<d/>
	<d/>
	<d/>
	<e path="Void"/>
</f></send>
		<seek public="1" set="method"><f a="offset">
	<c path="Float"/>
	<e path="Void"/>
</f></seek>
		<resume public="1" set="method"><f a=""><e path="Void"/></f></resume>
		<receiveVideoFPS public="1" set="method"><f a="FPS">
	<c path="Float"/>
	<e path="Void"/>
</f></receiveVideoFPS>
		<receiveVideo public="1" set="method"><f a="flag">
	<e path="Bool"/>
	<e path="Void"/>
</f></receiveVideo>
		<receiveAudio public="1" set="method"><f a="flag">
	<e path="Bool"/>
	<e path="Void"/>
</f></receiveAudio>
		<publish public="1" set="method"><f a="?name:?type">
	<c path="String"/>
	<c path="String"/>
	<e path="Void"/>
</f></publish>
		<play2 public="1" set="method">
			<f a="param">
				<c path="flash.net.NetStreamPlayOptions"/>
				<e path="Void"/>
			</f>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</play2>
		<play public="1" set="method"><f a="?p1:?p2:?p3:?p4:?p5">
	<d/>
	<d/>
	<d/>
	<d/>
	<d/>
	<e path="Void"/>
</f></play>
		<pause public="1" set="method"><f a=""><e path="Void"/></f></pause>
		<onPeerConnect public="1" set="method">
			<f a="subscriber">
				<c path="flash.net.NetStream"/>
				<e path="Bool"/>
			</f>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</onPeerConnect>
		<dispose public="1">
			<f a=""><e path="Void"/></f>
			<meta><m n=":require"><e>flash11_2</e></m></meta>
		</dispose>
		<close public="1" set="method"><f a=""><e path="Void"/></f></close>
		<attachCamera public="1" set="method"><f a="theCamera:?snapshotMilliseconds">
	<c path="flash.media.Camera"/>
	<c path="Int"/>
	<e path="Void"/>
</f></attachCamera>
		<attachAudio public="1" set="method"><f a="microphone">
	<c path="flash.media.Microphone"/>
	<e path="Void"/>
</f></attachAudio>
		<attach public="1">
			<f a="connection">
				<c path="flash.net.NetConnection"/>
				<e path="Void"/>
			</f>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</attach>
		<appendBytesAction public="1">
			<f a="netStreamAppendBytesAction">
				<c path="String"/>
				<e path="Void"/>
			</f>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</appendBytesAction>
		<appendBytes public="1">
			<f a="bytes">
				<c path="flash.utils.ByteArray"/>
				<e path="Void"/>
			</f>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</appendBytes>
		<videoStreamSettings public="1">
			<c path="flash.media.VideoStreamSettings"/>
			<meta><m n=":require"><e>flash11</e></m></meta>
		</videoStreamSettings>
		<videoSampleAccess public="1">
			<e path="Bool"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</videoSampleAccess>
		<videoReliable public="1">
			<e path="Bool"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</videoReliable>
		<videoCodec public="1" set="null"><t path="UInt"/></videoCodec>
		<useJitterBuffer public="1">
			<e path="Bool"/>
			<meta><m n=":require"><e>flash11_3</e></m></meta>
		</useJitterBuffer>
		<useHardwareDecoder public="1">
			<e path="Bool"/>
			<meta><m n=":require"><e>flash11</e></m></meta>
		</useHardwareDecoder>
		<time public="1" set="null"><c path="Float"/></time>
		<soundTransform public="1"><c path="flash.media.SoundTransform"/></soundTransform>
		<peerStreams public="1" set="null">
			<c path="Array"><d/></c>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</peerStreams>
		<objectEncoding public="1" set="null"><t path="UInt"/></objectEncoding>
		<nearNonce public="1" set="null">
			<c path="String"/>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</nearNonce>
		<multicastWindowDuration public="1">
			<c path="Float"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</multicastWindowDuration>
		<multicastRelayMarginDuration public="1">
			<c path="Float"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</multicastRelayMarginDuration>
		<multicastPushNeighborLimit public="1">
			<c path="Float"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</multicastPushNeighborLimit>
		<multicastInfo public="1">
			<c path="flash.net.NetStreamMulticastInfo"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</multicastInfo>
		<multicastFetchPeriod public="1">
			<c path="Float"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</multicastFetchPeriod>
		<multicastAvailabilityUpdatePeriod public="1">
			<c path="Float"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</multicastAvailabilityUpdatePeriod>
		<multicastAvailabilitySendToAll public="1">
			<e path="Bool"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</multicastAvailabilitySendToAll>
		<maxPauseBufferTime public="1">
			<c path="Float"/>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</maxPauseBufferTime>
		<liveDelay public="1" set="null"><c path="Float"/></liveDelay>
		<info public="1" set="null">
			<c path="flash.net.NetStreamInfo"/>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</info>
		<inBufferSeek public="1">
			<e path="Bool"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</inBufferSeek>
		<farNonce public="1" set="null">
			<c path="String"/>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</farNonce>
		<farID public="1" set="null">
			<c path="String"/>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</farID>
		<decodedFrames public="1" set="null"><t path="UInt"/></decodedFrames>
		<dataReliable public="1">
			<e path="Bool"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</dataReliable>
		<currentFPS public="1" set="null"><c path="Float"/></currentFPS>
		<client public="1"><d/></client>
		<checkPolicyFile public="1"><e path="Bool"/></checkPolicyFile>
		<bytesTotal public="1" set="null"><t path="UInt"/></bytesTotal>
		<bytesLoaded public="1" set="null"><t path="UInt"/></bytesLoaded>
		<bufferTimeMax public="1">
			<c path="Float"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</bufferTimeMax>
		<bufferTime public="1"><c path="Float"/></bufferTime>
		<bufferLength public="1" set="null"><c path="Float"/></bufferLength>
		<backBufferTime public="1">
			<c path="Float"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</backBufferTime>
		<backBufferLength public="1">
			<c path="Float"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</backBufferLength>
		<audioSampleAccess public="1">
			<e path="Bool"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</audioSampleAccess>
		<audioReliable public="1">
			<e path="Bool"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</audioReliable>
		<audioCodec public="1" set="null"><t path="UInt"/></audioCodec>
		<new public="1" set="method"><f a="connection:?peerID">
	<c path="flash.net.NetConnection"/>
	<c path="String"/>
	<e path="Void"/>
</f></new>
	</class>
	<class path="flash.net.NetStreamInfo" params="" file="C:\Motion-Twin\Haxe/std/flash/net/NetStreamInfo.hx" extern="1">
		<toString public="1" set="method"><f a=""><c path="String"/></f></toString>
		<xmpData public="1" set="null"><d/></xmpData>
		<videoLossRate public="1">
			<c path="Float"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</videoLossRate>
		<videoBytesPerSecond public="1" set="null"><c path="Float"/></videoBytesPerSecond>
		<videoByteCount public="1" set="null"><c path="Float"/></videoByteCount>
		<videoBufferLength public="1" set="null"><c path="Float"/></videoBufferLength>
		<videoBufferByteLength public="1" set="null"><c path="Float"/></videoBufferByteLength>
		<uri public="1" set="null"><c path="String"/></uri>
		<resourceName public="1" set="null"><c path="String"/></resourceName>
		<playbackBytesPerSecond public="1" set="null"><c path="Float"/></playbackBytesPerSecond>
		<metaData public="1" set="null"><d/></metaData>
		<maxBytesPerSecond public="1" set="null"><c path="Float"/></maxBytesPerSecond>
		<isLive public="1" set="null"><e path="Bool"/></isLive>
		<droppedFrames public="1" set="null"><c path="Float"/></droppedFrames>
		<dataBytesPerSecond public="1" set="null"><c path="Float"/></dataBytesPerSecond>
		<dataByteCount public="1" set="null"><c path="Float"/></dataByteCount>
		<dataBufferLength public="1" set="null"><c path="Float"/></dataBufferLength>
		<dataBufferByteLength public="1" set="null"><c path="Float"/></dataBufferByteLength>
		<currentBytesPerSecond public="1" set="null"><c path="Float"/></currentBytesPerSecond>
		<byteCount public="1" set="null"><c path="Float"/></byteCount>
		<audioLossRate public="1" set="null"><c path="Float"/></audioLossRate>
		<audioBytesPerSecond public="1" set="null"><c path="Float"/></audioBytesPerSecond>
		<audioByteCount public="1" set="null"><c path="Float"/></audioByteCount>
		<audioBufferLength public="1" set="null"><c path="Float"/></audioBufferLength>
		<audioBufferByteLength public="1" set="null"><c path="Float"/></audioBufferByteLength>
		<SRTT public="1" set="null"><c path="Float"/></SRTT>
		<new public="1" set="method"><f a="curBPS:byteCount:maxBPS:audioBPS:audioByteCount:videoBPS:videoByteCount:dataBPS:dataByteCount:playbackBPS:droppedFrames:audioBufferByteLength:videoBufferByteLength:dataBufferByteLength:audioBufferLength:videoBufferLength:dataBufferLength:srtt:audioLossRate:videoLossRate:?metaData:?xmpData:?uri:?resourceName:?isLive">
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<d/>
	<d/>
	<c path="String"/>
	<c path="String"/>
	<e path="Bool"/>
	<e path="Void"/>
</f></new>
		<meta><m n=":final"/></meta>
	</class>
	<class path="flash.net.NetStreamMulticastInfo" params="" file="C:\Motion-Twin\Haxe/std/flash/net/NetStreamMulticastInfo.hx" extern="1">
		<toString public="1" set="method"><f a=""><c path="String"/></f></toString>
		<sendDataBytesPerSecond public="1" set="null"><c path="Float"/></sendDataBytesPerSecond>
		<sendControlBytesPerSecondToServer public="1" set="null"><c path="Float"/></sendControlBytesPerSecondToServer>
		<sendControlBytesPerSecond public="1" set="null"><c path="Float"/></sendControlBytesPerSecond>
		<receiveDataBytesPerSecondFromServer public="1" set="null"><c path="Float"/></receiveDataBytesPerSecondFromServer>
		<receiveDataBytesPerSecondFromIPMulticast public="1" set="null"><c path="Float"/></receiveDataBytesPerSecondFromIPMulticast>
		<receiveDataBytesPerSecond public="1" set="null"><c path="Float"/></receiveDataBytesPerSecond>
		<receiveControlBytesPerSecond public="1" set="null"><c path="Float"/></receiveControlBytesPerSecond>
		<fragmentsRequestedFromPeers public="1" set="null"><c path="Float"/></fragmentsRequestedFromPeers>
		<fragmentsRequestedByPeers public="1" set="null"><c path="Float"/></fragmentsRequestedByPeers>
		<fragmentsReceivedFromServer public="1" set="null"><c path="Float"/></fragmentsReceivedFromServer>
		<fragmentsReceivedFromIPMulticast public="1" set="null"><c path="Float"/></fragmentsReceivedFromIPMulticast>
		<fragmentsPushedToPeers public="1" set="null"><c path="Float"/></fragmentsPushedToPeers>
		<fragmentsPushedFromPeers public="1" set="null"><c path="Float"/></fragmentsPushedFromPeers>
		<bytesRequestedFromPeers public="1" set="null"><c path="Float"/></bytesRequestedFromPeers>
		<bytesRequestedByPeers public="1" set="null"><c path="Float"/></bytesRequestedByPeers>
		<bytesReceivedFromServer public="1" set="null"><c path="Float"/></bytesReceivedFromServer>
		<bytesReceivedFromIPMulticast public="1" set="null"><c path="Float"/></bytesReceivedFromIPMulticast>
		<bytesPushedToPeers public="1" set="null"><c path="Float"/></bytesPushedToPeers>
		<bytesPushedFromPeers public="1" set="null"><c path="Float"/></bytesPushedFromPeers>
		<new public="1"><f a="sendDataBytesPerSecond:sendControlBytesPerSecond:receiveDataBytesPerSecond:receiveControlBytesPerSecond:bytesPushedToPeers:fragmentsPushedToPeers:bytesRequestedByPeers:fragmentsRequestedByPeers:bytesPushedFromPeers:fragmentsPushedFromPeers:bytesRequestedFromPeers:fragmentsRequestedFromPeers:sendControlBytesPerSecondToServer:receiveDataBytesPerSecondFromServer:bytesReceivedFromServer:fragmentsReceivedFromServer:receiveDataBytesPerSecondFromIPMulticast:bytesReceivedFromIPMulticast:fragmentsReceivedFromIPMulticast">
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<e path="Void"/>
</f></new>
		<meta>
			<m n=":final"/>
			<m n=":require"><e>flash10_1</e></m>
		</meta>
	</class>
	<class path="flash.net.NetStreamPlayOptions" params="" file="C:\Motion-Twin\Haxe/std/flash/net/NetStreamPlayOptions.hx" extern="1">
		<extends path="flash.events.EventDispatcher"/>
		<transition public="1"><c path="String"/></transition>
		<streamName public="1"><c path="String"/></streamName>
		<start public="1"><c path="Float"/></start>
		<oldStreamName public="1"><c path="String"/></oldStreamName>
		<offset public="1">
			<c path="Float"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</offset>
		<len public="1"><c path="Float"/></len>
		<new public="1" set="method"><f a=""><e path="Void"/></f></new>
		<haxe_dynamic><d/></haxe_dynamic>
	</class>
	<class path="flash.net.Responder" params="" file="C:\Motion-Twin\Haxe/std/flash/net/Responder.hx" extern="1"><new public="1" set="method"><f a="result:?status">
	<d/>
	<d/>
	<e path="Void"/>
</f></new></class>
	<class path="flash.utils.IDataInput" params="" file="C:\Motion-Twin\Haxe/std/flash/utils/IDataInput.hx" extern="1" interface="1">
		<readUnsignedShort public="1" set="method"><f a=""><t path="UInt"/></f></readUnsignedShort>
		<readUnsignedInt public="1" set="method"><f a=""><t path="UInt"/></f></readUnsignedInt>
		<readUnsignedByte public="1" set="method"><f a=""><t path="UInt"/></f></readUnsignedByte>
		<readUTFBytes public="1" set="method"><f a="length">
	<t path="UInt"/>
	<c path="String"/>
</f></readUTFBytes>
		<readUTF public="1" set="method"><f a=""><c path="String"/></f></readUTF>
		<readShort public="1" set="method"><f a=""><c path="Int"/></f></readShort>
		<readObject public="1" set="method"><f a=""><d/></f></readObject>
		<readMultiByte public="1" set="method"><f a="length:charSet">
	<t path="UInt"/>
	<c path="String"/>
	<c path="String"/>
</f></readMultiByte>
		<readInt public="1" set="method"><f a=""><c path="Int"/></f></readInt>
		<readFloat public="1" set="method"><f a=""><c path="Float"/></f></readFloat>
		<readDouble public="1" set="method"><f a=""><c path="Float"/></f></readDouble>
		<readBytes public="1" set="method"><f a="bytes:?offset:?length">
	<c path="flash.utils.ByteArray"/>
	<t path="UInt"/>
	<t path="UInt"/>
	<e path="Void"/>
</f></readBytes>
		<readByte public="1" set="method"><f a=""><c path="Int"/></f></readByte>
		<readBoolean public="1" set="method"><f a=""><e path="Bool"/></f></readBoolean>
		<objectEncoding public="1"><t path="UInt"/></objectEncoding>
		<endian public="1"><e path="flash.utils.Endian"/></endian>
		<bytesAvailable public="1" set="null"><t path="UInt"/></bytesAvailable>
	</class>
	<class path="flash.utils.IDataOutput" params="" file="C:\Motion-Twin\Haxe/std/flash/utils/IDataOutput.hx" extern="1" interface="1">
		<writeUnsignedInt public="1" set="method"><f a="value">
	<t path="UInt"/>
	<e path="Void"/>
</f></writeUnsignedInt>
		<writeUTFBytes public="1" set="method"><f a="value">
	<c path="String"/>
	<e path="Void"/>
</f></writeUTFBytes>
		<writeUTF public="1" set="method"><f a="value">
	<c path="String"/>
	<e path="Void"/>
</f></writeUTF>
		<writeShort public="1" set="method"><f a="value">
	<c path="Int"/>
	<e path="Void"/>
</f></writeShort>
		<writeObject public="1" set="method"><f a="object">
	<d/>
	<e path="Void"/>
</f></writeObject>
		<writeMultiByte public="1" set="method"><f a="value:charSet">
	<c path="String"/>
	<c path="String"/>
	<e path="Void"/>
</f></writeMultiByte>
		<writeInt public="1" set="method"><f a="value">
	<c path="Int"/>
	<e path="Void"/>
</f></writeInt>
		<writeFloat public="1" set="method"><f a="value">
	<c path="Float"/>
	<e path="Void"/>
</f></writeFloat>
		<writeDouble public="1" set="method"><f a="value">
	<c path="Float"/>
	<e path="Void"/>
</f></writeDouble>
		<writeBytes public="1" set="method"><f a="bytes:?offset:?length">
	<c path="flash.utils.ByteArray"/>
	<t path="UInt"/>
	<t path="UInt"/>
	<e path="Void"/>
</f></writeBytes>
		<writeByte public="1" set="method"><f a="value">
	<c path="Int"/>
	<e path="Void"/>
</f></writeByte>
		<writeBoolean public="1" set="method"><f a="value">
	<e path="Bool"/>
	<e path="Void"/>
</f></writeBoolean>
		<objectEncoding public="1"><t path="UInt"/></objectEncoding>
		<endian public="1"><e path="flash.utils.Endian"/></endian>
	</class>
	<class path="flash.net.Socket" params="" file="C:\Motion-Twin\Haxe/std/flash/net/Socket.hx" extern="1">
		<extends path="flash.events.EventDispatcher"/>
		<implements path="flash.utils.IDataInput"/>
		<implements path="flash.utils.IDataOutput"/>
		<writeUnsignedInt public="1" set="method"><f a="value">
	<t path="UInt"/>
	<e path="Void"/>
</f></writeUnsignedInt>
		<writeUTFBytes public="1" set="method"><f a="value">
	<c path="String"/>
	<e path="Void"/>
</f></writeUTFBytes>
		<writeUTF public="1" set="method"><f a="value">
	<c path="String"/>
	<e path="Void"/>
</f></writeUTF>
		<writeShort public="1" set="method"><f a="value">
	<c path="Int"/>
	<e path="Void"/>
</f></writeShort>
		<writeObject public="1" set="method"><f a="object">
	<d/>
	<e path="Void"/>
</f></writeObject>
		<writeMultiByte public="1" set="method"><f a="value:charSet">
	<c path="String"/>
	<c path="String"/>
	<e path="Void"/>
</f></writeMultiByte>
		<writeInt public="1" set="method"><f a="value">
	<c path="Int"/>
	<e path="Void"/>
</f></writeInt>
		<writeFloat public="1" set="method"><f a="value">
	<c path="Float"/>
	<e path="Void"/>
</f></writeFloat>
		<writeDouble public="1" set="method"><f a="value">
	<c path="Float"/>
	<e path="Void"/>
</f></writeDouble>
		<writeBytes public="1" set="method"><f a="bytes:?offset:?length">
	<c path="flash.utils.ByteArray"/>
	<t path="UInt"/>
	<t path="UInt"/>
	<e path="Void"/>
</f></writeBytes>
		<writeByte public="1" set="method"><f a="value">
	<c path="Int"/>
	<e path="Void"/>
</f></writeByte>
		<writeBoolean public="1" set="method"><f a="value">
	<e path="Bool"/>
	<e path="Void"/>
</f></writeBoolean>
		<readUnsignedShort public="1" set="method"><f a=""><t path="UInt"/></f></readUnsignedShort>
		<readUnsignedInt public="1" set="method"><f a=""><t path="UInt"/></f></readUnsignedInt>
		<readUnsignedByte public="1" set="method"><f a=""><t path="UInt"/></f></readUnsignedByte>
		<readUTFBytes public="1" set="method"><f a="length">
	<t path="UInt"/>
	<c path="String"/>
</f></readUTFBytes>
		<readUTF public="1" set="method"><f a=""><c path="String"/></f></readUTF>
		<readShort public="1" set="method"><f a=""><c path="Int"/></f></readShort>
		<readObject public="1" set="method"><f a=""><d/></f></readObject>
		<readMultiByte public="1" set="method"><f a="length:charSet">
	<t path="UInt"/>
	<c path="String"/>
	<c path="String"/>
</f></readMultiByte>
		<readInt public="1" set="method"><f a=""><c path="Int"/></f></readInt>
		<readFloat public="1" set="method"><f a=""><c path="Float"/></f></readFloat>
		<readDouble public="1" set="method"><f a=""><c path="Float"/></f></readDouble>
		<readBytes public="1" set="method"><f a="bytes:?offset:?length">
	<c path="flash.utils.ByteArray"/>
	<t path="UInt"/>
	<t path="UInt"/>
	<e path="Void"/>
</f></readBytes>
		<readByte public="1" set="method"><f a=""><c path="Int"/></f></readByte>
		<readBoolean public="1" set="method"><f a=""><e path="Bool"/></f></readBoolean>
		<flush public="1" set="method"><f a=""><e path="Void"/></f></flush>
		<connect public="1" set="method"><f a="host:port">
	<c path="String"/>
	<c path="Int"/>
	<e path="Void"/>
</f></connect>
		<close public="1" set="method"><f a=""><e path="Void"/></f></close>
		<timeout public="1">
			<t path="UInt"/>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</timeout>
		<objectEncoding public="1"><t path="UInt"/></objectEncoding>
		<endian public="1"><e path="flash.utils.Endian"/></endian>
		<connected public="1" set="null"><e path="Bool"/></connected>
		<bytesPending public="1">
			<t path="UInt"/>
			<meta><m n=":require"><e>flash11</e></m></meta>
		</bytesPending>
		<bytesAvailable public="1" set="null"><t path="UInt"/></bytesAvailable>
		<new public="1" set="method"><f a="?host:?port">
	<c path="String"/>
	<c path="Int"/>
	<e path="Void"/>
</f></new>
	</class>
	<class path="flash.net.URLLoader" params="" file="C:\Motion-Twin\Haxe/std/flash/net/URLLoader.hx" extern="1">
		<extends path="flash.events.EventDispatcher"/>
		<load public="1" set="method"><f a="request">
	<c path="flash.net.URLRequest"/>
	<e path="Void"/>
</f></load>
		<close public="1" set="method"><f a=""><e path="Void"/></f></close>
		<dataFormat public="1"><e path="flash.net.URLLoaderDataFormat"/></dataFormat>
		<data public="1"><d/></data>
		<bytesTotal public="1"><t path="UInt"/></bytesTotal>
		<bytesLoaded public="1"><t path="UInt"/></bytesLoaded>
		<new public="1" set="method"><f a="?request">
	<c path="flash.net.URLRequest"/>
	<e path="Void"/>
</f></new>
	</class>
	<enum path="flash.net.URLLoaderDataFormat" params="" file="C:\Motion-Twin\Haxe/std/flash/net/URLLoaderDataFormat.hx">
		<VARIABLES/>
		<TEXT/>
		<BINARY/>
		<meta><m n=":fakeEnum"><e>String</e></m></meta>
	</enum>
	<class path="flash.net.URLRequest" params="" file="C:\Motion-Twin\Haxe/std/flash/net/URLRequest.hx" extern="1">
		<url public="1"><c path="String"/></url>
		<requestHeaders public="1"><c path="Array"><c path="flash.net.URLRequestHeader"/></c></requestHeaders>
		<method public="1"><c path="String"/></method>
		<digest public="1"><c path="String"/></digest>
		<data public="1"><d/></data>
		<contentType public="1"><c path="String"/></contentType>
		<new public="1" set="method"><f a="?url">
	<c path="String"/>
	<e path="Void"/>
</f></new>
		<meta><m n=":final"/></meta>
	</class>
	<class path="flash.net.URLRequestHeader" params="" file="C:\Motion-Twin\Haxe/std/flash/net/URLRequestHeader.hx" extern="1">
		<value public="1"><c path="String"/></value>
		<name public="1"><c path="String"/></name>
		<new public="1" set="method"><f a="?name:?value">
	<c path="String"/>
	<c path="String"/>
	<e path="Void"/>
</f></new>
		<meta><m n=":final"/></meta>
	</class>
	<class path="flash.net.URLRequestMethod" params="" file="C:\Motion-Twin\Haxe/std/flash/net/URLRequestMethod.hx" extern="1">
		<DELETE public="1" static="1">
			<c path="String"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</DELETE>
		<GET public="1" static="1"><c path="String"/></GET>
		<HEAD public="1" static="1">
			<c path="String"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</HEAD>
		<OPTIONS public="1" static="1">
			<c path="String"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</OPTIONS>
		<POST public="1" static="1"><c path="String"/></POST>
		<PUT public="1" static="1">
			<c path="String"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</PUT>
	</class>
	<class path="flash.net.URLStream" params="" file="C:\Motion-Twin\Haxe/std/flash/net/URLStream.hx" extern="1">
		<extends path="flash.events.EventDispatcher"/>
		<implements path="flash.utils.IDataInput"/>
		<readUnsignedShort public="1" set="method"><f a=""><t path="UInt"/></f></readUnsignedShort>
		<readUnsignedInt public="1" set="method"><f a=""><t path="UInt"/></f></readUnsignedInt>
		<readUnsignedByte public="1" set="method"><f a=""><t path="UInt"/></f></readUnsignedByte>
		<readUTFBytes public="1" set="method"><f a="length">
	<t path="UInt"/>
	<c path="String"/>
</f></readUTFBytes>
		<readUTF public="1" set="method"><f a=""><c path="String"/></f></readUTF>
		<readShort public="1" set="method"><f a=""><c path="Int"/></f></readShort>
		<readObject public="1" set="method"><f a=""><d/></f></readObject>
		<readMultiByte public="1" set="method"><f a="length:charSet">
	<t path="UInt"/>
	<c path="String"/>
	<c path="String"/>
</f></readMultiByte>
		<readInt public="1" set="method"><f a=""><c path="Int"/></f></readInt>
		<readFloat public="1" set="method"><f a=""><c path="Float"/></f></readFloat>
		<readDouble public="1" set="method"><f a=""><c path="Float"/></f></readDouble>
		<readBytes public="1" set="method"><f a="bytes:?offset:?length">
	<c path="flash.utils.ByteArray"/>
	<t path="UInt"/>
	<t path="UInt"/>
	<e path="Void"/>
</f></readBytes>
		<readByte public="1" set="method"><f a=""><c path="Int"/></f></readByte>
		<readBoolean public="1" set="method"><f a=""><e path="Bool"/></f></readBoolean>
		<load public="1" set="method"><f a="request">
	<c path="flash.net.URLRequest"/>
	<e path="Void"/>
</f></load>
		<close public="1" set="method"><f a=""><e path="Void"/></f></close>
		<objectEncoding public="1"><t path="UInt"/></objectEncoding>
		<endian public="1"><e path="flash.utils.Endian"/></endian>
		<connected public="1" set="null"><e path="Bool"/></connected>
		<bytesAvailable public="1" set="null"><t path="UInt"/></bytesAvailable>
		<new public="1" set="method"><f a=""><e path="Void"/></f></new>
	</class>
	<class path="flash.net.URLVariables" params="" file="C:\Motion-Twin\Haxe/std/flash/net/URLVariables.hx" extern="1">
		<toString public="1" set="method"><f a=""><c path="String"/></f></toString>
		<decode public="1" set="method"><f a="source">
	<c path="String"/>
	<e path="Void"/>
</f></decode>
		<new public="1" set="method"><f a="?source">
	<c path="String"/>
	<e path="Void"/>
</f></new>
		<haxe_dynamic><d/></haxe_dynamic>
	</class>
	<class path="flash.system.ApplicationDomain" params="" file="C:\Motion-Twin\Haxe/std/flash/system/ApplicationDomain.hx" extern="1">
		<MIN_DOMAIN_MEMORY_LENGTH public="1" set="null" static="1">
			<t path="UInt"/>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</MIN_DOMAIN_MEMORY_LENGTH>
		<currentDomain public="1" set="null" static="1"><c path="flash.system.ApplicationDomain"/></currentDomain>
		<hasDefinition public="1" set="method"><f a="name">
	<c path="String"/>
	<e path="Bool"/>
</f></hasDefinition>
		<getQualifiedDefinitionNames public="1">
			<f a=""><c path="flash.Vector"><c path="String"/></c></f>
			<meta><m n=":require"><e>flash11_3</e></m></meta>
		</getQualifiedDefinitionNames>
		<getDefinition public="1" set="method"><f a="name">
	<c path="String"/>
	<d/>
</f></getDefinition>
		<parentDomain public="1" set="null"><c path="flash.system.ApplicationDomain"/></parentDomain>
		<domainMemory public="1">
			<c path="flash.utils.ByteArray"/>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</domainMemory>
		<new public="1" set="method"><f a="?parentDomain">
	<c path="flash.system.ApplicationDomain"/>
	<e path="Void"/>
</f></new>
		<meta><m n=":final"/></meta>
	</class>
	<class path="flash.system.IME" params="" file="C:\Motion-Twin\Haxe/std/flash/system/IME.hx" extern="1">
		<extends path="flash.events.EventDispatcher"/>
		<conversionMode public="1" static="1"><e path="flash.system.IMEConversionMode"/></conversionMode>
		<enabled public="1" static="1"><e path="Bool"/></enabled>
		<isSupported public="1" static="1">
			<e path="Bool"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</isSupported>
		<compositionAbandoned public="1" static="1">
			<f a=""><e path="Void"/></f>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</compositionAbandoned>
		<compositionSelectionChanged public="1" static="1">
			<f a="start:end">
				<c path="Int"/>
				<c path="Int"/>
				<e path="Void"/>
			</f>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</compositionSelectionChanged>
		<doConversion public="1" set="method" static="1"><f a=""><e path="Void"/></f></doConversion>
		<setCompositionString public="1" set="method" static="1"><f a="composition">
	<c path="String"/>
	<e path="Void"/>
</f></setCompositionString>
	</class>
	<enum path="flash.system.IMEConversionMode" params="" file="C:\Motion-Twin\Haxe/std/flash/system/IMEConversionMode.hx">
		<UNKNOWN/>
		<KOREAN/>
		<JAPANESE_KATAKANA_HALF/>
		<JAPANESE_KATAKANA_FULL/>
		<JAPANESE_HIRAGANA/>
		<CHINESE/>
		<ALPHANUMERIC_HALF/>
		<ALPHANUMERIC_FULL/>
		<meta><m n=":fakeEnum"><e>String</e></m></meta>
	</enum>
	<enum path="flash.system.ImageDecodingPolicy" params="" file="C:\Motion-Twin\Haxe/std/flash/system/ImageDecodingPolicy.hx">
		<ON_LOAD/>
		<ON_DEMAND/>
		<meta><m n=":fakeEnum"><e>String</e></m></meta>
	</enum>
	<class path="flash.system.LoaderContext" params="" file="C:\Motion-Twin\Haxe/std/flash/system/LoaderContext.hx" extern="1">
		<securityDomain public="1"><c path="flash.system.SecurityDomain"/></securityDomain>
		<requestedContentParent public="1">
			<c path="flash.display.DisplayObjectContainer"/>
			<meta><m n=":require"><e>flash11</e></m></meta>
		</requestedContentParent>
		<parameters public="1">
			<d/>
			<meta><m n=":require"><e>flash11</e></m></meta>
		</parameters>
		<imageDecodingPolicy public="1">
			<e path="flash.system.ImageDecodingPolicy"/>
			<meta><m n=":require"><e>flash11</e></m></meta>
		</imageDecodingPolicy>
		<checkPolicyFile public="1"><e path="Bool"/></checkPolicyFile>
		<applicationDomain public="1"><c path="flash.system.ApplicationDomain"/></applicationDomain>
		<allowLoadBytesCodeExecution public="1">
			<e path="Bool"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</allowLoadBytesCodeExecution>
		<allowCodeImport public="1">
			<e path="Bool"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</allowCodeImport>
		<new public="1" set="method"><f a="?checkPolicyFile:?applicationDomain:?securityDomain">
	<e path="Bool"/>
	<c path="flash.system.ApplicationDomain"/>
	<c path="flash.system.SecurityDomain"/>
	<e path="Void"/>
</f></new>
	</class>
	<class path="flash.system.SecurityDomain" params="" file="C:\Motion-Twin\Haxe/std/flash/system/SecurityDomain.hx" extern="1">
		<currentDomain public="1" set="null" static="1"><c path="flash.system.SecurityDomain"/></currentDomain>
		<domainID public="1">
			<c path="String"/>
			<meta><m n=":require"><e>flash11_3</e></m></meta>
		</domainID>
	</class>
	<class path="flash.system.System" params="" file="C:\Motion-Twin\Haxe/std/flash/system/System.hx" extern="1">
		<freeMemory public="1" static="1">
			<c path="Float"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</freeMemory>
		<ime public="1" set="null" static="1"><c path="flash.system.IME"/></ime>
		<privateMemory public="1" static="1">
			<c path="Float"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</privateMemory>
		<processCPUUsage public="1" static="1">
			<c path="Float"/>
			<meta><m n=":require"><e>flash11</e></m></meta>
		</processCPUUsage>
		<totalMemory public="1" set="null" static="1"><t path="UInt"/></totalMemory>
		<totalMemoryNumber public="1" static="1">
			<c path="Float"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</totalMemoryNumber>
		<useCodePage public="1" static="1"><e path="Bool"/></useCodePage>
		<vmVersion public="1" set="null" static="1"><c path="String"/></vmVersion>
		<disposeXML public="1" static="1">
			<f a="node">
				<c path="flash.xml.XML"/>
				<e path="Void"/>
			</f>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</disposeXML>
		<exit public="1" set="method" static="1"><f a="code">
	<t path="UInt"/>
	<e path="Void"/>
</f></exit>
		<gc public="1" set="method" static="1"><f a=""><e path="Void"/></f></gc>
		<pause public="1" set="method" static="1"><f a=""><e path="Void"/></f></pause>
		<pauseForGCIfCollectionImminent public="1" static="1">
			<f a="?imminence">
				<c path="Float"/>
				<e path="Void"/>
			</f>
			<meta><m n=":require"><e>flash11</e></m></meta>
		</pauseForGCIfCollectionImminent>
		<resume public="1" set="method" static="1"><f a=""><e path="Void"/></f></resume>
		<setClipboard public="1" set="method" static="1"><f a="string">
	<c path="String"/>
	<e path="Void"/>
</f></setClipboard>
	</class>
	<enum path="flash.system.TouchscreenType" params="" file="C:\Motion-Twin\Haxe/std/flash/system/TouchscreenType.hx">
		<STYLUS/>
		<NONE/>
		<FINGER/>
		<meta><m n=":fakeEnum"><e>String</e></m></meta>
	</enum>
	<enum path="flash.text.AntiAliasType" params="" file="C:\Motion-Twin\Haxe/std/flash/text/AntiAliasType.hx">
		<NORMAL/>
		<ADVANCED/>
		<meta><m n=":fakeEnum"><e>String</e></m></meta>
	</enum>
	<enum path="flash.text.GridFitType" params="" file="C:\Motion-Twin\Haxe/std/flash/text/GridFitType.hx">
		<SUBPIXEL/>
		<PIXEL/>
		<NONE/>
		<meta><m n=":fakeEnum"><e>String</e></m></meta>
	</enum>
	<class path="flash.text.StyleSheet" params="" file="C:\Motion-Twin\Haxe/std/flash/text/StyleSheet.hx" extern="1">
		<extends path="flash.events.EventDispatcher"/>
		<transform public="1" set="method"><f a="formatObject">
	<d/>
	<c path="flash.text.TextFormat"/>
</f></transform>
		<setStyle public="1" set="method"><f a="styleName:styleObject">
	<c path="String"/>
	<d/>
	<e path="Void"/>
</f></setStyle>
		<parseCSS public="1" set="method"><f a="CSSText">
	<c path="String"/>
	<e path="Void"/>
</f></parseCSS>
		<getStyle public="1" set="method"><f a="styleName">
	<c path="String"/>
	<d/>
</f></getStyle>
		<clear public="1" set="method"><f a=""><e path="Void"/></f></clear>
		<styleNames public="1" set="null"><c path="Array"><d/></c></styleNames>
		<new public="1" set="method"><f a=""><e path="Void"/></f></new>
		<haxe_dynamic><d/></haxe_dynamic>
	</class>
	<class path="flash.text.TextField" params="" file="C:\Motion-Twin\Haxe/std/flash/text/TextField.hx" extern="1">
		<extends path="flash.display.InteractiveObject"/>
		<isFontCompatible public="1" set="method" static="1">
			<f a="fontName:fontStyle">
				<c path="String"/>
				<c path="String"/>
				<e path="Bool"/>
			</f>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</isFontCompatible>
		<setTextFormat public="1" set="method"><f a="format:?beginIndex:?endIndex">
	<c path="flash.text.TextFormat"/>
	<c path="Int"/>
	<c path="Int"/>
	<e path="Void"/>
</f></setTextFormat>
		<setSelection public="1" set="method"><f a="beginIndex:endIndex">
	<c path="Int"/>
	<c path="Int"/>
	<e path="Void"/>
</f></setSelection>
		<replaceText public="1" set="method"><f a="beginIndex:endIndex:newText">
	<c path="Int"/>
	<c path="Int"/>
	<c path="String"/>
	<e path="Void"/>
</f></replaceText>
		<replaceSelectedText public="1" set="method"><f a="value">
	<c path="String"/>
	<e path="Void"/>
</f></replaceSelectedText>
		<pasteRichText public="1" set="method"><f a="richText">
	<c path="String"/>
	<e path="Bool"/>
</f></pasteRichText>
		<insertXMLText public="1" set="method"><f a="beginIndex:endIndex:richText:?pasting">
	<c path="Int"/>
	<c path="Int"/>
	<c path="String"/>
	<e path="Bool"/>
	<e path="Void"/>
</f></insertXMLText>
		<getXMLText public="1" set="method"><f a="?beginIndex:?endIndex">
	<c path="Int"/>
	<c path="Int"/>
	<c path="String"/>
</f></getXMLText>
		<getTextRuns public="1" set="method"><f a="?beginIndex:?endIndex">
	<c path="Int"/>
	<c path="Int"/>
	<c path="Array"><d/></c>
</f></getTextRuns>
		<getTextFormat public="1" set="method"><f a="?beginIndex:?endIndex">
	<c path="Int"/>
	<c path="Int"/>
	<c path="flash.text.TextFormat"/>
</f></getTextFormat>
		<getRawText public="1" set="method"><f a=""><c path="String"/></f></getRawText>
		<getParagraphLength public="1" set="method"><f a="charIndex">
	<c path="Int"/>
	<c path="Int"/>
</f></getParagraphLength>
		<getLineText public="1" set="method"><f a="lineIndex">
	<c path="Int"/>
	<c path="String"/>
</f></getLineText>
		<getLineOffset public="1" set="method"><f a="lineIndex">
	<c path="Int"/>
	<c path="Int"/>
</f></getLineOffset>
		<getLineMetrics public="1" set="method"><f a="lineIndex">
	<c path="Int"/>
	<c path="flash.text.TextLineMetrics"/>
</f></getLineMetrics>
		<getLineLength public="1" set="method"><f a="lineIndex">
	<c path="Int"/>
	<c path="Int"/>
</f></getLineLength>
		<getLineIndexOfChar public="1" set="method"><f a="charIndex">
	<c path="Int"/>
	<c path="Int"/>
</f></getLineIndexOfChar>
		<getLineIndexAtPoint public="1" set="method"><f a="x:y">
	<c path="Float"/>
	<c path="Float"/>
	<c path="Int"/>
</f></getLineIndexAtPoint>
		<getImageReference public="1" set="method"><f a="id">
	<c path="String"/>
	<c path="flash.display.DisplayObject"/>
</f></getImageReference>
		<getFirstCharInParagraph public="1" set="method"><f a="charIndex">
	<c path="Int"/>
	<c path="Int"/>
</f></getFirstCharInParagraph>
		<getCharIndexAtPoint public="1" set="method"><f a="x:y">
	<c path="Float"/>
	<c path="Float"/>
	<c path="Int"/>
</f></getCharIndexAtPoint>
		<getCharBoundaries public="1" set="method"><f a="charIndex">
	<c path="Int"/>
	<c path="flash.geom.Rectangle"/>
</f></getCharBoundaries>
		<copyRichText public="1" set="method"><f a=""><c path="String"/></f></copyRichText>
		<appendText public="1" set="method"><f a="newText">
	<c path="String"/>
	<e path="Void"/>
</f></appendText>
		<wordWrap public="1"><e path="Bool"/></wordWrap>
		<useRichTextClipboard public="1"><e path="Bool"/></useRichTextClipboard>
		<type public="1"><e path="flash.text.TextFieldType"/></type>
		<thickness public="1"><c path="Float"/></thickness>
		<textWidth public="1" set="null"><c path="Float"/></textWidth>
		<textInteractionMode public="1">
			<e path="flash.text.TextInteractionMode"/>
			<meta><m n=":require"><e>flash11</e></m></meta>
		</textInteractionMode>
		<textHeight public="1" set="null"><c path="Float"/></textHeight>
		<textColor public="1"><t path="UInt"/></textColor>
		<text public="1"><c path="String"/></text>
		<styleSheet public="1"><c path="flash.text.StyleSheet"/></styleSheet>
		<sharpness public="1"><c path="Float"/></sharpness>
		<selectionEndIndex public="1" set="null"><c path="Int"/></selectionEndIndex>
		<selectionBeginIndex public="1" set="null"><c path="Int"/></selectionBeginIndex>
		<selectedText public="1" set="null"><c path="String"/></selectedText>
		<selectable public="1"><e path="Bool"/></selectable>
		<scrollV public="1"><c path="Int"/></scrollV>
		<scrollH public="1"><c path="Int"/></scrollH>
		<restrict public="1"><c path="String"/></restrict>
		<numLines public="1" set="null"><c path="Int"/></numLines>
		<multiline public="1"><e path="Bool"/></multiline>
		<mouseWheelEnabled public="1"><e path="Bool"/></mouseWheelEnabled>
		<maxScrollV public="1" set="null"><c path="Int"/></maxScrollV>
		<maxScrollH public="1" set="null"><c path="Int"/></maxScrollH>
		<maxChars public="1"><c path="Int"/></maxChars>
		<length public="1" set="null"><c path="Int"/></length>
		<htmlText public="1"><c path="String"/></htmlText>
		<gridFitType public="1"><e path="flash.text.GridFitType"/></gridFitType>
		<embedFonts public="1"><e path="Bool"/></embedFonts>
		<displayAsPassword public="1"><e path="Bool"/></displayAsPassword>
		<defaultTextFormat public="1"><c path="flash.text.TextFormat"/></defaultTextFormat>
		<condenseWhite public="1"><e path="Bool"/></condenseWhite>
		<caretIndex public="1" set="null"><c path="Int"/></caretIndex>
		<bottomScrollV public="1" set="null"><c path="Int"/></bottomScrollV>
		<borderColor public="1"><t path="UInt"/></borderColor>
		<border public="1"><e path="Bool"/></border>
		<backgroundColor public="1"><t path="UInt"/></backgroundColor>
		<background public="1"><e path="Bool"/></background>
		<autoSize public="1"><e path="flash.text.TextFieldAutoSize"/></autoSize>
		<antiAliasType public="1"><e path="flash.text.AntiAliasType"/></antiAliasType>
		<alwaysShowSelection public="1"><e path="Bool"/></alwaysShowSelection>
		<new public="1" set="method"><f a=""><e path="Void"/></f></new>
	</class>
	<enum path="flash.text.TextFieldAutoSize" params="" file="C:\Motion-Twin\Haxe/std/flash/text/TextFieldAutoSize.hx">
		<RIGHT/>
		<NONE/>
		<LEFT/>
		<CENTER/>
		<meta><m n=":fakeEnum"><e>String</e></m></meta>
	</enum>
	<enum path="flash.text.TextFieldType" params="" file="C:\Motion-Twin\Haxe/std/flash/text/TextFieldType.hx">
		<INPUT/>
		<DYNAMIC/>
		<meta><m n=":fakeEnum"><e>String</e></m></meta>
	</enum>
	<class path="flash.text.TextFormat" params="" file="C:\Motion-Twin\Haxe/std/flash/text/TextFormat.hx" extern="1">
		<url public="1"><c path="String"/></url>
		<underline public="1"><t path="Null"><e path="Bool"/></t></underline>
		<target public="1"><c path="String"/></target>
		<tabStops public="1"><c path="Array"><t path="UInt"/></c></tabStops>
		<size public="1"><t path="Null"><c path="Float"/></t></size>
		<rightMargin public="1"><t path="Null"><c path="Float"/></t></rightMargin>
		<letterSpacing public="1"><t path="Null"><c path="Float"/></t></letterSpacing>
		<leftMargin public="1"><t path="Null"><c path="Float"/></t></leftMargin>
		<leading public="1"><t path="Null"><c path="Float"/></t></leading>
		<kerning public="1"><t path="Null"><e path="Bool"/></t></kerning>
		<italic public="1"><t path="Null"><e path="Bool"/></t></italic>
		<indent public="1"><t path="Null"><c path="Float"/></t></indent>
		<font public="1"><c path="String"/></font>
		<display public="1"><e path="flash.text.TextFormatDisplay"/></display>
		<color public="1"><t path="Null"><t path="UInt"/></t></color>
		<bullet public="1"><t path="Null"><e path="Bool"/></t></bullet>
		<bold public="1"><t path="Null"><e path="Bool"/></t></bold>
		<blockIndent public="1"><t path="Null"><c path="Float"/></t></blockIndent>
		<align public="1"><e path="flash.text.TextFormatAlign"/></align>
		<new public="1" set="method"><f a="?font:?size:?color:?bold:?italic:?underline:?url:?target:?align:?leftMargin:?rightMargin:?indent:?leading">
	<c path="String"/>
	<c path="Float"/>
	<t path="UInt"/>
	<e path="Bool"/>
	<e path="Bool"/>
	<e path="Bool"/>
	<c path="String"/>
	<c path="String"/>
	<e path="flash.text.TextFormatAlign"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<e path="Void"/>
</f></new>
	</class>
	<enum path="flash.text.TextFormatAlign" params="" file="C:\Motion-Twin\Haxe/std/flash/text/TextFormatAlign.hx">
		<START/>
		<RIGHT/>
		<LEFT/>
		<JUSTIFY/>
		<END/>
		<CENTER/>
		<meta><m n=":fakeEnum"><e>String</e></m></meta>
	</enum>
	<enum path="flash.text.TextFormatDisplay" params="" file="C:\Motion-Twin\Haxe/std/flash/text/TextFormatDisplay.hx">
		<INLINE/>
		<BLOCK/>
		<meta><m n=":fakeEnum"><e>String</e></m></meta>
	</enum>
	<enum path="flash.text.TextInteractionMode" params="" file="C:\Motion-Twin\Haxe/std/flash/text/TextInteractionMode.hx">
		<SELECTION/>
		<NORMAL/>
		<meta><m n=":fakeEnum"><e>String</e></m></meta>
	</enum>
	<class path="flash.text.TextLineMetrics" params="" file="C:\Motion-Twin\Haxe/std/flash/text/TextLineMetrics.hx" extern="1">
		<x public="1"><c path="Float"/></x>
		<width public="1"><c path="Float"/></width>
		<leading public="1"><c path="Float"/></leading>
		<height public="1"><c path="Float"/></height>
		<descent public="1"><c path="Float"/></descent>
		<ascent public="1"><c path="Float"/></ascent>
		<new public="1" set="method"><f a="x:width:height:ascent:descent:leading">
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<e path="Void"/>
</f></new>
	</class>
	<class path="flash.text.TextSnapshot" params="" file="C:\Motion-Twin\Haxe/std/flash/text/TextSnapshot.hx" extern="1">
		<setSelected public="1" set="method"><f a="beginIndex:endIndex:select">
	<c path="Int"/>
	<c path="Int"/>
	<e path="Bool"/>
	<e path="Void"/>
</f></setSelected>
		<setSelectColor public="1" set="method"><f a="?hexColor">
	<t path="UInt"/>
	<e path="Void"/>
</f></setSelectColor>
		<hitTestTextNearPos public="1" set="method"><f a="x:y:?maxDistance">
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
</f></hitTestTextNearPos>
		<getTextRunInfo public="1" set="method"><f a="beginIndex:endIndex">
	<c path="Int"/>
	<c path="Int"/>
	<c path="Array"><d/></c>
</f></getTextRunInfo>
		<getText public="1" set="method"><f a="beginIndex:endIndex:?includeLineEndings">
	<c path="Int"/>
	<c path="Int"/>
	<e path="Bool"/>
	<c path="String"/>
</f></getText>
		<getSelectedText public="1" set="method"><f a="?includeLineEndings">
	<e path="Bool"/>
	<c path="String"/>
</f></getSelectedText>
		<getSelected public="1" set="method"><f a="beginIndex:endIndex">
	<c path="Int"/>
	<c path="Int"/>
	<e path="Bool"/>
</f></getSelected>
		<findText public="1" set="method"><f a="beginIndex:textToFind:caseSensitive">
	<c path="Int"/>
	<c path="String"/>
	<e path="Bool"/>
	<c path="Int"/>
</f></findText>
		<charCount public="1" set="null"><c path="Int"/></charCount>
		<new public="1" set="method"><f a=""><e path="Void"/></f></new>
	</class>
	<class path="flash.ui.ContextMenu" params="" file="C:\Motion-Twin\Haxe/std/flash/ui/ContextMenu.hx" extern="1">
		<extends path="flash.display.NativeMenu"/>
		<isSupported public="1" static="1">
			<e path="Bool"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</isSupported>
		<hideBuiltInItems public="1" set="method"><f a=""><e path="Void"/></f></hideBuiltInItems>
		<clone public="1" set="method"><f a=""><c path="flash.ui.ContextMenu"/></f></clone>
		<link public="1">
			<c path="flash.net.URLRequest"/>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</link>
		<customItems public="1"><c path="Array"><d/></c></customItems>
		<clipboardMenu public="1">
			<e path="Bool"/>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</clipboardMenu>
		<clipboardItems public="1">
			<c path="flash.ui.ContextMenuClipboardItems"/>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</clipboardItems>
		<builtInItems public="1"><c path="flash.ui.ContextMenuBuiltInItems"/></builtInItems>
		<new public="1" set="method"><f a=""><e path="Void"/></f></new>
		<meta><m n=":final"/></meta>
	</class>
	<class path="flash.ui.ContextMenuBuiltInItems" params="" file="C:\Motion-Twin\Haxe/std/flash/ui/ContextMenuBuiltInItems.hx" extern="1">
		<clone public="1" set="method"><f a=""><c path="flash.ui.ContextMenuBuiltInItems"/></f></clone>
		<zoom public="1"><e path="Bool"/></zoom>
		<save public="1"><e path="Bool"/></save>
		<rewind public="1"><e path="Bool"/></rewind>
		<quality public="1"><e path="Bool"/></quality>
		<print public="1"><e path="Bool"/></print>
		<play public="1"><e path="Bool"/></play>
		<loop public="1"><e path="Bool"/></loop>
		<forwardAndBack public="1"><e path="Bool"/></forwardAndBack>
		<new public="1" set="method"><f a=""><e path="Void"/></f></new>
		<meta><m n=":final"/></meta>
	</class>
	<class path="flash.ui.ContextMenuClipboardItems" params="" file="C:\Motion-Twin\Haxe/std/flash/ui/ContextMenuClipboardItems.hx" extern="1">
		<clone public="1" set="method"><f a=""><c path="flash.ui.ContextMenuClipboardItems"/></f></clone>
		<selectAll public="1"><e path="Bool"/></selectAll>
		<paste public="1"><e path="Bool"/></paste>
		<cut public="1"><e path="Bool"/></cut>
		<copy public="1"><e path="Bool"/></copy>
		<clear public="1"><e path="Bool"/></clear>
		<new public="1" set="method"><f a=""><e path="Void"/></f></new>
		<meta><m n=":final"/></meta>
	</class>
	<enum path="flash.ui.KeyLocation" params="" file="C:\Motion-Twin\Haxe/std/flash/ui/KeyLocation.hx">
		<STANDARD/>
		<RIGHT/>
		<NUM_PAD/>
		<LEFT/>
		<D_PAD/>
		<meta><m n=":fakeEnum"><e>UInt</e></m></meta>
	</enum>
	<class path="flash.ui.Mouse" params="" file="C:\Motion-Twin\Haxe/std/flash/ui/Mouse.hx" extern="1">
		<cursor public="1" static="1">
			<d/>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</cursor>
		<supportsCursor public="1" static="1">
			<e path="Bool"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</supportsCursor>
		<supportsNativeCursor public="1" static="1">
			<e path="Bool"/>
			<meta><m n=":require"><e>flash11</e></m></meta>
		</supportsNativeCursor>
		<hide public="1" set="method" static="1"><f a=""><e path="Void"/></f></hide>
		<registerCursor public="1" static="1">
			<f a="name:cursor">
				<c path="String"/>
				<c path="flash.ui.MouseCursorData"/>
				<e path="Void"/>
			</f>
			<meta><m n=":require"><e>flash10_2</e></m></meta>
		</registerCursor>
		<show public="1" set="method" static="1"><f a=""><e path="Void"/></f></show>
		<unregisterCursor public="1" static="1">
			<f a="name">
				<c path="String"/>
				<e path="Void"/>
			</f>
			<meta><m n=":require"><e>flash11</e></m></meta>
		</unregisterCursor>
	</class>
	<class path="flash.ui.MouseCursor" params="" file="C:\Motion-Twin\Haxe/std/flash/ui/MouseCursor.hx" extern="1">
		<ARROW public="1" static="1"><c path="String"/></ARROW>
		<AUTO public="1" static="1"><c path="String"/></AUTO>
		<BUTTON public="1" static="1"><c path="String"/></BUTTON>
		<HAND public="1" static="1"><c path="String"/></HAND>
		<IBEAM public="1" static="1"><c path="String"/></IBEAM>
	</class>
	<class path="flash.ui.MouseCursorData" params="" file="C:\Motion-Twin\Haxe/std/flash/ui/MouseCursorData.hx" extern="1">
		<hotSpot public="1"><c path="flash.geom.Point"/></hotSpot>
		<frameRate public="1"><c path="Float"/></frameRate>
		<data public="1"><c path="flash.Vector"><c path="flash.display.BitmapData"/></c></data>
		<new public="1"><f a=""><e path="Void"/></f></new>
		<meta>
			<m n=":final"/>
			<m n=":require"><e>flash10_2</e></m>
		</meta>
	</class>
	<class path="flash.utils.ByteArray" params="" file="C:\Motion-Twin\Haxe/std/flash/utils/ByteArray.hx" extern="1">
		<implements path="flash.utils.IDataInput"/>
		<implements path="flash.utils.IDataOutput"/>
		<defaultObjectEncoding public="1" static="1"><t path="UInt"/></defaultObjectEncoding>
		<writeUnsignedInt public="1" set="method"><f a="value">
	<t path="UInt"/>
	<e path="Void"/>
</f></writeUnsignedInt>
		<writeUTFBytes public="1" set="method"><f a="value">
	<c path="String"/>
	<e path="Void"/>
</f></writeUTFBytes>
		<writeUTF public="1" set="method"><f a="value">
	<c path="String"/>
	<e path="Void"/>
</f></writeUTF>
		<writeShort public="1" set="method"><f a="value">
	<c path="Int"/>
	<e path="Void"/>
</f></writeShort>
		<writeObject public="1" set="method"><f a="object">
	<d/>
	<e path="Void"/>
</f></writeObject>
		<writeMultiByte public="1" set="method"><f a="value:charSet">
	<c path="String"/>
	<c path="String"/>
	<e path="Void"/>
</f></writeMultiByte>
		<writeInt public="1" set="method"><f a="value">
	<c path="Int"/>
	<e path="Void"/>
</f></writeInt>
		<writeFloat public="1" set="method"><f a="value">
	<c path="Float"/>
	<e path="Void"/>
</f></writeFloat>
		<writeDouble public="1" set="method"><f a="value">
	<c path="Float"/>
	<e path="Void"/>
</f></writeDouble>
		<writeBytes public="1" set="method"><f a="bytes:?offset:?length">
	<c path="flash.utils.ByteArray"/>
	<t path="UInt"/>
	<t path="UInt"/>
	<e path="Void"/>
</f></writeBytes>
		<writeByte public="1" set="method"><f a="value">
	<c path="Int"/>
	<e path="Void"/>
</f></writeByte>
		<writeBoolean public="1" set="method"><f a="value">
	<e path="Bool"/>
	<e path="Void"/>
</f></writeBoolean>
		<uncompress public="1" set="method"><f a=""><e path="Void"/></f></uncompress>
		<toString public="1" set="method"><f a=""><c path="String"/></f></toString>
		<readUnsignedShort public="1" set="method"><f a=""><t path="UInt"/></f></readUnsignedShort>
		<readUnsignedInt public="1" set="method"><f a=""><t path="UInt"/></f></readUnsignedInt>
		<readUnsignedByte public="1" set="method"><f a=""><t path="UInt"/></f></readUnsignedByte>
		<readUTFBytes public="1" set="method"><f a="length">
	<t path="UInt"/>
	<c path="String"/>
</f></readUTFBytes>
		<readUTF public="1" set="method"><f a=""><c path="String"/></f></readUTF>
		<readShort public="1" set="method"><f a=""><c path="Int"/></f></readShort>
		<readObject public="1" set="method"><f a=""><d/></f></readObject>
		<readMultiByte public="1" set="method"><f a="length:charSet">
	<t path="UInt"/>
	<c path="String"/>
	<c path="String"/>
</f></readMultiByte>
		<readInt public="1" set="method"><f a=""><c path="Int"/></f></readInt>
		<readFloat public="1" set="method"><f a=""><c path="Float"/></f></readFloat>
		<readDouble public="1" set="method"><f a=""><c path="Float"/></f></readDouble>
		<readBytes public="1" set="method"><f a="bytes:?offset:?length">
	<c path="flash.utils.ByteArray"/>
	<t path="UInt"/>
	<t path="UInt"/>
	<e path="Void"/>
</f></readBytes>
		<readByte public="1" set="method"><f a=""><c path="Int"/></f></readByte>
		<readBoolean public="1" set="method"><f a=""><e path="Bool"/></f></readBoolean>
		<inflate public="1" set="method">
			<f a=""><e path="Void"/></f>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</inflate>
		<deflate public="1" set="method">
			<f a=""><e path="Void"/></f>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</deflate>
		<compress public="1" set="method"><f a=""><e path="Void"/></f></compress>
		<clear public="1" set="method">
			<f a=""><e path="Void"/></f>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</clear>
		<position public="1"><t path="UInt"/></position>
		<objectEncoding public="1"><t path="UInt"/></objectEncoding>
		<length public="1"><t path="UInt"/></length>
		<endian public="1"><e path="flash.utils.Endian"/></endian>
		<bytesAvailable public="1" set="null"><t path="UInt"/></bytesAvailable>
		<new public="1" set="method"><f a=""><e path="Void"/></f></new>
	</class>
	<enum path="flash.utils.Endian" params="" file="C:\Motion-Twin\Haxe/std/flash/utils/Endian.hx">
		<LITTLE_ENDIAN/>
		<BIG_ENDIAN/>
		<meta><m n=":fakeEnum"><e>String</e></m></meta>
	</enum>
	<class path="flash.utils.Namespace" params="" file="C:\Motion-Twin\Haxe/std/flash/utils/Namespace.hx" extern="1">
		<uri public="1" set="null"><c path="String"/></uri>
		<prefix public="1" set="null"><d/></prefix>
		<new public="1" set="method"><f a="?prefix:?uri">
	<d/>
	<d/>
	<e path="Void"/>
</f></new>
		<meta><m n=":final"/></meta>
	</class>
	<class path="flash.utils.QName" params="" file="C:\Motion-Twin\Haxe/std/flash/utils/QName.hx" extern="1">
		<uri public="1" set="null"><d/></uri>
		<localName public="1" set="null"><c path="String"/></localName>
		<new public="1" set="method"><f a="?namespace:?name">
	<d/>
	<d/>
	<e path="Void"/>
</f></new>
		<meta><m n=":final"/></meta>
	</class>
	<class path="flash.utils.RegExp" params="" file="C:\Motion-Twin\Haxe/std/flash/utils/RegExp.hx" extern="1">
		<test public="1" set="method">
			<f a="?s">
				<c path="String"/>
				<e path="Bool"/>
			</f>
			<meta><m n=":ns"><e>http://adobe.com/AS3/2006/builtin</e></m></meta>
		</test>
		<exec public="1" set="method">
			<f a="?s">
				<c path="String"/>
				<d/>
			</f>
			<meta><m n=":ns"><e>http://adobe.com/AS3/2006/builtin</e></m></meta>
		</exec>
		<source public="1" set="null"><c path="String"/></source>
		<multiline public="1" set="null"><e path="Bool"/></multiline>
		<lastIndex public="1"><c path="Int"/></lastIndex>
		<ignoreCase public="1" set="null"><e path="Bool"/></ignoreCase>
		<global public="1" set="null"><e path="Bool"/></global>
		<extended public="1" set="null"><e path="Bool"/></extended>
		<dotall public="1" set="null"><e path="Bool"/></dotall>
		<new public="1" set="method"><f a="?pattern:?options">
	<d/>
	<d/>
	<e path="Void"/>
</f></new>
		<meta><m n=":native"><e>RegExp</e></m></meta>
		<haxe_dynamic><d/></haxe_dynamic>
	</class>
	<class path="flash.xml.XML" params="" file="C:\Motion-Twin\Haxe/std/flash/xml/XML.hx" extern="1">
		<ignoreComments public="1" static="1"><e path="Bool"/></ignoreComments>
		<ignoreProcessingInstructions public="1" static="1"><e path="Bool"/></ignoreProcessingInstructions>
		<ignoreWhitespace public="1" static="1"><e path="Bool"/></ignoreWhitespace>
		<prettyIndent public="1" static="1"><c path="Int"/></prettyIndent>
		<prettyPrinting public="1" static="1"><e path="Bool"/></prettyPrinting>
		<defaultSettings public="1" set="method" static="1"><f a=""><d/></f></defaultSettings>
		<setSettings public="1" set="method" static="1"><f a="?o">
	<d/>
	<e path="Void"/>
</f></setSettings>
		<settings public="1" set="method" static="1"><f a=""><d/></f></settings>
		<valueOf public="1" set="method"><f a=""><c path="flash.xml.XML"/></f></valueOf>
		<toXMLString public="1" set="method"><f a=""><c path="String"/></f></toXMLString>
		<toString public="1" set="method"><f a=""><c path="String"/></f></toString>
		<toJSON public="1">
			<f a="k">
				<c path="String"/>
				<d/>
			</f>
			<meta><m n=":require"><e>flash11</e></m></meta>
		</toJSON>
		<text public="1" set="method"><f a=""><c path="flash.xml.XMLList"/></f></text>
		<setNotification public="1" set="method"><f a="f">
	<d/>
	<d/>
</f></setNotification>
		<setNamespace public="1" set="method"><f a="ns">
	<d/>
	<e path="Void"/>
</f></setNamespace>
		<setName public="1" set="method"><f a="name">
	<d/>
	<e path="Void"/>
</f></setName>
		<setLocalName public="1" set="method"><f a="name">
	<d/>
	<e path="Void"/>
</f></setLocalName>
		<setChildren public="1" set="method"><f a="value">
	<d/>
	<c path="flash.xml.XML"/>
</f></setChildren>
		<replace public="1" set="method"><f a="propertyName:value">
	<d/>
	<d/>
	<c path="flash.xml.XML"/>
</f></replace>
		<removeNamespace public="1" set="method"><f a="ns">
	<d/>
	<c path="flash.xml.XML"/>
</f></removeNamespace>
		<processingInstructions public="1" set="method"><f a="?name">
	<d/>
	<c path="flash.xml.XMLList"/>
</f></processingInstructions>
		<prependChild public="1" set="method"><f a="value">
	<d/>
	<c path="flash.xml.XML"/>
</f></prependChild>
		<parent public="1" set="method"><f a=""><c path="flash.xml.XML"/></f></parent>
		<notification public="1" set="method"><f a=""><d/></f></notification>
		<normalize public="1" set="method"><f a=""><c path="flash.xml.XML"/></f></normalize>
		<nodeKind public="1" set="method"><f a=""><c path="String"/></f></nodeKind>
		<namespaceDeclarations public="1" set="method"><f a=""><c path="Array"><d/></c></f></namespaceDeclarations>
		<namespace public="1" set="method"><f a="?prefix">
	<d/>
	<c path="flash.utils.Namespace"/>
</f></namespace>
		<name public="1" set="method"><f a=""><d/></f></name>
		<localName public="1" set="method"><f a=""><d/></f></localName>
		<length public="1" set="method"><f a=""><c path="Int"/></f></length>
		<insertChildBefore public="1" set="method"><f a="child1:child2">
	<d/>
	<d/>
	<d/>
</f></insertChildBefore>
		<insertChildAfter public="1" set="method"><f a="child1:child2">
	<d/>
	<d/>
	<d/>
</f></insertChildAfter>
		<inScopeNamespaces public="1" set="method"><f a=""><c path="Array"><d/></c></f></inScopeNamespaces>
		<hasSimpleContent public="1" set="method"><f a=""><e path="Bool"/></f></hasSimpleContent>
		<hasComplexContent public="1" set="method"><f a=""><e path="Bool"/></f></hasComplexContent>
		<elements public="1" set="method"><f a="?name">
	<d/>
	<c path="flash.xml.XMLList"/>
</f></elements>
		<descendants public="1" set="method"><f a="?name">
	<d/>
	<c path="flash.xml.XMLList"/>
</f></descendants>
		<copy public="1" set="method"><f a=""><c path="flash.xml.XML"/></f></copy>
		<contains public="1" set="method"><f a="value">
	<d/>
	<e path="Bool"/>
</f></contains>
		<comments public="1" set="method"><f a=""><c path="flash.xml.XMLList"/></f></comments>
		<children public="1" set="method"><f a=""><c path="flash.xml.XMLList"/></f></children>
		<childIndex public="1" set="method"><f a=""><c path="Int"/></f></childIndex>
		<child public="1" set="method"><f a="propertyName">
	<d/>
	<c path="flash.xml.XMLList"/>
</f></child>
		<attributes public="1" set="method"><f a=""><c path="flash.xml.XMLList"/></f></attributes>
		<attribute public="1" set="method"><f a="arg">
	<d/>
	<c path="flash.xml.XMLList"/>
</f></attribute>
		<appendChild public="1" set="method"><f a="child">
	<d/>
	<c path="flash.xml.XML"/>
</f></appendChild>
		<addNamespace public="1" set="method"><f a="ns">
	<d/>
	<c path="flash.xml.XML"/>
</f></addNamespace>
		<new public="1" set="method"><f a="?value">
	<d/>
	<e path="Void"/>
</f></new>
		<meta><m n=":final"/></meta>
		<haxe_dynamic><c path="flash.xml.XMLList"/></haxe_dynamic>
	</class>
	<class path="flash.xml.XMLList" params="" file="C:\Motion-Twin\Haxe/std/flash/xml/XMLList.hx" extern="1">
		<valueOf public="1" set="method"><f a=""><c path="flash.xml.XMLList"/></f></valueOf>
		<toXMLString public="1" set="method"><f a=""><c path="String"/></f></toXMLString>
		<toString public="1" set="method"><f a=""><c path="String"/></f></toString>
		<toJSON public="1">
			<f a="k">
				<c path="String"/>
				<d/>
			</f>
			<meta><m n=":require"><e>flash11</e></m></meta>
		</toJSON>
		<text public="1" set="method"><f a=""><c path="flash.xml.XMLList"/></f></text>
		<setNamespace public="1" set="method"><f a="ns">
	<d/>
	<e path="Void"/>
</f></setNamespace>
		<setName public="1" set="method"><f a="name">
	<d/>
	<e path="Void"/>
</f></setName>
		<setLocalName public="1" set="method"><f a="name">
	<d/>
	<e path="Void"/>
</f></setLocalName>
		<setChildren public="1" set="method"><f a="value">
	<d/>
	<c path="flash.xml.XML"/>
</f></setChildren>
		<replace public="1" set="method"><f a="propertyName:value">
	<d/>
	<d/>
	<c path="flash.xml.XML"/>
</f></replace>
		<removeNamespace public="1" set="method"><f a="ns">
	<d/>
	<c path="flash.xml.XML"/>
</f></removeNamespace>
		<processingInstructions public="1" set="method"><f a="?name">
	<d/>
	<c path="flash.xml.XMLList"/>
</f></processingInstructions>
		<prependChild public="1" set="method"><f a="value">
	<d/>
	<c path="flash.xml.XML"/>
</f></prependChild>
		<parent public="1" set="method"><f a=""><c path="flash.xml.XML"/></f></parent>
		<normalize public="1" set="method"><f a=""><c path="flash.xml.XMLList"/></f></normalize>
		<nodeKind public="1" set="method"><f a=""><c path="String"/></f></nodeKind>
		<namespaceDeclarations public="1" set="method"><f a=""><c path="Array"><d/></c></f></namespaceDeclarations>
		<namespace public="1" set="method"><f a="?prefix">
	<d/>
	<c path="flash.utils.Namespace"/>
</f></namespace>
		<name public="1" set="method"><f a=""><d/></f></name>
		<localName public="1" set="method"><f a=""><d/></f></localName>
		<length public="1" set="method"><f a=""><c path="Int"/></f></length>
		<insertChildBefore public="1" set="method"><f a="child1:child2">
	<d/>
	<d/>
	<d/>
</f></insertChildBefore>
		<insertChildAfter public="1" set="method"><f a="child1:child2">
	<d/>
	<d/>
	<d/>
</f></insertChildAfter>
		<inScopeNamespaces public="1" set="method"><f a=""><c path="Array"><d/></c></f></inScopeNamespaces>
		<hasSimpleContent public="1" set="method"><f a=""><e path="Bool"/></f></hasSimpleContent>
		<hasComplexContent public="1" set="method"><f a=""><e path="Bool"/></f></hasComplexContent>
		<elements public="1" set="method"><f a="?name">
	<d/>
	<c path="flash.xml.XMLList"/>
</f></elements>
		<descendants public="1" set="method"><f a="?name">
	<d/>
	<c path="flash.xml.XMLList"/>
</f></descendants>
		<copy public="1" set="method"><f a=""><c path="flash.xml.XMLList"/></f></copy>
		<contains public="1" set="method"><f a="value">
	<d/>
	<e path="Bool"/>
</f></contains>
		<comments public="1" set="method"><f a=""><c path="flash.xml.XMLList"/></f></comments>
		<children public="1" set="method"><f a=""><c path="flash.xml.XMLList"/></f></children>
		<childIndex public="1" set="method"><f a=""><c path="Int"/></f></childIndex>
		<child public="1" set="method"><f a="propertyName">
	<d/>
	<c path="flash.xml.XMLList"/>
</f></child>
		<attributes public="1" set="method"><f a=""><c path="flash.xml.XMLList"/></f></attributes>
		<attribute public="1" set="method"><f a="arg">
	<d/>
	<c path="flash.xml.XMLList"/>
</f></attribute>
		<appendChild public="1" set="method"><f a="child">
	<d/>
	<c path="flash.xml.XML"/>
</f></appendChild>
		<addNamespace public="1" set="method"><f a="ns">
	<d/>
	<c path="flash.xml.XML"/>
</f></addNamespace>
		<new public="1" set="method"><f a="?value">
	<d/>
	<e path="Void"/>
</f></new>
		<meta><m n=":final"/></meta>
	</class>
	<class path="haxe.Int32" params="" file="C:\Motion-Twin\Haxe/std/haxe/Int32.hx">
		<make public="1" get="inline" set="null" line="29" static="1"><f a="a:b">
	<c path="Int"/>
	<c path="Int"/>
	<c path="haxe.Int32"/>
</f></make>
		<ofInt public="1" get="inline" set="null" line="33" static="1"><f a="x">
	<c path="Int"/>
	<c path="haxe.Int32"/>
</f></ofInt>
		<clamp get="inline" set="null" line="37" static="1"><f a="x">
	<c path="haxe.Int32"/>
	<c path="haxe.Int32"/>
</f></clamp>
		<toInt public="1" get="inline" set="null" line="45" static="1"><f a="x">
	<c path="haxe.Int32"/>
	<c path="Int"/>
</f></toInt>
		<toNativeInt public="1" get="inline" set="null" line="54" static="1"><f a="x">
	<c path="haxe.Int32"/>
	<c path="Int"/>
</f></toNativeInt>
		<add public="1" get="inline" set="null" line="58" static="1"><f a="a:b">
	<c path="haxe.Int32"/>
	<c path="haxe.Int32"/>
	<c path="haxe.Int32"/>
</f></add>
		<sub public="1" get="inline" set="null" line="62" static="1"><f a="a:b">
	<c path="haxe.Int32"/>
	<c path="haxe.Int32"/>
	<c path="haxe.Int32"/>
</f></sub>
		<mul public="1" get="inline" set="null" line="66" static="1"><f a="a:b">
	<c path="haxe.Int32"/>
	<c path="haxe.Int32"/>
	<c path="haxe.Int32"/>
</f></mul>
		<div public="1" get="inline" set="null" line="74" static="1"><f a="a:b">
	<c path="haxe.Int32"/>
	<c path="haxe.Int32"/>
	<c path="haxe.Int32"/>
</f></div>
		<mod public="1" get="inline" set="null" line="78" static="1"><f a="a:b">
	<c path="haxe.Int32"/>
	<c path="haxe.Int32"/>
	<c path="haxe.Int32"/>
</f></mod>
		<shl public="1" get="inline" set="null" line="82" static="1"><f a="a:b">
	<c path="haxe.Int32"/>
	<c path="Int"/>
	<c path="haxe.Int32"/>
</f></shl>
		<shr public="1" get="inline" set="null" line="86" static="1"><f a="a:b">
	<c path="haxe.Int32"/>
	<c path="Int"/>
	<c path="haxe.Int32"/>
</f></shr>
		<ushr public="1" get="inline" set="null" line="90" static="1"><f a="a:b">
	<c path="haxe.Int32"/>
	<c path="Int"/>
	<c path="haxe.Int32"/>
</f></ushr>
		<and public="1" get="inline" set="null" line="94" static="1"><f a="a:b">
	<c path="haxe.Int32"/>
	<c path="haxe.Int32"/>
	<c path="haxe.Int32"/>
</f></and>
		<or public="1" get="inline" set="null" line="98" static="1"><f a="a:b">
	<c path="haxe.Int32"/>
	<c path="haxe.Int32"/>
	<c path="haxe.Int32"/>
</f></or>
		<xor public="1" get="inline" set="null" line="102" static="1"><f a="a:b">
	<c path="haxe.Int32"/>
	<c path="haxe.Int32"/>
	<c path="haxe.Int32"/>
</f></xor>
		<neg public="1" get="inline" set="null" line="106" static="1"><f a="a">
	<c path="haxe.Int32"/>
	<c path="haxe.Int32"/>
</f></neg>
		<isNeg public="1" get="inline" set="null" line="110" static="1"><f a="a">
	<c path="haxe.Int32"/>
	<e path="Bool"/>
</f></isNeg>
		<isZero public="1" get="inline" set="null" line="114" static="1"><f a="a">
	<c path="haxe.Int32"/>
	<e path="Bool"/>
</f></isZero>
		<complement public="1" get="inline" set="null" line="118" static="1"><f a="a">
	<c path="haxe.Int32"/>
	<c path="haxe.Int32"/>
</f></complement>
		<compare public="1" get="inline" set="null" line="122" static="1"><f a="a:b">
	<c path="haxe.Int32"/>
	<c path="haxe.Int32"/>
	<c path="Int"/>
</f></compare>
		<ucompare public="1" set="method" line="133" static="1">
			<f a="a:b">
				<c path="haxe.Int32"/>
				<c path="haxe.Int32"/>
				<c path="Int"/>
			</f>
			<haxe_doc>Compare two Int32 in unsigned mode.</haxe_doc>
		</ucompare>
	</class>
	<class path="haxe.Json" params="" file="C:\Motion-Twin\Haxe/std/haxe/Json.hx">
		<parse public="1" set="method" line="335" static="1"><f a="text">
	<c path="String"/>
	<d/>
</f></parse>
		<stringify public="1" set="method" line="346" static="1"><f a="value">
	<d/>
	<c path="String"/>
</f></stringify>
		<parseString set="method" line="275"><f a=""><c path="String"/></f></parseString>
		<parseRec set="method" line="186"><f a=""><d/></f></parseRec>
		<nextChar get="inline" set="null" line="182"><f a=""><c path="Int"/></f></nextChar>
		<invalidChar set="method" line="177"><f a=""><e path="Void"/></f></invalidChar>
		<doParse set="method" line="170"><f a="str">
	<c path="String"/>
	<unknown/>
</f></doParse>
		<quote set="method" line="124"><f a="s">
	<c path="String"/>
	<e path="Void"/>
</f></quote>
		<toStringRec set="method" line="77"><f a="v">
	<d/>
	<e path="Void"/>
</f></toStringRec>
		<objString set="method" line="73"><f a="v">
	<d/>
	<e path="Void"/>
</f></objString>
		<classString set="method" line="68"><f a="v">
	<d/>
	<e path="Void"/>
</f></classString>
		<fieldsString set="method" line="52"><f a="v:fields">
	<d/>
	<c path="Array"><c path="String"/></c>
	<e path="Void"/>
</f></fieldsString>
		<toString set="method" line="46"><f a="v">
	<d/>
	<c path="String"/>
</f></toString>
		<reg_float><c path="EReg"/></reg_float>
		<pos><c path="Int"/></pos>
		<str><c path="String"/></str>
		<buf><c path="StringBuf"/></buf>
		<new set="method" line="43"><f a=""><e path="Void"/></f></new>
		<haxe_doc>Crossplatform JSON API : it will automatically use the optimized native API if available.
	Use -D haxeJSON to force usage of the haXe implementation even if a native API is found : this will provide
	extra encoding features such as enums (replaced by their index), Hashs and Iterable.</haxe_doc>
	</class>
	<class path="haxe.Log" params="" file="C:\Motion-Twin\Haxe/std/haxe/Log.hx">
		<trace public="1" set="dynamic" line="29" static="1"><f a="v:?infos">
	<d/>
	<t path="haxe.PosInfos"/>
	<e path="Void"/>
</f></trace>
		<clear public="1" set="dynamic" line="54" static="1"><f a=""><e path="Void"/></f></clear>
		<setColor public="1" set="dynamic" line="63" static="1"><f a="rgb">
	<c path="Int"/>
	<e path="Void"/>
</f></setColor>
	</class>
	<typedef path="haxe.PosInfos" params="" file="C:\Motion-Twin\Haxe/std/haxe/PosInfos.hx"><a>
	<methodName><c path="String"/></methodName>
	<lineNumber><c path="Int"/></lineNumber>
	<fileName><c path="String"/></fileName>
	<customParams>
		<c path="Array"><d/></c>
		<meta><m n=":optional"/></meta>
	</customParams>
	<className><c path="String"/></className>
</a></typedef>
	<class path="haxe.Timer" params="" file="C:\Motion-Twin\Haxe\lib\nme/3,5,5/haxe/Timer.hx">
		<delay public="1" set="method" line="54" static="1">
			<f a="f:time_ms">
				<f a=""><e path="Void"/></f>
				<c path="Int"/>
				<c path="haxe.Timer"/>
			</f>
			<haxe_doc>This will delay the call to [f] for the given time. [f] will only be called once.</haxe_doc>
		</delay>
		<measure public="1" params="T" set="method" line="68" static="1">
			<f a="f:?pos">
				<f a=""><c path="measure.T"/></f>
				<t path="haxe.PosInfos"/>
				<c path="measure.T"/>
			</f>
			<haxe_doc>Measure the time it takes to execute the function [f] and trace it. Returns the value returned by [f].</haxe_doc>
		</measure>
		<stamp public="1" set="method" line="78" static="1">
			<f a=""><c path="Float"/></f>
			<haxe_doc>Returns the most precise timestamp, in seconds. The value itself might differ depending on platforms, only differences between two values make sense.</haxe_doc>
		</stamp>
		<run public="1" set="dynamic" line="48">
			<f a=""><e path="Void"/></f>
			<haxe_doc>This is the [run()] method that is called when the Timer executes. It can be either overriden in subclasses or directly rebinded with another function-value.</haxe_doc>
		</run>
		<stop public="1" set="method" line="32">
			<f a=""><e path="Void"/></f>
			<haxe_doc>Stop the timer definitely.</haxe_doc>
		</stop>
		<id><t path="Null"><c path="Int"/></t></id>
		<new public="1" set="method" line="16">
			<f a="time_ms">
				<c path="Int"/>
				<e path="Void"/>
			</f>
			<haxe_doc>Create a new timer that will run every [time_ms] (in milliseconds).</haxe_doc>
		</new>
	</class>
	<class path="haxe.io.BytesBuffer" params="" file="C:\Motion-Twin\Haxe/std/haxe/io/BytesBuffer.hx">
		<getBytes public="1" set="method" line="126">
			<f a=""><c path="haxe.io.Bytes"/></f>
			<haxe_doc>Returns either a copy or a reference of the current bytes.
		Once called, the buffer can no longer be used.</haxe_doc>
		</getBytes>
		<addBytes public="1" get="inline" set="null" line="100"><f a="src:pos:len">
	<c path="haxe.io.Bytes"/>
	<c path="Int"/>
	<c path="Int"/>
	<e path="Void"/>
</f></addBytes>
		<add public="1" get="inline" set="null" line="81"><f a="src">
	<c path="haxe.io.Bytes"/>
	<e path="Void"/>
</f></add>
		<addByte public="1" get="inline" set="null" line="63"><f a="byte">
	<c path="Int"/>
	<e path="Void"/>
</f></addByte>
		<b><c path="flash.utils.ByteArray"/></b>
		<new public="1" set="method" line="45"><f a=""><e path="Void"/></f></new>
	</class>
	<typedef path="haxe.io.BytesData" params="" file="C:\Motion-Twin\Haxe/std/haxe/io/BytesData.hx"><c path="flash.utils.ByteArray"/></typedef>
	<class path="haxe.io.Input" params="" file="C:\Motion-Twin\Haxe/std/haxe/io/Input.hx">
		<getDoubleSig set="method" line="430"><f a="bytes">
	<c path="Array"><c path="Int"/></c>
	<c path="Int"/>
</f></getDoubleSig>
		<readString public="1" set="method" line="408"><f a="len">
	<c path="Int"/>
	<c path="String"/>
</f></readString>
		<readInt32 public="1" set="method" line="393"><f a=""><c path="haxe.Int32"/></f></readInt32>
		<readUInt30 public="1" set="method" line="384"><f a=""><c path="Int"/></f></readUInt30>
		<readInt31 public="1" set="method" line="367"><f a=""><c path="Int"/></f></readInt31>
		<readUInt24 public="1" set="method" line="360"><f a=""><c path="Int"/></f></readUInt24>
		<readInt24 public="1" set="method" line="350"><f a=""><c path="Int"/></f></readInt24>
		<readUInt16 public="1" set="method" line="344"><f a=""><c path="Int"/></f></readUInt16>
		<readInt16 public="1" set="method" line="335"><f a=""><c path="Int"/></f></readInt16>
		<readInt8 public="1" set="method" line="328"><f a=""><c path="Int"/></f></readInt8>
		<readDouble public="1" set="method" line="255"><f a=""><c path="Float"/></f></readDouble>
		<readFloat public="1" set="method" line="201"><f a=""><c path="Float"/></f></readFloat>
		<readLine public="1" set="method" line="184"><f a=""><c path="String"/></f></readLine>
		<readUntil public="1" set="method" line="176"><f a="end">
	<c path="Int"/>
	<c path="String"/>
</f></readUntil>
		<read public="1" set="method" line="164"><f a="nbytes">
	<c path="Int"/>
	<c path="haxe.io.Bytes"/>
</f></read>
		<readFullBytes public="1" set="method" line="156"><f a="s:pos:len">
	<c path="haxe.io.Bytes"/>
	<c path="Int"/>
	<c path="Int"/>
	<e path="Void"/>
</f></readFullBytes>
		<readAll public="1" set="method" line="80"><f a="?bufsize">
	<c path="Int"/>
	<c path="haxe.io.Bytes"/>
</f></readAll>
		<setEndian set="method" line="73"><f a="b">
	<e path="Bool"/>
	<e path="Bool"/>
</f></setEndian>
		<close public="1" set="method" line="70"><f a=""><e path="Void"/></f></close>
		<readBytes public="1" set="method" line="49"><f a="s:pos:len">
	<c path="haxe.io.Bytes"/>
	<c path="Int"/>
	<c path="Int"/>
	<c path="Int"/>
</f></readBytes>
		<readByte public="1" set="method" line="40"><f a=""><c path="Int"/></f></readByte>
		<bigEndian public="1" set="setEndian"><e path="Bool"/></bigEndian>
		<haxe_doc>An Input is an abstract reader. See other classes in the [haxe.io] package
	for several possible implementations.</haxe_doc>
	</class>
	<class path="haxe.io.BytesInput" params="" file="C:\Motion-Twin\Haxe/std/haxe/io/BytesInput.hx">
		<extends path="haxe.io.Input"/>
		<readString public="1" set="method" line="167" override="1"><f a="len">
	<c path="Int"/>
	<c path="String"/>
</f></readString>
		<readInt32 public="1" set="method" line="163" override="1"><f a=""><c path="haxe.Int32"/></f></readInt32>
		<readUInt30 public="1" set="method" line="156" override="1"><f a=""><c path="Int"/></f></readUInt30>
		<readInt31 public="1" set="method" line="149" override="1"><f a=""><c path="Int"/></f></readInt31>
		<readUInt16 public="1" set="method" line="145" override="1"><f a=""><c path="Int"/></f></readUInt16>
		<readInt16 public="1" set="method" line="141" override="1"><f a=""><c path="Int"/></f></readInt16>
		<readInt8 public="1" set="method" line="137" override="1"><f a=""><c path="Int"/></f></readInt8>
		<readDouble public="1" set="method" line="133" override="1"><f a=""><c path="Float"/></f></readDouble>
		<readFloat public="1" set="method" line="129" override="1"><f a=""><c path="Float"/></f></readFloat>
		<setEndian set="method" line="123" override="1"><f a="e">
	<e path="Bool"/>
	<e path="Bool"/>
</f></setEndian>
		<readBytes public="1" set="method" line="76" override="1"><f a="buf:pos:len">
	<c path="haxe.io.Bytes"/>
	<c path="Int"/>
	<c path="Int"/>
	<c path="Int"/>
</f></readBytes>
		<readByte public="1" set="method" line="55" override="1"><f a=""><c path="Int"/></f></readByte>
		<b><t path="haxe.io.BytesData"/></b>
		<new public="1" set="method" line="34"><f a="b:?pos:?len">
	<c path="haxe.io.Bytes"/>
	<c path="Int"/>
	<c path="Int"/>
	<e path="Void"/>
</f></new>
	</class>
	<class path="haxe.io.Output" params="" file="C:\Motion-Twin\Haxe/std/haxe/io/Output.hx">
		<LN2 line="34" static="1"><c path="Float"/></LN2>
		<writeString public="1" set="method" line="348"><f a="s">
	<c path="String"/>
	<e path="Void"/>
</f></writeString>
		<writeInput public="1" set="method" line="326"><f a="i:?bufsize">
	<c path="haxe.io.Input"/>
	<c path="Int"/>
	<e path="Void"/>
</f></writeInput>
		<prepare public="1" set="method" line="323">
			<f a="nbytes">
				<c path="Int"/>
				<e path="Void"/>
			</f>
			<haxe_doc>Inform that we are about to write at least a specified number of bytes.
		The underlying implementation can allocate proper working space depending
		on this information, or simply ignore it. This is not a mandatory call
		but a tip and is only used in some specific cases.</haxe_doc>
		</prepare>
		<writeInt32 public="1" set="method" line="303"><f a="x">
	<c path="haxe.Int32"/>
	<e path="Void"/>
</f></writeInt32>
		<writeUInt30 public="1" set="method" line="288"><f a="x">
	<c path="Int"/>
	<e path="Void"/>
</f></writeUInt30>
		<writeInt31 public="1" set="method" line="271"><f a="x">
	<c path="Int"/>
	<e path="Void"/>
</f></writeInt31>
		<writeUInt24 public="1" set="method" line="258"><f a="x">
	<c path="Int"/>
	<e path="Void"/>
</f></writeUInt24>
		<writeInt24 public="1" set="method" line="253"><f a="x">
	<c path="Int"/>
	<e path="Void"/>
</f></writeInt24>
		<writeUInt16 public="1" set="method" line="242"><f a="x">
	<c path="Int"/>
	<e path="Void"/>
</f></writeUInt16>
		<writeInt16 public="1" set="method" line="237"><f a="x">
	<c path="Int"/>
	<e path="Void"/>
</f></writeInt16>
		<writeInt8 public="1" set="method" line="231"><f a="x">
	<c path="Int"/>
	<e path="Void"/>
</f></writeInt8>
		<writeDouble public="1" set="method" line="154"><f a="x">
	<c path="Float"/>
	<e path="Void"/>
</f></writeDouble>
		<writeFloat public="1" set="method" line="100"><f a="x">
	<c path="Float"/>
	<e path="Void"/>
</f></writeFloat>
		<writeFullBytes public="1" set="method" line="92"><f a="s:pos:len">
	<c path="haxe.io.Bytes"/>
	<c path="Int"/>
	<c path="Int"/>
	<e path="Void"/>
</f></writeFullBytes>
		<write public="1" set="method" line="81"><f a="s">
	<c path="haxe.io.Bytes"/>
	<e path="Void"/>
</f></write>
		<setEndian set="method" line="74"><f a="b">
	<e path="Bool"/>
	<e path="Bool"/>
</f></setEndian>
		<close public="1" set="method" line="71"><f a=""><e path="Void"/></f></close>
		<flush public="1" set="method" line="68"><f a=""><e path="Void"/></f></flush>
		<writeBytes public="1" set="method" line="45"><f a="s:pos:len">
	<c path="haxe.io.Bytes"/>
	<c path="Int"/>
	<c path="Int"/>
	<c path="Int"/>
</f></writeBytes>
		<writeByte public="1" set="method" line="41"><f a="c">
	<c path="Int"/>
	<e path="Void"/>
</f></writeByte>
		<bigEndian public="1" set="setEndian"><e path="Bool"/></bigEndian>
		<haxe_doc>An Output is an abstract write. A specific output implementation will only
	have to override the [writeChar] and maybe the [write], [flush] and [close]
	methods. See [File.write] and [String.write] for two ways of creating an
	Output.</haxe_doc>
	</class>
	<class path="haxe.io.BytesOutput" params="" file="C:\Motion-Twin\Haxe/std/haxe/io/BytesOutput.hx">
		<extends path="haxe.io.Output"/>
		<getBytes public="1" set="method" line="126"><f a=""><c path="haxe.io.Bytes"/></f></getBytes>
		<writeString public="1" set="method" line="120" override="1"><f a="s">
	<c path="String"/>
	<e path="Void"/>
</f></writeString>
		<prepare public="1" set="method" line="111" override="1"><f a="size">
	<c path="Int"/>
	<e path="Void"/>
</f></prepare>
		<writeInt32 public="1" set="method" line="107" override="1"><f a="x">
	<c path="haxe.Int32"/>
	<e path="Void"/>
</f></writeInt32>
		<writeUInt30 public="1" set="method" line="102" override="1"><f a="x">
	<c path="Int"/>
	<e path="Void"/>
</f></writeUInt30>
		<writeInt31 public="1" set="method" line="95" override="1"><f a="x">
	<c path="Int"/>
	<e path="Void"/>
</f></writeInt31>
		<writeUInt16 public="1" set="method" line="90" override="1"><f a="x">
	<c path="Int"/>
	<e path="Void"/>
</f></writeUInt16>
		<writeInt16 public="1" set="method" line="85" override="1"><f a="x">
	<c path="Int"/>
	<e path="Void"/>
</f></writeInt16>
		<writeInt8 public="1" set="method" line="79" override="1"><f a="x">
	<c path="Int"/>
	<e path="Void"/>
</f></writeInt8>
		<writeDouble public="1" set="method" line="75" override="1"><f a="f">
	<c path="Float"/>
	<e path="Void"/>
</f></writeDouble>
		<writeFloat public="1" set="method" line="71" override="1"><f a="f">
	<c path="Float"/>
	<e path="Void"/>
</f></writeFloat>
		<setEndian set="method" line="65" override="1"><f a="e">
	<e path="Bool"/>
	<e path="Bool"/>
</f></setEndian>
		<writeBytes public="1" set="method" line="52" override="1"><f a="buf:pos:len">
	<c path="haxe.io.Bytes"/>
	<c path="Int"/>
	<c path="Int"/>
	<c path="Int"/>
</f></writeBytes>
		<writeByte public="1" set="method" line="44" override="1"><f a="c">
	<c path="Int"/>
	<e path="Void"/>
</f></writeByte>
		<b><c path="flash.utils.ByteArray"/></b>
		<new public="1" set="method" line="35"><f a=""><e path="Void"/></f></new>
	</class>
	<class path="haxe.io.Eof" params="" file="C:\Motion-Twin\Haxe/std/haxe/io/Eof.hx">
		<toString set="method" line="33"><f a=""><c path="String"/></f></toString>
		<new public="1" set="method" line="31"><f a=""><e path="Void"/></f></new>
		<haxe_doc>This exception is raised when reading while data is no longer available in the [Input].</haxe_doc>
	</class>
	<enum path="haxe.io.Error" params="" file="C:\Motion-Twin\Haxe/std/haxe/io/Error.hx">
		<Overflow><haxe_doc>An integer value is outside its allowed range</haxe_doc></Overflow>
		<OutsideBounds><haxe_doc>An operation on Bytes is outside of its valid range</haxe_doc></OutsideBounds>
		<Custom a="e">
			<d/>
			<haxe_doc>Other errors</haxe_doc>
		</Custom>
		<Blocked><haxe_doc>The IO is set into nonblocking mode and some data cannot be read or written</haxe_doc></Blocked>
		<haxe_doc>The possible IO errors that can occur</haxe_doc>
	</enum>
	<typedef path="nme.Vector" params="T" file="C:\Motion-Twin\Haxe\lib\nme/3,5,5/nme/Vector.hx"><c path="flash.Vector"><c path="nme.Vector.T"/></c></typedef>
	<typedef path="nme.display.BitmapData" params="" file="C:\Motion-Twin\Haxe\lib\nme/3,5,5/nme/display/BitmapData.hx"><c path="flash.display.BitmapData"/></typedef>
	<typedef path="nme.display.Graphics" params="" file="C:\Motion-Twin\Haxe\lib\nme/3,5,5/nme/display/Graphics.hx"><c path="flash.display.Graphics"/></typedef>
	<class path="nme.display.Tilesheet" params="" file="C:\Motion-Twin\Haxe\lib\nme/3,5,5/nme/display/Tilesheet.hx">
		<TILE_SCALE public="1" get="inline" set="null" line="137" static="1"><c path="Int"/></TILE_SCALE>
		<TILE_ROTATION public="1" get="inline" set="null" line="138" static="1"><c path="Int"/></TILE_ROTATION>
		<TILE_RGB public="1" get="inline" set="null" line="139" static="1"><c path="Int"/></TILE_RGB>
		<TILE_ALPHA public="1" get="inline" set="null" line="140" static="1"><c path="Int"/></TILE_ALPHA>
		<TILE_TRANS_2x2 public="1" get="inline" set="null" line="144" static="1"><c path="Int"/></TILE_TRANS_2x2>
		<TILE_BLEND_NORMAL public="1" get="inline" set="null" line="147" static="1"><c path="Int"/></TILE_BLEND_NORMAL>
		<TILE_BLEND_ADD public="1" get="inline" set="null" line="148" static="1"><c path="Int"/></TILE_BLEND_ADD>
		<defaultRatio line="155" static="1"><t path="nme.geom.Point"/></defaultRatio>
		<drawTiles public="1" set="method" line="271">
			<f a="graphics:tileData:?smooth:?flags">
				<t path="nme.display.Graphics"/>
				<c path="Array"><c path="Float"/></c>
				<e path="Bool"/>
				<c path="Int"/>
				<e path="Void"/>
			</f>
			<haxe_doc>* Fast method to draw a batch of tiles using a Tilesheet
	 * 
	 * The input array accepts the x, y and tile ID for each tile you wish to draw.
	 * For example, an array of [ 0, 0, 0, 10, 10, 1 ] would draw tile 0 to(0, 0) and
	 * tile 1 to(10, 10)
	 * 
	 * You can also set flags for TILE_SCALE, TILE_ROTATION, TILE_RGB and
	 * TILE_ALPHA.
	 * 
	 * Depending on which flags are active, this is the full order of the array:
	 * 
	 * [ x, y, tile ID, scale, rotation, red, green, blue, alpha, x, y ... ]
	 * 
	 * @param	graphics		The native.display.Graphics object to use for drawing
	 * @param	tileData		An array of all position, ID and optional values for use in drawing
	 * @param	smooth		(Optional) Whether drawn tiles should be smoothed(Default: false)
	 * @param	flags		(Optional) Flags to enable scale, rotation, RGB and/or alpha when drawing(Default: 0)</haxe_doc>
		</drawTiles>
		<adjustLen set="method" line="240"><f a="vec:len">
	<t path="nme.Vector"><c path="Float"/></t>
	<t path="UInt"/>
	<t path="nme.Vector"><c path="Float"/></t>
</f></adjustLen>
		<adjustIndices set="method" line="209"><f a="vec:len">
	<t path="nme.Vector"><c path="Int"/></t>
	<t path="UInt"/>
	<t path="nme.Vector"><c path="Int"/></t>
</f></adjustIndices>
		<adjustIDs set="method" line="194"><f a="vec:len">
	<t path="nme.Vector"><c path="Int"/></t>
	<t path="UInt"/>
	<t path="nme.Vector"><c path="Int"/></t>
</f></adjustIDs>
		<addTileRect public="1" set="method" line="185"><f a="rectangle:?centerPoint">
	<t path="nme.geom.Rectangle"/>
	<t path="nme.geom.Point"/>
	<e path="Void"/>
</f></addTileRect>
		<_uvs><t path="nme.Vector"><c path="Float"/></t></_uvs>
		<_indices><t path="nme.Vector"><c path="Int"/></t></_indices>
		<_vertices><t path="nme.Vector"><c path="Float"/></t></_vertices>
		<_ids><t path="nme.Vector"><c path="Int"/></t></_ids>
		<tileUVs><c path="Array"><t path="nme.geom.Rectangle"/></c></tileUVs>
		<tiles><c path="Array"><t path="nme.geom.Rectangle"/></c></tiles>
		<tilePoints><c path="Array"><t path="nme.geom.Point"/></c></tilePoints>
		<bitmapWidth><c path="Int"/></bitmapWidth>
		<bitmapHeight><c path="Int"/></bitmapHeight>
		<nmeBitmap public="1">
			<t path="nme.display.BitmapData"/>
			<haxe_doc>* @private</haxe_doc>
		</nmeBitmap>
		<new public="1" set="method" line="167"><f a="inImage">
	<t path="nme.display.BitmapData"/>
	<e path="Void"/>
</f></new>
	</class>
	<typedef path="nme.geom.Matrix" params="" file="C:\Motion-Twin\Haxe\lib\nme/3,5,5/nme/geom/Matrix.hx"><c path="flash.geom.Matrix"/></typedef>
	<typedef path="nme.geom.Point" params="" file="C:\Motion-Twin\Haxe\lib\nme/3,5,5/nme/geom/Point.hx"><c path="flash.geom.Point"/></typedef>
	<typedef path="nme.geom.Rectangle" params="" file="C:\Motion-Twin\Haxe\lib\nme/3,5,5/nme/geom/Rectangle.hx"><c path="flash.geom.Rectangle"/></typedef>
	<class path="starling.core.RenderSupport" params="" file="starling/core/RenderSupport.hx" extern="1">
		<transformMatrixForObject public="1" set="method" static="1"><f a="matrix:object">
	<c path="flash.geom.Matrix"/>
	<c path="starling.display.DisplayObject"/>
	<e path="Void"/>
</f></transformMatrixForObject>
		<setBlendFactors public="1" set="method" static="1"><f a="premultipliedAlpha:?blendMode">
	<e path="Bool"/>
	<c path="String"/>
	<e path="Void"/>
</f></setBlendFactors>
		<clear public="1" set="method" static="1"><f a="?rgb:?alpha">
	<t path="UInt"/>
	<c path="Float"/>
	<e path="Void"/>
</f></clear>
		<drawCount public="1" set="null"><c path="Int"/></drawCount>
		<raiseDrawCount public="1" set="method"><f a="?value">
	<t path="UInt"/>
	<e path="Void"/>
</f></raiseDrawCount>
		<nextFrame public="1" set="method"><f a=""><e path="Void"/></f></nextFrame>
		<finishQuadBatch public="1" set="method"><f a=""><e path="Void"/></f></finishQuadBatch>
		<batchQuad public="1" set="method"><f a="quad:parentAlpha:?texture:?smoothing">
	<c path="starling.display.Quad"/>
	<c path="Float"/>
	<c path="starling.textures.Texture"/>
	<c path="String"/>
	<e path="Void"/>
</f></batchQuad>
		<blendMode public="1"><c path="String"/></blendMode>
		<applyBlendMode public="1" set="method"><f a="premultipliedAlpha">
	<e path="Bool"/>
	<e path="Void"/>
</f></applyBlendMode>
		<resetBlendMode public="1" set="method"><f a=""><e path="Void"/></f></resetBlendMode>
		<popBlendMode public="1" set="method"><f a=""><e path="Void"/></f></popBlendMode>
		<pushBlendMode public="1" set="method"><f a=""><e path="Void"/></f></pushBlendMode>
		<mvpMatrix3D public="1" set="null"><c path="flash.geom.Matrix3D"/></mvpMatrix3D>
		<mvpMatrix public="1" set="null"><c path="flash.geom.Matrix"/></mvpMatrix>
		<resetMatrix public="1" set="method"><f a=""><e path="Void"/></f></resetMatrix>
		<popMatrix public="1" set="method"><f a=""><e path="Void"/></f></popMatrix>
		<pushMatrix public="1" set="method"><f a=""><e path="Void"/></f></pushMatrix>
		<transformMatrix public="1" set="method"><f a="object">
	<c path="starling.display.DisplayObject"/>
	<e path="Void"/>
</f></transformMatrix>
		<scaleMatrix public="1" set="method"><f a="sx:sy">
	<c path="Float"/>
	<c path="Float"/>
	<e path="Void"/>
</f></scaleMatrix>
		<rotateMatrix public="1" set="method"><f a="angle">
	<c path="Float"/>
	<e path="Void"/>
</f></rotateMatrix>
		<translateMatrix public="1" set="method"><f a="dx:dy">
	<c path="Float"/>
	<c path="Float"/>
	<e path="Void"/>
</f></translateMatrix>
		<loadIdentity public="1" set="method"><f a=""><e path="Void"/></f></loadIdentity>
		<setOrthographicProjection public="1" set="method"><f a="width:height">
	<c path="Float"/>
	<c path="Float"/>
	<e path="Void"/>
</f></setOrthographicProjection>
		<dispose public="1" set="method"><f a=""><e path="Void"/></f></dispose>
		<new public="1" set="method"><f a=""><e path="Void"/></f></new>
	</class>
	<class path="starling.display.Quad" params="" file="starling/display/Quad.hx" extern="1">
		<extends path="starling.display.DisplayObject"/>
		<tinted public="1" set="null"><e path="Bool"/></tinted>
		<copyVertexDataTo public="1" set="method"><f a="targetData:?targetVertexID">
	<c path="starling.utils.VertexData"/>
	<c path="Int"/>
	<e path="Void"/>
</f></copyVertexDataTo>
		<color public="1"><t path="UInt"/></color>
		<setVertexAlpha public="1" set="method"><f a="vertexID:alpha">
	<c path="Int"/>
	<c path="Float"/>
	<e path="Void"/>
</f></setVertexAlpha>
		<getVertexAlpha public="1" set="method"><f a="vertexID">
	<c path="Int"/>
	<c path="Float"/>
</f></getVertexAlpha>
		<setVertexColor public="1" set="method"><f a="vertexID:color">
	<c path="Int"/>
	<t path="UInt"/>
	<e path="Void"/>
</f></setVertexColor>
		<getVertexColor public="1" set="method"><f a="vertexID">
	<c path="Int"/>
	<t path="UInt"/>
</f></getVertexColor>
		<new public="1" set="method"><f a="width:height:?color:?premultipliedAlpha">
	<c path="Float"/>
	<c path="Float"/>
	<t path="UInt"/>
	<e path="Bool"/>
	<e path="Void"/>
</f></new>
	</class>
	<class path="starling.display.Image" params="" file="starling/display/Image.hx" extern="1">
		<extends path="starling.display.Quad"/>
		<fromBitmap public="1" set="method" static="1"><f a="bitmap">
	<c path="flash.display.Bitmap"/>
	<c path="starling.display.Image"/>
</f></fromBitmap>
		<smoothing public="1"><c path="String"/></smoothing>
		<texture public="1"><c path="starling.textures.Texture"/></texture>
		<getTexCoords public="1" set="method"><f a="vertexID:?resultPoint">
	<c path="Int"/>
	<c path="flash.geom.Point"/>
	<c path="flash.geom.Point"/>
</f></getTexCoords>
		<setTexCoords public="1" set="method"><f a="vertexID:coords">
	<c path="Int"/>
	<c path="flash.geom.Point"/>
	<e path="Void"/>
</f></setTexCoords>
		<readjustSize public="1" set="method"><f a=""><e path="Void"/></f></readjustSize>
		<new public="1" set="method"><f a="texture">
	<c path="starling.textures.Texture"/>
	<e path="Void"/>
</f></new>
	</class>
	<class path="starling.display.QuadBatch" params="" file="starling/display/QuadBatch.hx" extern="1">
		<extends path="starling.display.DisplayObject"/>
		<compile public="1" set="method" static="1"><f a="container:quadBatches">
	<c path="starling.display.DisplayObjectContainer"/>
	<c path="flash.Vector"><c path="starling.display.QuadBatch"/></c>
	<e path="Void"/>
</f></compile>
		<capacity public="1" set="null"><c path="Int"/></capacity>
		<smoothing public="1" set="null"><c path="String"/></smoothing>
		<texture public="1" set="null"><c path="starling.textures.Texture"/></texture>
		<tinted public="1" set="null"><e path="Bool"/></tinted>
		<numQuads public="1" set="null"><c path="Int"/></numQuads>
		<isStateChange public="1" set="method"><f a="tinted:parentAlpha:texture:smoothing:blendMode:?numQuads">
	<e path="Bool"/>
	<c path="Float"/>
	<c path="starling.textures.Texture"/>
	<c path="String"/>
	<c path="String"/>
	<c path="Int"/>
	<e path="Bool"/>
</f></isStateChange>
		<addQuadBatch public="1" set="method"><f a="quadBatch:?parentAlpha:?modelViewMatrix:?blendMode">
	<c path="starling.display.QuadBatch"/>
	<c path="Float"/>
	<c path="flash.geom.Matrix"/>
	<c path="String"/>
	<e path="Void"/>
</f></addQuadBatch>
		<addQuad public="1" set="method"><f a="quad:?parentAlpha:?texture:?smoothing:?modelViewMatrix:?blendMode">
	<c path="starling.display.Quad"/>
	<c path="Float"/>
	<c path="starling.textures.Texture"/>
	<c path="String"/>
	<c path="flash.geom.Matrix"/>
	<c path="String"/>
	<e path="Void"/>
</f></addQuad>
		<addImage public="1" set="method"><f a="image:?parentAlpha:?modelViewMatrix:?blendMode">
	<c path="starling.display.Image"/>
	<c path="Float"/>
	<c path="flash.geom.Matrix"/>
	<c path="String"/>
	<e path="Void"/>
</f></addImage>
		<reset public="1" set="method"><f a=""><e path="Void"/></f></reset>
		<renderCustom public="1" set="method"><f a="mvpMatrix:?parentAlpha:?blendMode">
	<c path="flash.geom.Matrix"/>
	<c path="Float"/>
	<c path="String"/>
	<e path="Void"/>
</f></renderCustom>
		<clone public="1" set="method"><f a=""><c path="starling.display.QuadBatch"/></f></clone>
		<new public="1" set="method"><f a=""><e path="Void"/></f></new>
	</class>
	<class path="starling.display.Stage" params="" file="starling/display/Stage.hx" extern="1">
		<extends path="starling.display.DisplayObjectContainer"/>
		<stageHeight public="1"><c path="Int"/></stageHeight>
		<stageWidth public="1"><c path="Int"/></stageWidth>
		<color public="1"><t path="UInt"/></color>
	</class>
	<class path="starling.events.Event" params="" file="starling/events/Event.hx" extern="1">
		<ADDED public="1" static="1"><c path="String"/></ADDED>
		<ADDED_TO_STAGE public="1" static="1"><c path="String"/></ADDED_TO_STAGE>
		<ENTER_FRAME public="1" static="1"><c path="String"/></ENTER_FRAME>
		<REMOVED public="1" static="1"><c path="String"/></REMOVED>
		<REMOVED_FROM_STAGE public="1" static="1"><c path="String"/></REMOVED_FROM_STAGE>
		<TRIGGERED public="1" static="1"><c path="String"/></TRIGGERED>
		<FLATTEN public="1" static="1"><c path="String"/></FLATTEN>
		<RESIZE public="1" static="1"><c path="String"/></RESIZE>
		<COMPLETE public="1" static="1"><c path="String"/></COMPLETE>
		<CONTEXT3D_CREATE public="1" static="1"><c path="String"/></CONTEXT3D_CREATE>
		<ROOT_CREATED public="1" static="1"><c path="String"/></ROOT_CREATED>
		<REMOVE_FROM_JUGGLER public="1" static="1"><c path="String"/></REMOVE_FROM_JUGGLER>
		<data public="1" set="null"><d/></data>
		<type public="1" set="null"><c path="String"/></type>
		<currentTarget public="1" set="null"><c path="starling.events.EventDispatcher"/></currentTarget>
		<target public="1" set="null"><c path="starling.events.EventDispatcher"/></target>
		<bubbles public="1" set="null"><e path="Bool"/></bubbles>
		<toString public="1" set="method"><f a=""><c path="String"/></f></toString>
		<stopImmediatePropogation public="1" set="method"><f a=""><e path="Void"/></f></stopImmediatePropogation>
		<stopPropogation public="1" set="method"><f a=""><e path="Void"/></f></stopPropogation>
		<new public="1" set="method"><f a="type:?bubbles:?data">
	<c path="String"/>
	<e path="Bool"/>
	<d/>
	<e path="Void"/>
</f></new>
	</class>
	<class path="starling.events.Touch" params="" file="starling/events/Touch.hx" extern="1">
		<timestamp public="1" set="null"><c path="Float"/></timestamp>
		<target public="1" set="null"><c path="starling.display.DisplayObject"/></target>
		<phase public="1" set="null"><c path="String"/></phase>
		<tapCount public="1" set="null"><c path="Float"/></tapCount>
		<previousGlobalY public="1" set="null"><c path="Float"/></previousGlobalY>
		<previousGlobalX public="1" set="null"><c path="Float"/></previousGlobalX>
		<globalY public="1" set="null"><c path="Float"/></globalY>
		<globalX public="1" set="null"><c path="Float"/></globalX>
		<id public="1" set="null"><c path="Int"/></id>
		<clone public="1" set="method"><f a=""><c path="starling.events.Touch"/></f></clone>
		<toString public="1" set="method"><f a=""><c path="String"/></f></toString>
		<getMovement public="1" set="method"><f a="space:?resultPoint">
	<c path="starling.display.DisplayObject"/>
	<c path="flash.geom.Point"/>
	<c path="flash.geom.Point"/>
</f></getMovement>
		<getPreviousLocation public="1" set="method"><f a="space:?resultPoint">
	<c path="starling.display.DisplayObject"/>
	<c path="flash.geom.Point"/>
	<c path="flash.geom.Point"/>
</f></getPreviousLocation>
		<getLocation public="1" set="method"><f a="space:?resultPoint">
	<c path="starling.display.DisplayObject"/>
	<c path="flash.geom.Point"/>
	<c path="flash.geom.Point"/>
</f></getLocation>
		<new public="1" set="method"><f a="id:globalX:globalY:phase:target">
	<c path="Int"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="String"/>
	<c path="starling.display.DisplayObject"/>
	<e path="Void"/>
</f></new>
	</class>
	<class path="starling.events.TouchEvent" params="" file="starling/events/TouchEvent.hx" extern="1">
		<extends path="starling.events.Event"/>
		<TOUCH public="1" static="1"><c path="String"/></TOUCH>
		<ctrlKey public="1" set="null"><e path="Bool"/></ctrlKey>
		<shiftKey public="1" set="null"><e path="Bool"/></shiftKey>
		<touches public="1" set="null"><c path="flash.Vector"><c path="starling.events.Touch"/></c></touches>
		<timestamp public="1" set="null"><c path="Float"/></timestamp>
		<interactsWith public="1" set="method"><f a="target">
	<c path="starling.display.DisplayObject"/>
	<e path="Bool"/>
</f></interactsWith>
		<getTouch public="1" set="method"><f a="target:?phase">
	<c path="starling.display.DisplayObject"/>
	<c path="String"/>
	<c path="starling.events.Touch"/>
</f></getTouch>
		<getTouches public="1" set="method"><f a="target:?phase">
	<c path="starling.display.DisplayObject"/>
	<c path="String"/>
	<c path="flash.Vector"><c path="starling.events.Touch"/></c>
</f></getTouches>
		<new public="1" set="method"><f a="type:touches:?shiftKey:?ctrlKey:?bubbles">
	<c path="String"/>
	<c path="flash.Vector"><c path="starling.events.Touch"/></c>
	<e path="Bool"/>
	<e path="Bool"/>
	<e path="Bool"/>
	<e path="Void"/>
</f></new>
	</class>
	<class path="starling.events.TouchPhase" params="" file="starling/events/TouchPhase.hx" extern="1">
		<HOVER public="1" static="1"><c path="String"/></HOVER>
		<BEGAN public="1" static="1"><c path="String"/></BEGAN>
		<MOVED public="1" static="1"><c path="String"/></MOVED>
		<STATIONARY public="1" static="1"><c path="String"/></STATIONARY>
		<ENDED public="1" static="1"><c path="String"/></ENDED>
	</class>
	<class path="starling.text.BitmapChar" params="" file="starling/text/BitmapChar.hx" extern="1">
		<height public="1" set="null"><c path="Float"/></height>
		<width public="1" set="null"><c path="Float"/></width>
		<texture public="1" set="null"><c path="starling.textures.Texture"/></texture>
		<xAdvance public="1" set="null"><c path="Float"/></xAdvance>
		<yOffset public="1" set="null"><c path="Float"/></yOffset>
		<xOffset public="1" set="null"><c path="Float"/></xOffset>
		<charID public="1" set="null"><c path="Int"/></charID>
		<createImage public="1" set="method"><f a=""><c path="starling.display.Image"/></f></createImage>
		<getKerning public="1" set="method"><f a="charID">
	<c path="Int"/>
	<c path="Float"/>
</f></getKerning>
		<addKerning public="1" set="method"><f a="charID:amount">
	<c path="Int"/>
	<c path="Float"/>
	<e path="Void"/>
</f></addKerning>
		<new public="1" set="method"><f a="id:texture:xOffset:yOffset:xAdvance">
	<c path="Int"/>
	<c path="starling.textures.Texture"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<e path="Void"/>
</f></new>
	</class>
	<class path="starling.text.BitmapFont" params="" file="starling/text/BitmapFont.hx" extern="1">
		<NATIVE_SIZE public="1" line="13" static="1"><c path="Int"/></NATIVE_SIZE>
		<MINI public="1" static="1"><c path="String"/></MINI>
		<baseline public="1" set="null"><c path="Float"/></baseline>
		<smoothing public="1"><c path="String"/></smoothing>
		<lineHeight public="1"><c path="Float"/></lineHeight>
		<size public="1" set="null"><c path="Float"/></size>
		<name public="1" set="null"><c path="String"/></name>
		<fillQuadBatch public="1" set="method"><f a="quadBatch:width:height:text:?fontSize:?color:?hAlign:?vAlign:?autoScale:?kerning">
	<c path="starling.display.QuadBatch"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="String"/>
	<c path="Float"/>
	<t path="UInt"/>
	<c path="String"/>
	<c path="String"/>
	<e path="Bool"/>
	<e path="Bool"/>
	<e path="Void"/>
</f></fillQuadBatch>
		<createSprite public="1" set="method"><f a="width:height:text:?fontSize:?color:?hAlign:?vAlign:?autoScale:?kerning">
	<c path="Float"/>
	<c path="Float"/>
	<c path="String"/>
	<c path="Float"/>
	<t path="UInt"/>
	<c path="String"/>
	<c path="String"/>
	<e path="Bool"/>
	<e path="Bool"/>
	<c path="starling.display.Sprite"/>
</f></createSprite>
		<addChar public="1" set="method"><f a="charID:bitmapChar">
	<c path="Int"/>
	<c path="starling.text.BitmapChar"/>
	<e path="Void"/>
</f></addChar>
		<getChar public="1" set="method"><f a="charID">
	<c path="Int"/>
	<c path="starling.text.BitmapChar"/>
</f></getChar>
		<dispose public="1" set="method"><f a=""><e path="Void"/></f></dispose>
		<new public="1" set="method"><f a="?texture:?fontXml">
	<c path="starling.textures.Texture"/>
	<c path="flash.xml.XML"/>
	<e path="Void"/>
</f></new>
	</class>
	<class path="starling.text.CharLocation" params="" file="starling/text/BitmapFont.hx" module="starling.text.BitmapFont" extern="1">
		<y public="1"><c path="Float"/></y>
		<x public="1"><c path="Float"/></x>
		<scale public="1"><c path="Float"/></scale>
		<char public="1"><c path="starling.text.BitmapChar"/></char>
		<new public="1" set="method"><f a="char">
	<c path="starling.text.BitmapChar"/>
	<e path="Void"/>
</f></new>
	</class>
	<class path="starling.text.TextField" params="" file="starling/text/TextField.hx" extern="1">
		<extends path="starling.display.DisplayObjectContainer"/>
		<registerBitmapFont public="1" set="method" static="1"><f a="bitmapFont:?name">
	<c path="starling.text.BitmapFont"/>
	<c path="String"/>
	<e path="Void"/>
</f></registerBitmapFont>
		<unregisterBitmapFont public="1" set="method" static="1"><f a="name:?dispose">
	<c path="String"/>
	<e path="Bool"/>
	<e path="Void"/>
</f></unregisterBitmapFont>
		<getBitmapFont public="1" set="method" static="1"><f a="name">
	<c path="String"/>
	<c path="starling.text.BitmapFont"/>
</f></getBitmapFont>
		<autoScale public="1"><e path="Bool"/></autoScale>
		<kerning public="1"><e path="Bool"/></kerning>
		<underline public="1"><e path="Bool"/></underline>
		<italic public="1"><e path="Bool"/></italic>
		<bold public="1"><e path="Bool"/></bold>
		<border public="1"><e path="Bool"/></border>
		<vAlign public="1"><c path="String"/></vAlign>
		<hAlign public="1"><c path="String"/></hAlign>
		<color public="1"><t path="UInt"/></color>
		<fontSize public="1"><c path="Float"/></fontSize>
		<fontName public="1"><c path="String"/></fontName>
		<text public="1"><c path="String"/></text>
		<textBounds public="1" set="null"><c path="flash.geom.Rectangle"/></textBounds>
		<dispose public="1" set="method" override="1"><f a=""><e path="Void"/></f></dispose>
		<new public="1" set="method"><f a="width:height:text:fontName:?fontSize:?char:bold">
	<c path="Int"/>
	<c path="Int"/>
	<c path="String"/>
	<c path="String"/>
	<c path="Float"/>
	<t path="UInt"/>
	<e path="Bool"/>
	<e path="Void"/>
</f></new>
	</class>
	<class path="starling.textures.Texture" params="" file="starling/textures/Texture.hx" extern="1">
		<fromBitmap public="1" set="method" static="1"><f a="data:?generateMipMaps:?optimizeForRenderTexture:?scale">
	<c path="flash.display.Bitmap"/>
	<e path="Bool"/>
	<e path="Bool"/>
	<c path="Float"/>
	<c path="starling.textures.Texture"/>
</f></fromBitmap>
		<fromBitmapData public="1" set="method" static="1"><f a="data:?generateMipMaps:?optimizeForRenderTexture:?scale">
	<c path="flash.display.BitmapData"/>
	<e path="Bool"/>
	<e path="Bool"/>
	<c path="Float"/>
	<c path="starling.textures.Texture"/>
</f></fromBitmapData>
		<fromAtfData public="1" set="method" static="1"><f a="data:?scale">
	<c path="flash.utils.ByteArray"/>
	<c path="Float"/>
	<c path="starling.textures.Texture"/>
</f></fromAtfData>
		<fromTexture public="1" set="method" static="1"><f a="texture:?region:?frame">
	<c path="starling.textures.Texture"/>
	<c path="flash.geom.Rectangle"/>
	<c path="flash.geom.Rectangle"/>
	<c path="starling.textures.Texture"/>
</f></fromTexture>
		<empty public="1" set="method" static="1"><f a="?width:?height:?color:?optimizeForRenderTexture:?scale">
	<c path="Int"/>
	<c path="Int"/>
	<t path="UInt"/>
	<e path="Bool"/>
	<c path="Float"/>
	<c path="starling.textures.Texture"/>
</f></empty>
		<premultipliedAlpha public="1" set="null"><e path="Bool"/></premultipliedAlpha>
		<mipMapping public="1" set="null"><e path="Bool"/></mipMapping>
		<format public="1" set="null"><c path="String"/></format>
		<base public="1" set="null"><c path="flash.display3D.textures.TextureBase"/></base>
		<scale public="1" set="null"><c path="Float"/></scale>
		<height public="1" set="null"><c path="Float"/></height>
		<width public="1" set="null"><c path="Float"/></width>
		<repeat public="1"><e path="Bool"/></repeat>
		<frame public="1" set="null"><c path="flash.geom.Rectangle"/></frame>
		<adjustVertexData public="1" set="method"><f a="vertexData:vertexID:count">
	<c path="starling.utils.VertexData"/>
	<c path="Int"/>
	<c path="Int"/>
	<e path="Void"/>
</f></adjustVertexData>
		<dispose public="1" set="method"><f a=""><e path="Void"/></f></dispose>
	</class>
	<class path="starling.utils.HAlign" params="" file="starling/utils/HAlign.hx" extern="1">
		<LEFT public="1" static="1"><c path="String"/></LEFT>
		<CENTER public="1" static="1"><c path="String"/></CENTER>
		<RIGHT public="1" static="1"><c path="String"/></RIGHT>
		<isValid public="1" set="method" static="1"><f a="hAlign">
	<c path="String"/>
	<e path="Bool"/>
</f></isValid>
	</class>
	<class path="starling.utils.VertexData" params="" file="starling/utils/VertexData.hx" extern="1">
		<ELEMENTS_PER_VERTEX public="1" static="1"><c path="Int"/></ELEMENTS_PER_VERTEX>
		<POSITION_OFFSET public="1" static="1"><c path="Int"/></POSITION_OFFSET>
		<COLOR_OFFSET public="1" static="1"><c path="Int"/></COLOR_OFFSET>
		<TEXCOORD_OFFSET public="1" static="1"><c path="Int"/></TEXCOORD_OFFSET>
		<rawData public="1" set="null"><c path="flash.Vector"><c path="Float"/></c></rawData>
		<numVertices public="1"><c path="Int"/></numVertices>
		<premultipliedAlpha public="1" set="null"><e path="Bool"/></premultipliedAlpha>
		<setPremultipliedAlpha public="1" set="method"><f a="value:?updateData">
	<e path="Bool"/>
	<e path="Bool"/>
	<e path="Void"/>
</f></setPremultipliedAlpha>
		<tinted public="1" set="null"><e path="Bool"/></tinted>
		<getBounds public="1" set="method"><f a="?transformationMatrix:?vertexID:?numVertices:?resultRect">
	<c path="flash.geom.Matrix"/>
	<c path="Int"/>
	<c path="Int"/>
	<c path="flash.geom.Rectangle"/>
	<c path="flash.geom.Rectangle"/>
</f></getBounds>
		<scaleAlpha public="1" set="method"><f a="vertexID:alpha:?numVertices">
	<c path="Int"/>
	<c path="Float"/>
	<c path="Int"/>
	<e path="Void"/>
</f></scaleAlpha>
		<setUniformAlpha public="1" set="method"><f a="alpha">
	<c path="Float"/>
	<e path="Void"/>
</f></setUniformAlpha>
		<setUniformColor public="1" set="method"><f a="color">
	<t path="UInt"/>
	<e path="Void"/>
</f></setUniformColor>
		<transformVertex public="1" set="method"><f a="vertexID:matrix:?numVertices">
	<c path="Int"/>
	<c path="flash.geom.Matrix"/>
	<c path="Int"/>
	<e path="Void"/>
</f></transformVertex>
		<translateVertex public="1" set="method"><f a="vertexID:deltaX:deltaY">
	<c path="Int"/>
	<c path="Float"/>
	<c path="Float"/>
	<e path="Void"/>
</f></translateVertex>
		<getTexCoords public="1" set="method"><f a="vertexID:texCoords">
	<c path="Int"/>
	<c path="flash.geom.Point"/>
	<e path="Void"/>
</f></getTexCoords>
		<setTexCoords public="1" set="method"><f a="vertexID:u:v">
	<c path="Int"/>
	<c path="Float"/>
	<c path="Float"/>
	<e path="Void"/>
</f></setTexCoords>
		<getAlpha public="1" set="method"><f a="vertexID">
	<c path="Int"/>
	<c path="Float"/>
</f></getAlpha>
		<setAlpha public="1" set="method"><f a="vertexID:alpha">
	<c path="Int"/>
	<c path="Float"/>
	<e path="Void"/>
</f></setAlpha>
		<getColor public="1" set="method"><f a="vertexID">
	<c path="Int"/>
	<t path="UInt"/>
</f></getColor>
		<setColor public="1" set="method"><f a="vertexID:color">
	<c path="Int"/>
	<t path="UInt"/>
	<e path="Void"/>
</f></setColor>
		<getPosition public="1" set="method"><f a="vertexID:position">
	<c path="Int"/>
	<c path="flash.geom.Point"/>
	<e path="Void"/>
</f></getPosition>
		<setPosition public="1" set="method"><f a="vertexID:x:y">
	<c path="Int"/>
	<c path="Float"/>
	<c path="Float"/>
	<e path="Void"/>
</f></setPosition>
		<append public="1" set="method"><f a="data">
	<c path="starling.utils.VertexData"/>
	<e path="Void"/>
</f></append>
		<copyTo public="1" set="method"><f a="targetData:?targetVertexID:?vertexID:?numVertices">
	<c path="starling.utils.VertexData"/>
	<c path="Int"/>
	<c path="Int"/>
	<c path="Int"/>
	<e path="Void"/>
</f></copyTo>
		<clone public="1" set="method"><f a="?vertexID:?numVertices">
	<c path="Int"/>
	<c path="Int"/>
	<c path="starling.utils.VertexData"/>
</f></clone>
		<new public="1" set="method"><f a="numVertices:?premultipliedAlpha">
	<c path="Int"/>
	<e path="Bool"/>
	<e path="Void"/>
</f></new>
	</class>
</haxe>